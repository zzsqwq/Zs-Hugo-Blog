<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python初步学习 | Zs's Blog</title>
<meta name=keywords content="Python"><meta name=description content="Python学习笔记
Python的不同解释器


CPython
这是自带的用C语言开发的解释器，因此叫CPython。它也是使用最广的Python解释器。


IPython
这是基于CPython之上的一个交互式解释器，只是相比于CPython多了交互上的优化。


PyPy
它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。他与CPython略有不同。

"><meta name=author content="zzsqwq"><link rel=canonical href=https://blog.zzsqwq.cn/posts/66/><meta name=google-site-verification content="G-WF7TH97J9X"><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://blog.zzsqwq.cn/images/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://blog.zzsqwq.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.zzsqwq.cn/images/favicon-32x32.ico><link rel=apple-touch-icon href=https://blog.zzsqwq.cn/apple-touch-icon.png><link rel=mask-icon href=https://blog.zzsqwq.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.zzsqwq.cn/posts/66/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-WF7TH97J9X"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WF7TH97J9X",{anonymize_ip:!1})}</script><meta property="og:title" content="Python初步学习"><meta property="og:description" content="Python学习笔记
Python的不同解释器


CPython
这是自带的用C语言开发的解释器，因此叫CPython。它也是使用最广的Python解释器。


IPython
这是基于CPython之上的一个交互式解释器，只是相比于CPython多了交互上的优化。


PyPy
它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。他与CPython略有不同。

"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.zzsqwq.cn/posts/66/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-04-18T01:24:00+00:00"><meta property="article:modified_time" content="2020-04-18T01:24:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Python初步学习"><meta name=twitter:description content="Python学习笔记
Python的不同解释器


CPython
这是自带的用C语言开发的解释器，因此叫CPython。它也是使用最广的Python解释器。


IPython
这是基于CPython之上的一个交互式解释器，只是相比于CPython多了交互上的优化。


PyPy
它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。他与CPython略有不同。

"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.zzsqwq.cn/posts/"},{"@type":"ListItem","position":2,"name":"Python初步学习","item":"https://blog.zzsqwq.cn/posts/66/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python初步学习","name":"Python初步学习","description":"Python学习笔记 Python的不同解释器 CPython\n这是自带的用C语言开发的解释器，因此叫CPython。它也是使用最广的Python解释器。\nIPython\n这是基于CPython之上的一个交互式解释器，只是相比于CPython多了交互上的优化。\nPyPy\n它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。他与CPython略有不同。\n","keywords":["Python"],"articleBody":"Python学习笔记 Python的不同解释器 CPython\n这是自带的用C语言开发的解释器，因此叫CPython。它也是使用最广的Python解释器。\nIPython\n这是基于CPython之上的一个交互式解释器，只是相比于CPython多了交互上的优化。\nPyPy\n它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。他与CPython略有不同。\nJython\n这是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。\nIronPython\n这是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。\nPython基础 简单的输入和输出(I/O) 输入 python提供了一个 input() 函数供我们输入使用，这读入的是字符串数据，并返回，可以将返回值存放在一个变量中。input函数中可以带字符串，这段字符串在输入前会打印在屏幕上，这使得我们具有很好的交互性，好比我们写:\nname = input(\"hello,friend! please input your name\") print(\"The input name is \",name) 那么这时候我们运行上述程序，就会提示 hello , friend! please input your name ，这就提示我们应该输入名字。\n这里需要注意的是，input() 函数读入的是一个字符串 str ，就算我们输入了整数他也是一个字符串，如果我们要用真正的整数，那么就需要用 int() 进行类型强制转换。如果其中不是合法的整数，那么会报错。\n输出 python中的输出函数是 print() ，这和 C++ 的printf 差了一个f。我们在函数的参数中传入什么，他就会打印什么。好比我们写 print(\"heelo,world\") ，那么运行就会打印 hello,world 在屏幕上。print 支持我们传入多个参数，好比 printf(\"my name is\",\"zs\") ，两两之间用逗号隔开，这在输出时会被解析成空格，也就是说两段字符串之间有一个空格。当然此函数也可以打印整数等。\n一些规则 缩进 Python中对代码块的区分，不是用C++的大括号，而是用缩进。处于连续同一缩进的是一个代码块，这也是为什么Python又被戏称为游标卡尺语言的原因。当语句以冒号:结尾时，缩进的语句视为代码块。我们通常用一个Tab / 四个空格 的缩进。\n注释 Python的注释用的是 # ，而 C++ 中的注释用的是 \\\\ 。\nCase Sensitive Python中是大小写敏感的，也就是 a 和 A 不是同一个东西。\n数据类型 1. 整数 Python一个很大的好处就是可以处理任意大小的整数，包括负整数。这也是为什么很多大数题大家都喜欢用Python，hhhh。多数地方都用十进制，但是也是支持其他进制的哈~好比 0x 前缀就是16进制。\n2. 浮点数 浮点数是小数，之所以称为浮点数，是因为小数点位置在科学计数法中是可变的。这里需要注意，整数和浮点数在计算机内部存储方式不同，浮点数应该都是 IEEE754 标准吧？整数之间的运算永远都是精确的，包括除法。而浮点数的运算则会有一定的误差。Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。\n3. 字符串 字符串是以单引号 '' 或者双引号 \"\" 括起来的任意文本。我们注意到Python中没有单个字符的概念，就算是单个字符也是一个字符串。如果'' 括起来的字符串内部出现 '' 需要使用\\转义，相同的，如果 \"\" 括起来的字符串内部出现 \"\" 需要转义。好比下面的程序\nprint(\"My name is 'zs'\") #合法 My name is 'zs' print(\"My name is \"zs\"\") #不合法 invalid syntax print(\"My name is \\\"zs\\\"\") #合法 My name is \"zs\" print('My name is \"zs\"') #合法 My name is \"zs\" print('My name is 'zs'') #不合法 invalid syntax print('My name is \\'zs\\'') #合法 My name is 'zs' Python中也有很多转义字符，跟C++的很类似。\\n,\\t,\\\\ 分别代表换行，横向制表，字符\\ 。在python中还支持用 r' ' 表示 '' 内部的字符默认不转义。\nPython在输出多行语句时，可以用 print('''content''') 其中content中的内容，支持用直觉上的换行。\nprint('''python name zs''') # The output python name zs 4. 布尔值 含有 Ture 和 False 两种类型，代表真和假。支持 and , or ,not 三种运算。\n5. 空值 空值是Python中的一个特殊值，用 None 表示。 None不能理解为0，因为0是有意义的，而None是一个特殊的空值。\n变量 变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头。\n变量命名时最好能做到顾名思义，当然也有很多规范的命名规则，可以自行百度。\n在 Python 中我们不需要指定一个变量是特定的类型，它可以在不同的类型之间变来变去，这确实很方便，不过感觉也是很占内存和时间的。\n这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错\n常量 Python中没有C++中的const来限制常量，但是通常用变量名全大写来代表这个变量为一个常量，但是这玩意是个约定俗成的，并不是说你这么写他就真是个常量了。\n字符串和编码 字符编码 字符编码有很多种，不同的语言也对应着不同的字符编码。常见的几个是 ASCII ,Unicode ,UTF-8,GB2313 他们分别是英文和特殊字符的编码，统一的一套编码，可变长的统一编码，常用的中文编码。\nPython的字符串存储 Python 3的的字符串是 Unicode 编码的，也就是说Python的字符串支持多语言，因为这是一套统一的编码。\n对于单个字符的编码，Python提供了 Ord() 函数获取字符的整数表示，chr() 函数通过整数获取对应字符。\nPython中的字符串类型为 str ，一个字符对应若干字节。**如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。**Python对bytes类型的数据用带b前缀的单引号或双引号表示。\n我们可以通过encode('编码方式') 将 str 转变成 bytes 。我们也可以通过 decode('编码方式') 将 bytes 转变为 str 。\nPython为我们提供了一个 len() 函数，如果字符串是 str ，那么计算出的是字符数，如果是 bytes ，那么计算的是字节数。我们为了防止乱码问题，在两者相互转换时推荐用 utf-8 编码。\n由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：\n#!/usr/bin/env python3 # -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；\n第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。而且需要你的编辑器支持 UTF-8编码。\n字符串的格式化输出 第一种方式 Python的 print() 格式化输出和C语言的很像，也是 %d 代表整数，%f 代表浮点数， %s 代表字符串，%s代表十六进制整数。关于格式的指定，好比补0什么的也和C的很像。具体格式如下：\nprint('%2d-%02d' % (3,1)) # 输出 3-01 print('my name is %s' % \"zs\") # 输出 my name is zs 如果我们要在字符串里面输出 % ，那么就需要用 %% 来转义表示 % 。\nprint(\"This is a common %% %s \" % \"字符\") # 输出 This is a common % 字符 第二种方式 除了上面的方法，print 还可以用 .format 的方法进行格式化输出。例如下例子\nprint('{0} name is {1}'.format(\"who\",\"zs\")) #输出 who name is zs List \u0026 tuple (列表和元组) List(列表) List像是一个大杂烩，里面可以有各种类型的东西，是一个有序的集合，也就是说可以通过下标索引。\n我们创建一个列表可以用中括号， Mylist = [\"zs\",\"wx\"] ，这就创建了具有两个元素的列表，第一个元素是字符串 zs 第二个元素是字符串 wx 。这个列表的名字就是 Mylist 。\n我们可以通过 len() 来获取列表中元素的个数，也可以通过下表索引列表的元素，但是要注意下标是从0开始计数的，如果索引出界会报 IndexError 。有趣的是，我们可以通过负的下表来访问元素，是倒着访问的，好比上述列表中 Mylist[-1] 就代表元素 “wx” 。\n我们可以通过 listk = [] ，来创建一个空列表 listk ，如果用 len() 查看长度那么长度为0.\n此外列表中的元素也可以是列表，可以通过类似于二维数组的形式索引。\n列表中，有许多的方法。就像是相对于这个类型内置的一些函数，用法如下：\nMylist = [\"zs\",\"wx\"] print(Mylist) # 输出 ['zs', 'wx'] Mylist.append('Better') # 用于在列表后面追加一个元素 print(Mylist) # 输出 ['zs', 'wx', 'Better'] Mylist.insert(1,'Good') # 用于在下标为1的位置，插入一个元素 print(Mylist) # 输出 ['zs', 'Good', 'wx', 'Better'] popx = Mylist.pop() # 用于删除列表中最后一个元素，并返回元素的值 print(Mylist,popx) # 输出 ['zs', 'Good', 'wx'] Better popx = Mylist.pop(1) # 用于删除列表中下标为1的元素，并返回元素的值 print(Mylist,popx) # 输出 ['zs', 'wx'] Good L = [] # 创建了一个空列表 L print(len(L)) #输出0 Tuple(元组) 元组跟上面的链表差不多，只不过是不可变的，一旦初始化就不能修改，也是可以通过下标访问元素。\n不同的的是，我们定义一个元组是用 () ，好比我们定义 Mytuple = (\"zs\",\"wx\") ，这是含有两个字符串元素的元组，我们可以通过 Mytuple = () 来定义一个空的元组。\n需要注意的是，当我们定义一个只有一个元素的元组，如果我们写成 Mytuple = (\"zs\") ，那么Python会默认解析为这是一个字符串，把括号当初普通的括号，不解释成元组。 那么我们如何定义只有一个元素的元组呢，我们应该写 Mytuple = (\"zs\",) 这样就是只有一个元素的元组。\n元组中的不可变，是指它的指向不变，那么如果好比元组的元素中有一个列表，那么其实这个元组中的列表的元素还是可以改变的。\n条件判断 条件判断是一个经典的语句。用于分支结构。\n用法跟C很像，不过 else if 可以缩写为 elif ，并且因为 if ，else , elif 后面接的都是语句块，因此要加 : 。\nweight = 120 if weight\u003e=200: print(\"too fat\") elif weight\u003c=100: print(\"too thin\") else: print(\"Good\") 循环语句 循环结构也是三大结构之一。\nfor for语句是我C++中最喜欢循环语句。在Python中，他的写法变成了 for x in something: ，下面接相应的循环语句块。这个 x 是变量的名字，something 是某一个容器，可以是列表可以是元组啥的，这个写法的意思就是 遍历 something 中的每个元素，带入变量 x 中，执行循环操作。\n我们通常配合 range() 函数来执行循环操作，通过 range(n) 可以生成从 [0,n) 的整数。\nfor x in list(range(11)): print(x) #输出 0~10 while while语句也是和C语言差不多，当型循环，当满足条件时就执行循环，也记住不要忘记加 : 。\nbreak \u0026 continue break 的作用是结束整个循环。\ncontinue 的作用是跳过这一次循环。\nDict \u0026 Set (字典和集合) Dict 这个字典其实就是C语言中的 map ，人家 Python 直接内置了，属实业界良心。其实就是利用键值对匹配，一个键对应一个值。实现方式为哈希 (Hash) 。\n创建就是 Mydict = {\"zs\":250 , \"wx\":666} 这样第一个元素的键为 “zs” ，对应值为 250 。第二个值与这个的解读类似。我们也可以通过类似于数组的形式往字典里面加元素. Mydict[\"jjh\"] = 100 ，那么这时候就往里面加入了一个键值对。\n字典中每个键值是唯一的，但是值可以相同，类似于函数。我们也可以通过类似于数组的形式，下标为键来访问值。当我们下标在字典中不存在，利用下标访问就会直接报错。Python 为我们提供了另一种方法来满足我们的需求，利用 Mydict.get(键) 可以获得对应的值，当不存在这个键，会返回 None 。此外，我们也可以指定其返回值，Mydict.get(键,something) ，这样当不存在的时候就会返回这个 something 。\n最后，字典中的 Key 只能是不可变对象。\nSet set 就是数学中的集合，具有无序性和唯一性。里面元素不重复，并且无序导致没法通过下标访问。可以用来给一组数据去重。通过 add(key) remove(key) 等函数去除对应值的元素。\n可以通过 \u0026 求交集， | 求并集， - 求差集等。\nset 中的元素也只能是不可变对象。\n函数 调用函数 调用函数的时候要保证参数个数、参数顺序、参数类型满足函数的定义。然后正确的处理好返回值。\n定义函数 函数的定义 普通函数的定义通过 def 来进行，好比我们要写一个求绝对值的函数，那么就可以如下定义\ndef myabs(x): if x\u003e=0: return x else: return -x 这样我们就可以类似调用 myabs(-5) 来获得 -5 的绝对值。\n如果我们想要定义一个空的函数，也就是什么都不做，那么函数内部的语句可以写 pass 。这类似于C++中的分号的作用？大概是。\n通过 函数.__name__ 可以获得函数的真实名字。\n多个返回值的函数 我们可以在 return 后面写多个参数，这样在返回的时候会返回一个元组。我们接受返回值的时候，也可以并拍写多个变量，这样就会把返回值的元组中的各个值依次赋给每个变量。\n函数的参数 Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数，可变参数，关键字参数，这使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。\n默认参数 当我们调用一个函数，有几个参数大多数情况下是一个默认的值，少数时候是变的，那么我们可以用到默认参数，默认参数的使用我们可以在那个参数的后面加上 =something ，这意思说是，这个参数默认为 something\ndef poww(x,n=2): k = 1 while n\u003e0: n = n-1 k = k*x return k 例如上面这个例子，我们要求 $2^5$ ，那么可以调用 poww(2,5) 。那么我们如果要求 $2^2$ ，那么就可以直接调用poww(2) ，另一个参数可以不写，那么就是默认的2。\n需要注意的是，必选参数在前，默认参数要在后。否则话会产生歧义，因为解释器不知道你到底传入的参数是默认参数还是必选参数。\n此外，当我们有多个默认参数的时候，我们要在前面几个默认参数使用默认值，而后面那个用传入参数的时候，我们需要加上参数名，也就是 参数名 = value 这样传入。例子如下：\ndef poww(x,n=2,z=3): k = 1 f = n+z while n\u003e0: f = f-1 k = k*x return k 这时候，我们如果要调用 poww(5,4) ，代表求的是 $5^{4+3}$ ，如果我们要求 $5^{2+7}$ ，可以按照如下方法调用，使用 poww(5,z=7) 。\n最后还有一点很重要，默认参数要指向 不变对象 。否则当我们重复调用会发生错误。\n可变参数 我们很多时候可能需要一个函数内传入不定量个数的参数，这就要用到可变参数，可变参数就是数量可变。\n我们很容易想到，可以往里面传列表或者元组 ，不过这样当我们传之前还有要把所有的参数归到一个列表和元素中，这样太麻烦。Python给出了一个简便写法，我们只需要在参数面前加一个 * ，这样我们就可以传入可变个参数。而且调用的时候，按普通的调用方法来即可，不需要传入元组。\ndef test(*numbers): sum = 0 for i in numbers: sum = sum + i*i return sum print(test(1,2,3)) # 输出 14 那么当这时候我们想往里面传一个元组，或者列表。当然可以挨个用数组访问然后写，不过Python也给了我们一个简便做法，只需要在列表或者元组前面加一个 * ，就可以把它结构解开，然后挨个元素传入函数中。\ndef test(*numbers): sum = 0 for i in numbers: sum = sum + i*i return sum Mylist = list(range(5)) print(test(*Mylist)) #输出30 关键词参数 可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。\ndef myfun(**kw): print(kw) myfun(city = \"jz\",name = \"zs\") # 输出 {'city': 'jz', 'name': 'zs'} Mydict = {\"city\":\"jz\",\"name\":\"zs\"} myfun(**Mydict) # 输出 {'city': 'jz', 'name': 'zs'} 参数前面加 ** 即是关键词参数。当然我们也可以传入参数时，用dict，然后加 ** 解开结构传入。\n命名关键词参数 我们可以在上述的基础上，传入特定的参数，给相应的参数命名。这需要我们在定义各个参数之前，在参数之前加上 * ，好比 def person(name,age,*,city,job) 规定了，我们传入的两个关键词参数名字只能是 city 和和 job 。不过，当我们前面有一个参数是可变参数，那么就可以不用加那个 * 。好比像如下方法定义上面那个函数， def person(name,age,*city,job) 。在这里 city 是一个可变参数，后面的 job 就是一个命名关键词参数。\n参数调用顺序 在函数的参数中，上述各类参数可以组合使用。但是要注意顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。\n函数的递归调用 函数的递归调用就是自己调用自己，QAQ，C++里面搞得也挺多的，就不赘述了。\n高级特性 切片 切片操作感觉真的是Python很方便的一个特性了。\n字符串，列表，元组支持切片。\n好比我们有一个列表，里面有数，0~100，我们要取其中的奇数，那么我们就需要每隔一个数取一个数，我们可以通过for循环来实现这个操作，但是呢，Python有一种更便利的方法来实现，那就是切片。他的用法类似于matlab中的冒号表达式，begin:end:step 这三个变量分别代表起始，终止和步长，也就是每个多少取一个，这三个参数都可以省略，省略时默认为序列起始点，序列终止点，1。这里要注意，序列范围为 [begin,end) ，前闭后开，例子：\nL = list(range(101)) print(L[1:100:2]) # 输出0~100所有的奇数 print(L[-10::2]) # 从倒数第十个数开始输出奇数，输出 [91, 93, 95, 97, 99] print(L[-50:0:-2]) # 从倒数第50个数，往前开始输出奇数，为 51~0中所有奇数 迭代 迭代就是类似于遍历吧，通过 for 可以迭代遍历一个容器内的所有元素。\n字符串和列表，元组，集合，字典这些都是可以用for遍历的，这也叫做可迭代对象。需要注意的是，我们在遍历字典和集合时，因为是无序的，所以两次遍历顺序可能不太一样。\n当我们遍历字典时，默认遍历的是键值。例如下面这样\nL = {\"zs\":\"rj\",\"jjh\":\"nb\"} for key in L: print(key) # 输出 zs jjh for value in L.values(): print(value) # 输出 rj nb for k,v in L.items(): print(k,v) # 输出 zs rj jjh nb 可以注意到，可以同时迭代两个数，或者多个数。\n列表生成器 列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。\n好比我们生成 [1*1,2*2,3*3,···,n*n] 这样的列表，可以用循环实现，也可以用列表生成式。\n列表生成式格式大概是 [元素 规则] 就是前面是要往里面加的元素的表达式，后面是生成的规则。\nL = [x*x for x in range(1,11)] print(L) # 输出[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] D = [x*x for x in range(1,11) if x % 2 == 0] print(D) # 输出[4, 16, 36, 64, 100] 生成器 我们将上述列表生成式外面的 [] 改成 () ，就变成了一个列表生成器。列表生成器里面每个元素不是原来就存在的，而是你要用的时候他按照规则去生成，可以节省空间。他也是一个可迭代对象，可以通过for循环来访问，此外也可以用 next(迭代器) 来获取下一个元素。\n除了上述方法，我们也可以用函数的方法来定义生成器，当一个函数中有了关键字 ： yield 他就不是一个普通的函数了，就变成了一个生成器，按照函数的规则来生成相应数据。规则如下：当我们进入函数的时候，开始从头开始执行，执行到 yield ，函数结束，返回 yield 后面接的内容。然后下次进入函数的时候，从上次结束的地方继续开始，然后这样一直循环，直到再不能取数为止。\n迭代器 凡是可作用于for循环的对象都是Iterable类型，就是可迭代对象；\n凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列，这感觉就像是一个指针呀其实（自我认为），可以通过指针访问可迭代对象中的元素；\n集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。\nPython的for循环本质上就是通过不断调用next()函数实现的，例如：\nfor x in [1, 2, 3, 4, 5]: pass 实际上完全等价于：\n# 首先获得Iterator对象: it = iter([1, 2, 3, 4, 5]) # 循环: while True: try: # 获得下一个值: x = next(it) except StopIteration: # 遇到StopIteration就退出循环 break 函数式编程 高阶函数 map/reduce map() 函数包括两个参数，第一个参数是一个函数，第二个参数是一个序列。map 的作用就是将序列中的每个元素代入到函数中并且求出每个元素对应的值，然后会返回一个相应的 Iterator ，我们可以通过对应的语句，好比 list() ，tuple() 啥的转成对应的序列。\nreduce() 函数也是包括两个参数，一个是函数，一个是序列。reduce 的作用是类似于一个递归的感觉吧大概，好比序列是 L = [1,2,3,4,5] ，有一个函数是 f ，我们暂且不管这个函数的作用是什么，那么如果我们现在调用 reduce(f,L) ，他返回一个 f 函数的返回值，值为 f(f(f(1,2),3),4) 。就是类似于这种嵌套的结构。\nfilter filter() 函数也包括两个参数，一个是函数，一个是序列。他是通过那个函数的返回值是 True or False 来判断是否保留那个序列中的每个元素。返回值也是 Iterator 。\nsorted sorted() 顾名思义，这是一个排序函数，我们往里面传入一个序列，那么他就会默认的对序列按升序排序，并且返回一个这个排序后序列。但是我们传入的序列不会有变动。\n此外，sorted() 里面还可以加关键词 key 键值来确定规则，好比我们可以加 key=abs 这样就可以将序列中所有的元素按照绝对值从小到大的顺序。我们也可以加 reverse=True 来变成降序排序。\n返回函数 我们知道，函数名只是一个指向函数的变量，我们也可以用另一个变量指向这个函数来引用函数，相当于起了一个别名。因此，我们也可以在函数的返回值中返回一个函数，然后将返回值赋值给一个变量，这样就可以通过这个变量来调用返回的函数。\n我们在一个函数中又定义了一个函数，并且，内部函数可以引用外部函数的参数和局部变量，当外部函数返回内部函数时，相关参数和变量都保存在返回的函数中，这种称为“闭包**（Closure）**”的程序结构拥有极大的威力。\n返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。因为这个变量相当于一个静态变量，现在变了，前面相应的结果也会变。\n返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。\n通过 函数.__name__ 可以获得函数的真实名字。\n匿名函数 通过 lambda 可以创建匿名函数，这个就类似于matlab里面的那个 @ 创建的匿名函数。\n格式为： lambda 变量: 返回值\nprint(list(map(lambda x: x*x,range(1,11)))) # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 我们也可以把匿名函数当作函数的返回值返回。\n装饰器 我们可能想在调用函数之前在前面打印一下函数的运行日志，或者其他的一些内容，其他的操作。\n这样我们就可以通过装饰器来实现，装饰器是为了给函数加一些其他的修饰，但是不需要在原本函数的基础上做改变。\n本质上，装饰器(decorator) 是一个返回函数的高阶函数，一个能打印日志的 decorator 可以如下定义：\ndef log(func): def wrapper(*args,**kw): print(\"call %s()\" % func.__name__) return func(*args,**kw) return wrapper 调用如下：\n@log def now(): print('2020-4-18') print(now()) # 输出 call now() 2020-4-18 在这里， @log 可以等效为 now = log(now) ，那么我们应该怎么理解呢，首先，在我们调用之前，我们就把这个函数传入这个log函数，然后进入 wrapper 函数，先输出了日志，然后返回了一个 func() 函数，然后结束这个函数的定义，又返回了 wrapper 函数，这样就是将日志和原函数组合在一起了。所以最后一起输出\n偏函数 偏函数可以看做一个函数其中某一个参数固定，然后另成一个新函数，这样到时候我们重复调用的时候就会比较方便了。\n当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。\n当用 functools.partial 之前我们需要引入 functools 模块。\nimport functools int2 = functools.partial(int,base=2) print(int('10110',base=2)) # 以二进制来转化这个字符串，得到22 print(int2('10110')) # 和上述等价 模块 这个就是类似于头文件的感觉，模块里面包含了很多别人已经写好了的函数，你引入之后可以直接拿来用，能够大大提高自己的编程效率。\n模块是放在包里的，这样可以避免不同模块之间的冲突，包中可以有很多的模块，并且所有包里都有一个相同名字的模块 ， __init__.py ，这个文件说明这个目录是一个包，里面的其他的内容是模块。\n模块命名为 包名.模块名 ，这样就有效避免了模块与模块之间的冲突\n模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。\n创建自己的模块时，要注意：\n模块名要遵循Python变量命名规范，不要使用中文、特殊字符； 模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块。 使用模块 在使用模块之前只需要 import 模块名 ，就可以通过 模块名.方法 的方式来调用这个模块里面的方法。\n当我们在命令行运行模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。\n封装 在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。\n正常的函数和变量名是公开的（public）。但是外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。\n安装第三方模块 我们用包管理工具 pip 来安装第三方模块。\n安装一个模块只需要 pip install 库名 ，这样就成功安装了一个包了。\n此外，我们也可以直接安装 Anaconda ，这是一个基于Python的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库，我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用。\n下载地址为 ： Anaconda官网\n模块搜索路径 当我们加载一个模块时，Python会在指定路径搜索对应的模块文件，如果找不到就会返回错误。\n默认情况下，Python解释器会搜索当前目录，所有已安装的内置模块和第三方模块，搜索路径存放在 sys 模块的 path 变量中。我们可以通过 sys.path 来查看。\n我们要改动这个目录，往里面添加我们需要的，有两个方法。\n直接通过 sys.path.append() 添加对应的路径，但是运行结束后会失效。 设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。 资料补充 廖雪峰的Python教程 Anaconda介绍、安装及使用教程 ","wordCount":"1135","inLanguage":"en","datePublished":"2020-04-18T01:24:00Z","dateModified":"2020-04-18T01:24:00Z","author":{"@type":"Person","name":"zzsqwq"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.zzsqwq.cn/posts/66/"},"publisher":{"@type":"Organization","name":"Zs's Blog","logo":{"@type":"ImageObject","url":"https://blog.zzsqwq.cn/images/avatar.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.zzsqwq.cn/ accesskey=h title="Zs's Blog (Alt + H)">Zs's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://blog.zzsqwq.cn/about title=About><span>About</span></a></li><li><a href=https://blog.zzsqwq.cn/archives title=Posts><span>Posts</span></a></li><li><a href=https://blog.zzsqwq.cn/friends title=Friends><span>Friends</span></a></li><li><a href=https://blog.zzsqwq.cn/contact title=Contact><span>Contact</span></a></li><li><a href=https://blog.zzsqwq.cn/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.zzsqwq.cn/>Home</a>&nbsp;»&nbsp;<a href=https://blog.zzsqwq.cn/posts/>Posts</a></div><h1 class=post-title>Python初步学习</h1><div class=post-meta><span title='2020-04-18 01:24:00 +0000 UTC'>April 18, 2020</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;zzsqwq&nbsp;|&nbsp;<a href=https://github.com/zzsqwq/zzsqwq.github.io/tree/master/content/posts/Python%e5%88%9d%e6%ad%a5%e5%ad%a6%e4%b9%a0.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#python%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0 aria-label=Python学习笔记>Python学习笔记</a><ul><li><a href=#python%e7%9a%84%e4%b8%8d%e5%90%8c%e8%a7%a3%e9%87%8a%e5%99%a8 aria-label=Python的不同解释器>Python的不同解释器</a></li><li><a href=#python%e5%9f%ba%e7%a1%80 aria-label=Python基础>Python基础</a><ul><li><a href=#%e7%ae%80%e5%8d%95%e7%9a%84%e8%be%93%e5%85%a5%e5%92%8c%e8%be%93%e5%87%baio aria-label=简单的输入和输出(I/O)>简单的输入和输出(I/O)</a><ul><li><a href=#%e8%be%93%e5%85%a5 aria-label=输入>输入</a></li><li><a href=#%e8%be%93%e5%87%ba aria-label=输出>输出</a></li></ul></li><li><a href=#%e4%b8%80%e4%ba%9b%e8%a7%84%e5%88%99 aria-label=一些规则>一些规则</a><ul><li><a href=#%e7%bc%a9%e8%bf%9b aria-label=缩进>缩进</a></li><li><a href=#%e6%b3%a8%e9%87%8a aria-label=注释>注释</a></li><li><a href=#case-sensitive aria-label="Case Sensitive">Case Sensitive</a></li></ul></li><li><a href=#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b aria-label=数据类型>数据类型</a><ul><li><a href=#1-%e6%95%b4%e6%95%b0 aria-label="1. 整数">1. 整数</a></li><li><a href=#2-%e6%b5%ae%e7%82%b9%e6%95%b0 aria-label="2. 浮点数">2. 浮点数</a></li><li><a href=#3-%e5%ad%97%e7%ac%a6%e4%b8%b2 aria-label="3. 字符串">3. 字符串</a></li><li><a href=#4-%e5%b8%83%e5%b0%94%e5%80%bc aria-label="4. 布尔值">4. 布尔值</a></li><li><a href=#5-%e7%a9%ba%e5%80%bc aria-label="5. 空值">5. 空值</a></li></ul></li><li><a href=#%e5%8f%98%e9%87%8f aria-label=变量>变量</a></li><li><a href=#%e5%b8%b8%e9%87%8f aria-label=常量>常量</a></li><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%92%8c%e7%bc%96%e7%a0%81 aria-label=字符串和编码>字符串和编码</a><ul><li><a href=#%e5%ad%97%e7%ac%a6%e7%bc%96%e7%a0%81 aria-label=字符编码>字符编码</a></li><li><a href=#python%e7%9a%84%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%ad%98%e5%82%a8 aria-label=Python的字符串存储>Python的字符串存储</a></li><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%9a%84%e6%a0%bc%e5%bc%8f%e5%8c%96%e8%be%93%e5%87%ba aria-label=字符串的格式化输出>字符串的格式化输出</a><ul><li><a href=#%e7%ac%ac%e4%b8%80%e7%a7%8d%e6%96%b9%e5%bc%8f aria-label=第一种方式>第一种方式</a></li><li><a href=#%e7%ac%ac%e4%ba%8c%e7%a7%8d%e6%96%b9%e5%bc%8f aria-label=第二种方式>第二种方式</a></li></ul></li></ul></li><li><a href=#list--tuple-%e5%88%97%e8%a1%a8%e5%92%8c%e5%85%83%e7%bb%84 aria-label="List &amp;amp; tuple (列表和元组)">List & tuple (列表和元组)</a><ul><li><a href=#list%e5%88%97%e8%a1%a8 aria-label=List(列表)>List(列表)</a></li><li><a href=#tuple%e5%85%83%e7%bb%84 aria-label=Tuple(元组)>Tuple(元组)</a></li></ul></li><li><a href=#%e6%9d%a1%e4%bb%b6%e5%88%a4%e6%96%ad aria-label=条件判断>条件判断</a></li><li><a href=#%e5%be%aa%e7%8e%af%e8%af%ad%e5%8f%a5 aria-label=循环语句>循环语句</a><ul><li><a href=#for aria-label=for>for</a></li><li><a href=#while aria-label=while>while</a></li><li><a href=#break--continue aria-label="break &amp;amp; continue">break & continue</a></li></ul></li><li><a href=#dict--set-%e5%ad%97%e5%85%b8%e5%92%8c%e9%9b%86%e5%90%88 aria-label="Dict &amp;amp; Set (字典和集合)">Dict & Set (字典和集合)</a><ul><li><a href=#dict aria-label=Dict>Dict</a></li><li><a href=#set aria-label=Set>Set</a></li></ul></li></ul></li><li><a href=#%e5%87%bd%e6%95%b0 aria-label=函数>函数</a><ul><li><a href=#%e8%b0%83%e7%94%a8%e5%87%bd%e6%95%b0 aria-label=调用函数>调用函数</a></li><li><a href=#%e5%ae%9a%e4%b9%89%e5%87%bd%e6%95%b0 aria-label=定义函数>定义函数</a><ul><li><a href=#%e5%87%bd%e6%95%b0%e7%9a%84%e5%ae%9a%e4%b9%89 aria-label=函数的定义>函数的定义</a></li><li><a href=#%e5%a4%9a%e4%b8%aa%e8%bf%94%e5%9b%9e%e5%80%bc%e7%9a%84%e5%87%bd%e6%95%b0 aria-label=多个返回值的函数>多个返回值的函数</a></li></ul></li><li><a href=#%e5%87%bd%e6%95%b0%e7%9a%84%e5%8f%82%e6%95%b0 aria-label=函数的参数>函数的参数</a><ul><li><a href=#%e9%bb%98%e8%ae%a4%e5%8f%82%e6%95%b0 aria-label=默认参数>默认参数</a></li><li><a href=#%e5%8f%af%e5%8f%98%e5%8f%82%e6%95%b0 aria-label=可变参数>可变参数</a></li><li><a href=#%e5%85%b3%e9%94%ae%e8%af%8d%e5%8f%82%e6%95%b0 aria-label=关键词参数>关键词参数</a></li><li><a href=#%e5%91%bd%e5%90%8d%e5%85%b3%e9%94%ae%e8%af%8d%e5%8f%82%e6%95%b0 aria-label=命名关键词参数>命名关键词参数</a></li><li><a href=#%e5%8f%82%e6%95%b0%e8%b0%83%e7%94%a8%e9%a1%ba%e5%ba%8f aria-label=参数调用顺序>参数调用顺序</a></li></ul></li><li><a href=#%e5%87%bd%e6%95%b0%e7%9a%84%e9%80%92%e5%bd%92%e8%b0%83%e7%94%a8 aria-label=函数的递归调用>函数的递归调用</a></li></ul></li><li><a href=#%e9%ab%98%e7%ba%a7%e7%89%b9%e6%80%a7 aria-label=高级特性>高级特性</a><ul><li><a href=#%e5%88%87%e7%89%87 aria-label=切片>切片</a></li><li><a href=#%e8%bf%ad%e4%bb%a3 aria-label=迭代>迭代</a></li><li><a href=#%e5%88%97%e8%a1%a8%e7%94%9f%e6%88%90%e5%99%a8 aria-label=列表生成器>列表生成器</a></li><li><a href=#%e7%94%9f%e6%88%90%e5%99%a8 aria-label=生成器>生成器</a></li><li><a href=#%e8%bf%ad%e4%bb%a3%e5%99%a8 aria-label=迭代器>迭代器</a></li></ul></li><li><a href=#%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b aria-label=函数式编程>函数式编程</a><ul><li><a href=#%e9%ab%98%e9%98%b6%e5%87%bd%e6%95%b0 aria-label=高阶函数>高阶函数</a><ul><li><a href=#mapreduce aria-label=map/reduce>map/reduce</a></li><li><a href=#filter aria-label=filter>filter</a></li><li><a href=#sorted aria-label=sorted>sorted</a></li></ul></li><li><a href=#%e8%bf%94%e5%9b%9e%e5%87%bd%e6%95%b0 aria-label=返回函数>返回函数</a></li><li><a href=#%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0 aria-label=匿名函数>匿名函数</a></li><li><a href=#%e8%a3%85%e9%a5%b0%e5%99%a8 aria-label=装饰器>装饰器</a></li><li><a href=#%e5%81%8f%e5%87%bd%e6%95%b0 aria-label=偏函数>偏函数</a></li></ul></li><li><a href=#%e6%a8%a1%e5%9d%97 aria-label=模块>模块</a><ul><li><a href=#%e4%bd%bf%e7%94%a8%e6%a8%a1%e5%9d%97 aria-label=使用模块>使用模块</a><ul><li><a href=#%e5%b0%81%e8%a3%85 aria-label=封装>封装</a></li></ul></li><li><a href=#%e5%ae%89%e8%a3%85%e7%ac%ac%e4%b8%89%e6%96%b9%e6%a8%a1%e5%9d%97 aria-label=安装第三方模块>安装第三方模块</a></li><li><a href=#%e6%a8%a1%e5%9d%97%e6%90%9c%e7%b4%a2%e8%b7%af%e5%be%84 aria-label=模块搜索路径>模块搜索路径</a></li></ul></li><li><a href=#%e8%b5%84%e6%96%99%e8%a1%a5%e5%85%85 aria-label=资料补充>资料补充</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=python学习笔记>Python学习笔记<a hidden class=anchor aria-hidden=true href=#python学习笔记>#</a></h1><h2 id=python的不同解释器>Python的不同解释器<a hidden class=anchor aria-hidden=true href=#python的不同解释器>#</a></h2><ol><li><p><strong>CPython</strong></p><p>这是自带的用C语言开发的解释器，因此叫CPython。它也是使用最广的Python解释器。</p></li><li><p><strong>IPython</strong></p><p>这是基于CPython之上的一个交互式解释器，只是相比于CPython多了交互上的优化。</p></li><li><p><strong>PyPy</strong></p><p>它的目标是执行速度。PyPy采用<a href=http://en.wikipedia.org/wiki/Just-in-time_compilation>JIT技术</a>，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。他与CPython略有不同。</p></li></ol><ol><li><p><strong>Jython</strong></p><p>这是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</p></li><li><p><strong>IronPython</strong></p><p>这是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。</p></li></ol><h2 id=python基础>Python基础<a hidden class=anchor aria-hidden=true href=#python基础>#</a></h2><h3 id=简单的输入和输出io>简单的输入和输出(I/O)<a hidden class=anchor aria-hidden=true href=#简单的输入和输出io>#</a></h3><h4 id=输入>输入<a hidden class=anchor aria-hidden=true href=#输入>#</a></h4><p>python提供了一个 <code>input()</code> 函数供我们输入使用，这读入的是字符串数据，并返回，可以将返回值存放在一个变量中。<strong>input</strong>函数中可以带字符串，这段字符串在输入前会打印在屏幕上，这使得我们具有很好的交互性，好比我们写:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>name</span> <span class=o>=</span> <span class=nb>input</span><span class=p>(</span><span class=s2>&#34;hello,friend! please input your name&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;The input name is &#34;</span><span class=p>,</span><span class=n>name</span><span class=p>)</span>
</span></span></code></pre></div><p>那么这时候我们运行上述程序，就会提示 <code>hello , friend! please input your name</code> ，这就提示我们应该输入名字。</p><p>这里需要注意的是，<code>input()</code> 函数读入的是一个字符串 <code>str</code> ，就算我们输入了整数他也是一个字符串，如果我们要用真正的整数，那么就需要用 <code>int()</code> 进行类型强制转换。如果其中不是合法的整数，那么会报错。</p><h4 id=输出>输出<a hidden class=anchor aria-hidden=true href=#输出>#</a></h4><p>python中的输出函数是 <code>print()</code> ，这和 <strong>C++</strong> 的<code>printf</code> 差了一个f。我们在函数的参数中传入什么，他就会打印什么。好比我们写 <code>print("heelo,world") </code>，那么运行就会打印 <code>hello,world</code> 在屏幕上。<code>print</code> 支持我们传入多个参数，好比 <code>printf("my name is","zs")</code> ，两两之间用逗号隔开，这在输出时会被解析成空格，也就是说两段字符串之间有一个空格。当然此函数也可以打印整数等。</p><h3 id=一些规则>一些规则<a hidden class=anchor aria-hidden=true href=#一些规则>#</a></h3><h4 id=缩进>缩进<a hidden class=anchor aria-hidden=true href=#缩进>#</a></h4><p>Python中对代码块的区分，不是用C++的大括号，而是用缩进。处于连续同一缩进的是一个代码块，这也是为什么Python又被戏称为<strong>游标卡尺语言</strong>的原因。<strong>当语句以冒号<code>:</code>结尾时，缩进的语句视为代码块。<strong>我们通常用</strong>一个Tab / 四个空格</strong> 的缩进。</p><h4 id=注释>注释<a hidden class=anchor aria-hidden=true href=#注释>#</a></h4><p>Python的注释用的是 <code>#</code> ，而 C++ 中的注释用的是 <code>\\</code> 。</p><h4 id=case-sensitive>Case Sensitive<a hidden class=anchor aria-hidden=true href=#case-sensitive>#</a></h4><p>Python中是大小写敏感的，也就是 a 和 A 不是同一个东西。</p><h3 id=数据类型>数据类型<a hidden class=anchor aria-hidden=true href=#数据类型>#</a></h3><h4 id=1-整数>1. 整数<a hidden class=anchor aria-hidden=true href=#1-整数>#</a></h4><p>Python一个很大的好处就是可以处理任意大小的整数，包括负整数。这也是为什么很多大数题大家都喜欢用Python，hhhh。多数地方都用十进制，但是也是支持其他进制的哈~好比 <code>0x</code> 前缀就是16进制。</p><h4 id=2-浮点数>2. 浮点数<a hidden class=anchor aria-hidden=true href=#2-浮点数>#</a></h4><p>浮点数是小数，之所以称为浮点数，是因为小数点位置在科学计数法中是可变的。这里需要注意，整数和浮点数在计算机内部存储方式不同，浮点数应该都是 <code>IEEE754</code> 标准吧？整数之间的运算永远都是精确的，包括除法。而浮点数的运算则会有一定的误差。Python的浮点数也没有大小限制，但是超出一定范围就直接表示为<code>inf</code>（无限大）。</p><h4 id=3-字符串>3. 字符串<a hidden class=anchor aria-hidden=true href=#3-字符串>#</a></h4><p>字符串是以单引号 <code>''</code> 或者双引号 <code>""</code> 括起来的任意文本。我们注意到<strong>Python</strong>中<strong>没有单个字符的概念</strong>，就算是单个字符也是一个字符串。如果<code>''</code> 括起来的字符串内部出现 <code>''</code> 需要使用<code>\</code>转义，相同的，如果 <code>""</code> 括起来的字符串内部出现 <code>""</code> 需要转义。好比下面的程序</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;My name is &#39;zs&#39;&#34;</span><span class=p>)</span>  <span class=c1>#合法  My name is &#39;zs&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;My name is &#34;</span><span class=n>zs</span><span class=s2>&#34;&#34;</span><span class=p>)</span>  <span class=c1>#不合法 invalid syntax</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;My name is </span><span class=se>\&#34;</span><span class=s2>zs</span><span class=se>\&#34;</span><span class=s2>&#34;</span><span class=p>)</span> <span class=c1>#合法 My name is &#34;zs&#34; </span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s1>&#39;My name is &#34;zs&#34;&#39;</span><span class=p>)</span>  <span class=c1>#合法  My name is &#34;zs&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s1>&#39;My name is &#39;</span><span class=n>zs</span><span class=s1>&#39;&#39;</span><span class=p>)</span>  <span class=c1>#不合法 invalid syntax</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s1>&#39;My name is </span><span class=se>\&#39;</span><span class=s1>zs</span><span class=se>\&#39;</span><span class=s1>&#39;</span><span class=p>)</span> <span class=c1>#合法 My name is &#39;zs&#39;</span>
</span></span></code></pre></div><p>Python中也有很多转义字符，跟C++的很类似。<code>\n</code>,<code>\t</code>,<code>\\</code> 分别代表换行，横向制表，字符<code>\</code> 。在python中还支持用 <code>r' '</code> 表示 <code>''</code> 内部的字符默认不转义。</p><p>Python在输出多行语句时，可以用 <code>print('''content''')</code> 其中content中的内容，支持用直觉上的换行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s1>&#39;&#39;&#39;python
</span></span></span><span class=line><span class=cl><span class=s1>name
</span></span></span><span class=line><span class=cl><span class=s1>zs&#39;&#39;&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># The output</span>
</span></span><span class=line><span class=cl><span class=n>python</span>
</span></span><span class=line><span class=cl><span class=n>name</span>
</span></span><span class=line><span class=cl><span class=n>zs</span>
</span></span></code></pre></div><h4 id=4-布尔值>4. 布尔值<a hidden class=anchor aria-hidden=true href=#4-布尔值>#</a></h4><p>含有 <strong>Ture</strong> 和 <strong>False</strong> 两种类型，代表真和假。支持 <code>and</code> , <code>or</code> ,<code>not</code> 三种运算。</p><h4 id=5-空值>5. 空值<a hidden class=anchor aria-hidden=true href=#5-空值>#</a></h4><p>空值是Python中的一个特殊值，用 <code>None</code> 表示。 <code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</p><h3 id=变量>变量<a hidden class=anchor aria-hidden=true href=#变量>#</a></h3><p>变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和<code>_</code>的组合，且不能用数字开头。</p><p>变量命名时最好能做到顾名思义，当然也有很多规范的命名规则，可以自行百度。</p><p>在 <strong>Python</strong> 中我们不需要指定一个变量是特定的类型，它可以在不同的类型之间变来变去，这确实很方便，不过感觉也是很占内存和时间的。</p><p>这种变量本身类型不固定的语言称之为<strong>动态语言</strong>，与之对应的是<strong>静态语言</strong>。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错</p><h3 id=常量>常量<a hidden class=anchor aria-hidden=true href=#常量>#</a></h3><p>Python中没有C++中的const来限制常量，但是通常用<strong>变量名全大写来代表这个变量为一个常量</strong>，但是这玩意是个约定俗成的，并不是说你这么写他就真是个常量了。</p><h3 id=字符串和编码>字符串和编码<a hidden class=anchor aria-hidden=true href=#字符串和编码>#</a></h3><h4 id=字符编码>字符编码<a hidden class=anchor aria-hidden=true href=#字符编码>#</a></h4><p>字符编码有很多种，不同的语言也对应着不同的字符编码。常见的几个是 <code>ASCII</code> ,<code>Unicode</code> ,<code>UTF-8</code>,<code>GB2313</code> 他们分别是英文和特殊字符的编码，统一的一套编码，可变长的统一编码，常用的中文编码。</p><h4 id=python的字符串存储>Python的字符串存储<a hidden class=anchor aria-hidden=true href=#python的字符串存储>#</a></h4><p>Python 3的的字符串是 <code>Unicode</code> 编码的，也就是说Python的字符串支持多语言，因为这是一套统一的编码。</p><p>对于单个字符的编码，Python提供了 <code>Ord()</code> 函数获取字符的整数表示，<code>chr()</code> 函数通过整数获取对应字符。</p><p>Python中的字符串类型为 <code>str</code> ，一个字符对应若干字节。**如果要在网络上传输，或者保存到磁盘上，就需要把<code>str</code>变为以字节为单位的<code>bytes</code>。**Python对<code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示。</p><p>我们可以通过<code>encode('编码方式')</code> 将 <strong>str</strong> 转变成 <strong>bytes</strong> 。我们也可以通过 <code>decode('编码方式')</code> 将 <strong>bytes</strong> 转变为 <strong>str</strong> 。</p><p>Python为我们提供了一个 <code>len()</code> 函数，如果字符串是 <strong>str</strong> ，那么计算出的是字符数，如果是 <strong>bytes</strong> ，那么计算的是字节数。我们为了防止乱码问题，在两者相互转换时推荐用 <strong>utf-8</strong> 编码。</p><p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ch>#!/usr/bin/env python3</span>
</span></span><span class=line><span class=cl><span class=c1># -*- coding: utf-8 -*-</span>
</span></span></code></pre></div><p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</p><p>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。而且需要你的编辑器支持 UTF-8编码。</p><h4 id=字符串的格式化输出>字符串的格式化输出<a hidden class=anchor aria-hidden=true href=#字符串的格式化输出>#</a></h4><h5 id=第一种方式>第一种方式<a hidden class=anchor aria-hidden=true href=#第一种方式>#</a></h5><p>Python的 <code>print()</code> 格式化输出和C语言的很像，也是 <code>%d</code> 代表整数，<code>%f</code> 代表浮点数， <code>%s</code> 代表字符串，<code>%s</code>代表十六进制整数。关于格式的指定，好比补0什么的也和C的很像。具体格式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s1>&#39;</span><span class=si>%2d</span><span class=s1>-</span><span class=si>%02d</span><span class=s1>&#39;</span> <span class=o>%</span> <span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=mi>1</span><span class=p>))</span> <span class=c1># 输出 3-01</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s1>&#39;my name is </span><span class=si>%s</span><span class=s1>&#39;</span> <span class=o>%</span> <span class=s2>&#34;zs&#34;</span><span class=p>)</span> <span class=c1># 输出 my name is zs</span>
</span></span></code></pre></div><p>如果我们要在字符串里面输出 <code>%</code> ，那么就需要用 <code>%%</code> 来转义表示 <code>%</code> 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;This is a common </span><span class=si>%%</span><span class=s2> </span><span class=si>%s</span><span class=s2> &#34;</span> <span class=o>%</span> <span class=s2>&#34;字符&#34;</span><span class=p>)</span> <span class=c1># 输出 This is a common % 字符</span>
</span></span></code></pre></div><h5 id=第二种方式>第二种方式<a hidden class=anchor aria-hidden=true href=#第二种方式>#</a></h5><p>除了上面的方法，<code>print</code> 还可以用 .format 的方法进行格式化输出。例如下例子</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s1>&#39;</span><span class=si>{0}</span><span class=s1> name is </span><span class=si>{1}</span><span class=s1>&#39;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=s2>&#34;who&#34;</span><span class=p>,</span><span class=s2>&#34;zs&#34;</span><span class=p>))</span> <span class=c1>#输出 who name is zs</span>
</span></span></code></pre></div><h3 id=list--tuple-列表和元组>List & tuple (列表和元组)<a hidden class=anchor aria-hidden=true href=#list--tuple-列表和元组>#</a></h3><h4 id=list列表>List(列表)<a hidden class=anchor aria-hidden=true href=#list列表>#</a></h4><p>List像是一个大杂烩，里面可以有各种类型的东西，是一个有序的集合，也就是说可以通过下标索引。</p><p>我们创建一个列表可以用中括号， <code>Mylist = ["zs","wx"]</code> ，这就创建了具有两个元素的列表，第一个元素是字符串 <strong>zs</strong> 第二个元素是字符串 <strong>wx</strong> 。这个列表的名字就是 <strong>Mylist</strong> 。</p><p>我们可以通过 <code>len()</code> 来获取列表中元素的个数，也可以通过下表索引列表的元素，但是要注意下标是从0开始计数的，如果索引出界会报 <code>IndexError</code> 。有趣的是，我们可以通过负的下表来访问元素，是倒着访问的，好比上述列表中 <code>Mylist[-1]</code> 就代表元素 <strong>&ldquo;wx&rdquo;</strong> 。</p><p>我们可以通过 <code>listk = []</code> ，来创建一个空列表 <strong>listk</strong> ，如果用 <code>len()</code> 查看长度那么长度为<strong>0</strong>.</p><p>此外列表中的元素也可以是列表，可以通过<strong>类似于二维数组的形式索引</strong>。</p><p>列表中，有许多的<strong>方法</strong>。就像是相对于这个类型内置的一些函数，用法如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>Mylist</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;zs&#34;</span><span class=p>,</span><span class=s2>&#34;wx&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>Mylist</span><span class=p>)</span> <span class=c1># 输出 [&#39;zs&#39;, &#39;wx&#39;]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Mylist</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=s1>&#39;Better&#39;</span><span class=p>)</span> <span class=c1># 用于在列表后面追加一个元素</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>Mylist</span><span class=p>)</span> <span class=c1># 输出 [&#39;zs&#39;, &#39;wx&#39;, &#39;Better&#39;]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Mylist</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=s1>&#39;Good&#39;</span><span class=p>)</span> <span class=c1># 用于在下标为1的位置，插入一个元素</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>Mylist</span><span class=p>)</span> <span class=c1># 输出 [&#39;zs&#39;, &#39;Good&#39;, &#39;wx&#39;, &#39;Better&#39;]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>popx</span> <span class=o>=</span> <span class=n>Mylist</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span> <span class=c1># 用于删除列表中最后一个元素，并返回元素的值</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>Mylist</span><span class=p>,</span><span class=n>popx</span><span class=p>)</span> <span class=c1># 输出 [&#39;zs&#39;, &#39;Good&#39;, &#39;wx&#39;] Better</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>popx</span> <span class=o>=</span> <span class=n>Mylist</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=c1># 用于删除列表中下标为1的元素，并返回元素的值</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>Mylist</span><span class=p>,</span><span class=n>popx</span><span class=p>)</span> <span class=c1># 输出 [&#39;zs&#39;, &#39;wx&#39;] Good</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>L</span> <span class=o>=</span> <span class=p>[]</span> <span class=c1># 创建了一个空列表 L</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>L</span><span class=p>))</span> <span class=c1>#输出0</span>
</span></span></code></pre></div><h4 id=tuple元组>Tuple(元组)<a hidden class=anchor aria-hidden=true href=#tuple元组>#</a></h4><p>元组跟上面的链表差不多，只不过是<strong>不可变的，一旦初始化就不能修改</strong>，也是可以通过下标访问元素。</p><p>不同的的是，我们定义一个元组是用 <code>()</code> ，好比我们定义 <code>Mytuple = ("zs","wx")</code> ，这是含有两个字符串元素的元组，我们可以通过 <code>Mytuple = ()</code> 来定义一个空的元组。</p><p>需要注意的是，当我们定义一个只有一个元素的元组，如果我们写成 <code>Mytuple = ("zs")</code> ，那么Python会默认解析为这是一个字符串，把括号当初普通的括号，不解释成元组。 那么我们如何定义只有一个元素的元组呢，我们应该写 <code>Mytuple = ("zs",)</code> 这样就是只有一个元素的元组。</p><p><strong>元组中的不可变，是指它的指向不变</strong>，那么如果好比元组的元素中有一个列表，那么其实这个元组中的列表的元素还是可以改变的。</p><h3 id=条件判断>条件判断<a hidden class=anchor aria-hidden=true href=#条件判断>#</a></h3><p>条件判断是一个经典的语句。用于分支结构。</p><p>用法跟C很像，不过 <strong>else if</strong> 可以缩写为 <strong>elif</strong> ，并且因为 <strong>if</strong> ，<strong>else</strong> , <strong>elif</strong> 后面接的都是语句块，因此要加 <code>:</code> 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>weight</span> <span class=o>=</span> <span class=mi>120</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>weight</span><span class=o>&gt;=</span><span class=mi>200</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;too fat&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>elif</span> <span class=n>weight</span><span class=o>&lt;=</span><span class=mi>100</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;too thin&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=p>:</span> 
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Good&#34;</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=循环语句>循环语句<a hidden class=anchor aria-hidden=true href=#循环语句>#</a></h3><p>循环结构也是三大结构之一。</p><h4 id=for>for<a hidden class=anchor aria-hidden=true href=#for>#</a></h4><p>for语句是我C++中最喜欢循环语句。在Python中，他的写法变成了 <code>for x in something:</code> ，下面接相应的循环语句块。这个 <strong>x</strong> 是变量的名字，<strong>something</strong> 是某一个容器，可以是列表可以是元组啥的，这个写法的意思就是 遍历 <strong>something</strong> 中的每个元素，带入变量 <strong>x</strong> 中，执行循环操作。</p><p>我们通常配合 <code>range()</code> 函数来执行循环操作，通过 <code>range(n)</code> 可以生成从 <strong>[0,n)</strong> 的整数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=nb>list</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=mi>11</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>  <span class=c1>#输出 0~10</span>
</span></span></code></pre></div><h4 id=while>while<a hidden class=anchor aria-hidden=true href=#while>#</a></h4><p>while语句也是和C语言差不多，当型循环，当满足条件时就执行循环，也记住不要忘记加 <code>:</code> 。</p><h4 id=break--continue>break & continue<a hidden class=anchor aria-hidden=true href=#break--continue>#</a></h4><p><strong>break</strong> 的作用是结束整个循环。</p><p><strong>continue</strong> 的作用是跳过这一次循环。</p><h3 id=dict--set-字典和集合>Dict & Set (字典和集合)<a hidden class=anchor aria-hidden=true href=#dict--set-字典和集合>#</a></h3><h4 id=dict>Dict<a hidden class=anchor aria-hidden=true href=#dict>#</a></h4><p>这个字典其实就是C语言中的 <strong>map</strong> ，人家 Python 直接内置了，属实业界良心。其实就是利用键值对匹配，一个键对应一个值。实现方式为哈希 <strong>(Hash)</strong> 。</p><p>创建就是 <code>Mydict = {"zs":250 , "wx":666</code>} 这样第一个元素的键为 &ldquo;zs&rdquo; ，对应值为 250 。第二个值与这个的解读类似。我们也可以通过类似于数组的形式往字典里面加元素. <code>Mydict["jjh"] = 100</code> ，那么这时候就往里面加入了一个键值对。</p><p>字典中每个键值是唯一的，但是值可以相同，类似于函数。我们也可以通过类似于数组的形式，下标为键来访问值。当我们下标在字典中不存在，利用下标访问就会直接报错。<strong>Python</strong> 为我们提供了另一种方法来满足我们的需求，利用 <code>Mydict.get(键)</code> 可以获得对应的值，当不存在这个键，会返回 <code>None</code> 。此外，我们也可以指定其返回值，<code>Mydict.get(键,something)</code> ，这样当不存在的时候就会返回这个 <strong>something</strong> 。</p><p>最后，<strong>字典中的 Key 只能是不可变对象。</strong></p><h4 id=set>Set<a hidden class=anchor aria-hidden=true href=#set>#</a></h4><p>set 就是数学中的集合，具有无序性和唯一性。里面元素不重复，并且无序导致没法通过下标访问。可以用来给一组数据去重。通过 <code>add(key) remove(key)</code> 等函数去除对应值的元素。</p><p>可以通过 <code>&</code> 求交集， <code>|</code> 求并集， <code>-</code> 求差集等。</p><p><strong>set 中的元素也只能是不可变对象。</strong></p><h2 id=函数>函数<a hidden class=anchor aria-hidden=true href=#函数>#</a></h2><h3 id=调用函数>调用函数<a hidden class=anchor aria-hidden=true href=#调用函数>#</a></h3><p>调用函数的时候要保证<strong>参数个数、参数顺序、参数类型</strong>满足函数的定义。然后正确的处理好返回值。</p><h3 id=定义函数>定义函数<a hidden class=anchor aria-hidden=true href=#定义函数>#</a></h3><h4 id=函数的定义>函数的定义<a hidden class=anchor aria-hidden=true href=#函数的定义>#</a></h4><p>普通函数的定义通过 <code>def</code> 来进行，好比我们要写一个求绝对值的函数，那么就可以如下定义</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>myabs</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>x</span><span class=o>&gt;=</span><span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=n>x</span>
</span></span></code></pre></div><p>这样我们就可以类似调用 <code>myabs(-5)</code> 来获得 -5 的绝对值。</p><p>如果我们想要定义一个<strong>空的函数</strong>，也就是什么都不做，那么函数内部的语句可以写 <code>pass</code> 。这类似于C++中的分号的作用？大概是。</p><p>通过 <code>函数.__name__</code> 可以获得函数的真实名字。</p><h4 id=多个返回值的函数>多个返回值的函数<a hidden class=anchor aria-hidden=true href=#多个返回值的函数>#</a></h4><p>我们可以在 <strong>return</strong> 后面写多个参数，这样在返回的时候会返回一个元组。我们接受返回值的时候，也可以并拍写多个变量，这样就会把返回值的元组中的各个值依次赋给每个变量。</p><h3 id=函数的参数>函数的参数<a hidden class=anchor aria-hidden=true href=#函数的参数>#</a></h3><p>Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数，可变参数，关键字参数，这使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p><h4 id=默认参数>默认参数<a hidden class=anchor aria-hidden=true href=#默认参数>#</a></h4><p>当我们调用一个函数，有几个参数大多数情况下是一个默认的值，少数时候是变的，那么我们可以用到默认参数，默认参数的使用我们可以在那个参数的后面加上 <code>=something</code> ，这意思说是，这个参数默认为 <strong>something</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>poww</span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=n>n</span><span class=o>=</span><span class=mi>2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>k</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>n</span><span class=o>&gt;</span><span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>n</span> <span class=o>=</span> <span class=n>n</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>k</span> <span class=o>=</span> <span class=n>k</span><span class=o>*</span><span class=n>x</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>k</span>
</span></span></code></pre></div><p>例如上面这个例子，我们要求 $2^5$ ，那么可以调用 <code>poww(2,5)</code> 。那么我们如果要求 $2^2$ ，那么就可以直接调用<code>poww(2)</code> ，另一个参数可以不写，那么就是默认的2。</p><p>需要注意的是，<strong>必选参数在前，默认参数要在后</strong>。否则话会产生歧义，因为解释器不知道你到底传入的参数是默认参数还是必选参数。</p><p>此外，当我们有多个默认参数的时候，我们要在前面几个默认参数使用默认值，而后面那个用传入参数的时候，我们需要加上参数名，也就是 <code>参数名 = value</code> 这样传入。例子如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>poww</span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=n>n</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span><span class=n>z</span><span class=o>=</span><span class=mi>3</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>k</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span> <span class=o>=</span> <span class=n>n</span><span class=o>+</span><span class=n>z</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>n</span><span class=o>&gt;</span><span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>f</span> <span class=o>=</span> <span class=n>f</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>k</span> <span class=o>=</span> <span class=n>k</span><span class=o>*</span><span class=n>x</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>k</span>
</span></span></code></pre></div><p>这时候，我们如果要调用 <code>poww(5,4)</code> ，代表求的是 $5^{4+3}$ ，如果我们要求 $5^{2+7}$ ，可以按照如下方法调用，使用 <code>poww(5,z=7)</code> 。</p><p>最后还有一点很重要，默认参数要指向 <strong>不变对象</strong> 。否则当我们重复调用会发生错误。</p><h4 id=可变参数>可变参数<a hidden class=anchor aria-hidden=true href=#可变参数>#</a></h4><p>我们很多时候可能需要一个函数内传入不定量个数的参数，这就要用到可变参数，可变参数就是数量可变。</p><p>我们很容易想到，可以往里面传<strong>列表或者元组</strong> ，不过这样当我们传之前还有要把所有的参数归到一个列表和元素中，这样太麻烦。Python给出了一个简便写法，我们只需要在参数面前加一个 <code>*</code> ，这样我们就可以传入可变个参数。而且调用的时候，按普通的调用方法来即可，不需要传入元组。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>test</span><span class=p>(</span><span class=o>*</span><span class=n>numbers</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>sum</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>numbers</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>sum</span> <span class=o>=</span> <span class=nb>sum</span> <span class=o>+</span> <span class=n>i</span><span class=o>*</span><span class=n>i</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>sum</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>test</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>))</span> <span class=c1># 输出 14</span>
</span></span></code></pre></div><p>那么当这时候我们想往里面传一个元组，或者列表。当然可以挨个用数组访问然后写，不过Python也给了我们一个简便做法，只需要在列表或者元组前面加一个 <code>*</code> ，就可以把它结构解开，然后挨个元素传入函数中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>test</span><span class=p>(</span><span class=o>*</span><span class=n>numbers</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>sum</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>numbers</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>sum</span> <span class=o>=</span> <span class=nb>sum</span> <span class=o>+</span> <span class=n>i</span><span class=o>*</span><span class=n>i</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>sum</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Mylist</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=mi>5</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>test</span><span class=p>(</span><span class=o>*</span><span class=n>Mylist</span><span class=p>))</span>  <span class=c1>#输出30</span>
</span></span></code></pre></div><h4 id=关键词参数>关键词参数<a hidden class=anchor aria-hidden=true href=#关键词参数>#</a></h4><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>myfun</span><span class=p>(</span><span class=o>**</span><span class=n>kw</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>kw</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>myfun</span><span class=p>(</span><span class=n>city</span> <span class=o>=</span> <span class=s2>&#34;jz&#34;</span><span class=p>,</span><span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;zs&#34;</span><span class=p>)</span> <span class=c1># 输出 {&#39;city&#39;: &#39;jz&#39;, &#39;name&#39;: &#39;zs&#39;}</span>
</span></span><span class=line><span class=cl><span class=n>Mydict</span> <span class=o>=</span> <span class=p>{</span><span class=s2>&#34;city&#34;</span><span class=p>:</span><span class=s2>&#34;jz&#34;</span><span class=p>,</span><span class=s2>&#34;name&#34;</span><span class=p>:</span><span class=s2>&#34;zs&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>myfun</span><span class=p>(</span><span class=o>**</span><span class=n>Mydict</span><span class=p>)</span>  <span class=c1># 输出 {&#39;city&#39;: &#39;jz&#39;, &#39;name&#39;: &#39;zs&#39;}</span>
</span></span></code></pre></div><p>参数前面加 <code>**</code> 即是关键词参数。当然我们也可以传入参数时，用dict，然后加 <code>**</code> 解开结构传入。</p><h4 id=命名关键词参数>命名关键词参数<a hidden class=anchor aria-hidden=true href=#命名关键词参数>#</a></h4><p>我们可以在上述的基础上，传入特定的参数，给相应的参数命名。这需要我们在定义各个参数之前，在参数之前加上 <code>*</code> ，好比 <code>def person(name,age,*,city,job)</code> 规定了，我们传入的两个关键词参数名字只能是 <strong>city</strong> 和和 <strong>job</strong> 。不过，当我们前面有一个参数是可变参数，那么就可以不用加那个 <code>*</code> 。好比像如下方法定义上面那个函数， <code>def person(name,age,*city,job)</code> 。在这里 <strong>city</strong> 是一个可变参数，后面的 <strong>job</strong> 就是一个命名关键词参数。</p><h4 id=参数调用顺序>参数调用顺序<a hidden class=anchor aria-hidden=true href=#参数调用顺序>#</a></h4><p>在函数的参数中，上述各类参数可以组合使用。但是要注意顺序必须是：<strong>必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</strong></p><h3 id=函数的递归调用>函数的递归调用<a hidden class=anchor aria-hidden=true href=#函数的递归调用>#</a></h3><p>函数的递归调用就是自己调用自己，QAQ，C++里面搞得也挺多的，就不赘述了。</p><h2 id=高级特性>高级特性<a hidden class=anchor aria-hidden=true href=#高级特性>#</a></h2><h3 id=切片>切片<a hidden class=anchor aria-hidden=true href=#切片>#</a></h3><p>切片操作感觉真的是Python很方便的一个特性了。</p><p><strong>字符串，列表，元组支持切片。</strong></p><p>好比我们有一个列表，里面有数，0~100，我们要取其中的奇数，那么我们就需要每隔一个数取一个数，我们可以通过for循环来实现这个操作，但是呢，Python有一种更便利的方法来实现，那就是切片。他的用法类似于matlab中的冒号表达式，<code>begin:end:step</code> 这三个变量分别代表起始，终止和步长，也就是每个多少取一个，这三个参数都可以省略，<strong>省略时默认为序列起始点，序列终止点，1。这里要注意</strong>，<strong>序列范围为 <code>[begin,end)</code> ，前闭后开</strong>，例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>L</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=mi>101</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>L</span><span class=p>[</span><span class=mi>1</span><span class=p>:</span><span class=mi>100</span><span class=p>:</span><span class=mi>2</span><span class=p>])</span> <span class=c1># 输出0~100所有的奇数</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>L</span><span class=p>[</span><span class=o>-</span><span class=mi>10</span><span class=p>::</span><span class=mi>2</span><span class=p>])</span>  <span class=c1># 从倒数第十个数开始输出奇数，输出 [91, 93, 95, 97, 99]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>L</span><span class=p>[</span><span class=o>-</span><span class=mi>50</span><span class=p>:</span><span class=mi>0</span><span class=p>:</span><span class=o>-</span><span class=mi>2</span><span class=p>])</span>  <span class=c1># 从倒数第50个数，往前开始输出奇数，为 51~0中所有奇数</span>
</span></span></code></pre></div><h3 id=迭代>迭代<a hidden class=anchor aria-hidden=true href=#迭代>#</a></h3><p>迭代就是类似于遍历吧，通过 <strong>for</strong> 可以迭代遍历一个容器内的所有元素。</p><p>字符串和列表，元组，集合，字典这些都是可以用<strong>for</strong>遍历的，这也叫做可迭代对象。需要注意的是，我们在遍历字典和集合时，因为是无序的，所以两次遍历顺序可能不太一样。</p><p>当我们遍历字典时，默认遍历的是键值。例如下面这样</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>L</span> <span class=o>=</span> <span class=p>{</span><span class=s2>&#34;zs&#34;</span><span class=p>:</span><span class=s2>&#34;rj&#34;</span><span class=p>,</span><span class=s2>&#34;jjh&#34;</span><span class=p>:</span><span class=s2>&#34;nb&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>key</span> <span class=ow>in</span> <span class=n>L</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>  <span class=c1># 输出 zs jjh</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>value</span> <span class=ow>in</span> <span class=n>L</span><span class=o>.</span><span class=n>values</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>value</span><span class=p>)</span> <span class=c1># 输出 rj nb</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>k</span><span class=p>,</span><span class=n>v</span> <span class=ow>in</span> <span class=n>L</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>k</span><span class=p>,</span><span class=n>v</span><span class=p>)</span> <span class=c1># 输出 zs rj jjh nb</span>
</span></span></code></pre></div><p>可以注意到，可以同时迭代两个数，或者多个数。</p><h3 id=列表生成器>列表生成器<a hidden class=anchor aria-hidden=true href=#列表生成器>#</a></h3><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p><p>好比我们生成 <code>[1*1,2*2,3*3,···,n*n]</code> 这样的列表，可以用循环实现，也可以用列表生成式。</p><p>列表生成式格式大概是 <code>[元素 规则]</code> 就是前面是要往里面加的元素的表达式，后面是生成的规则。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>L</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span><span class=o>*</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>11</span><span class=p>)]</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>L</span><span class=p>)</span>  <span class=c1># 输出[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>D</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span><span class=o>*</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>11</span><span class=p>)</span> <span class=k>if</span> <span class=n>x</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>D</span><span class=p>)</span>  <span class=c1># 输出[4, 16, 36, 64, 100]</span>
</span></span></code></pre></div><h3 id=生成器>生成器<a hidden class=anchor aria-hidden=true href=#生成器>#</a></h3><p>我们将上述列表生成式外面的 <code>[]</code> 改成 <code>()</code> ，就变成了一个列表生成器。列表生成器里面每个元素不是原来就存在的，而是你要用的时候他按照规则去生成，可以节省空间。他也是一个可迭代对象，可以通过for循环来访问，此外也可以用 <code>next(迭代器)</code> 来获取下一个元素。</p><p>除了上述方法，我们也可以用函数的方法来定义生成器，当一个函数中有了关键字 ： <code>yield</code> 他就不是一个普通的函数了，就变成了一个生成器，按照函数的规则来生成相应数据。规则如下：当我们进入函数的时候，开始从头开始执行，执行到 <strong>yield</strong> ，函数结束，返回 <strong>yield</strong> 后面接的内容。然后下次进入函数的时候，从上次结束的地方继续开始，然后这样一直循环，直到再不能取数为止。</p><h3 id=迭代器>迭代器<a hidden class=anchor aria-hidden=true href=#迭代器>#</a></h3><p>凡是可作用于<code>for</code>循环的对象都是<code>Iterable</code>类型，就是可迭代对象；</p><p>凡是可作用于<code>next()</code>函数的对象都是<code>Iterator</code>类型，它们表示一个惰性计算的序列，<strong>这感觉就像是一个指针呀其实（自我认为），可以通过指针访问可迭代对象中的元素</strong>；</p><p>集合数据类型如<code>list</code>、<code>dict</code>、<code>str</code>等是<code>Iterable</code>但不是<code>Iterator</code>，不过可以通过<code>iter()</code>函数获得一个<code>Iterator</code>对象。</p><p>Python的<code>for</code>循环本质上就是通过不断调用<code>next()</code>函数实现的，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span></code></pre></div><p>实际上完全等价于：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 首先获得Iterator对象:</span>
</span></span><span class=line><span class=cl><span class=n>it</span> <span class=o>=</span> <span class=nb>iter</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=c1># 循环:</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 获得下一个值:</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span> <span class=o>=</span> <span class=nb>next</span><span class=p>(</span><span class=n>it</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span> <span class=ne>StopIteration</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 遇到StopIteration就退出循环</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span>
</span></span></code></pre></div><h2 id=函数式编程>函数式编程<a hidden class=anchor aria-hidden=true href=#函数式编程>#</a></h2><h3 id=高阶函数>高阶函数<a hidden class=anchor aria-hidden=true href=#高阶函数>#</a></h3><h4 id=mapreduce>map/reduce<a hidden class=anchor aria-hidden=true href=#mapreduce>#</a></h4><p><code>map()</code> 函数包括两个参数，第一个参数是一个函数，第二个参数是一个序列。<strong>map</strong> 的作用就是将序列中的每个元素代入到函数中并且求出每个元素对应的值，然后会返回一个相应的 <code>Iterator </code>，我们可以通过对应的语句，好比 <code>list()</code> ，<code>tuple()</code> 啥的转成对应的序列。</p><p><code>reduce()</code> 函数也是包括两个参数，一个是函数，一个是序列。<strong>reduce</strong> 的作用是类似于一个递归的感觉吧大概，好比序列是 <code>L = [1,2,3,4,5]</code> ，有一个函数是 <code>f</code> ，我们暂且不管这个函数的作用是什么，那么如果我们现在调用 <code>reduce(f,L)</code> ，他返回一个 <code>f</code> 函数的返回值，值为 <code>f(f(f(1,2),3),4)</code> 。就是类似于这种嵌套的结构。</p><h4 id=filter>filter<a hidden class=anchor aria-hidden=true href=#filter>#</a></h4><p><code>filter()</code> 函数也包括两个参数，一个是函数，一个是序列。他是通过那个函数的返回值是 <code>True</code> or <code>False</code> 来判断是否保留那个序列中的每个元素。返回值也是 <code>Iterator</code> 。</p><h4 id=sorted>sorted<a hidden class=anchor aria-hidden=true href=#sorted>#</a></h4><p><code>sorted()</code> 顾名思义，这是一个排序函数，我们往里面传入一个序列，那么他就会默认的对序列按升序排序，并且返回一个这个排序后序列。<strong>但是我们传入的序列不会有变动。</strong></p><p>此外，<code>sorted()</code> 里面还可以加关键词 key 键值来确定规则，好比我们可以加 <code>key=abs</code> 这样就可以将序列中所有的元素按照绝对值从小到大的顺序。我们也可以加 <code>reverse=True</code> 来变成降序排序。</p><h3 id=返回函数>返回函数<a hidden class=anchor aria-hidden=true href=#返回函数>#</a></h3><p>我们知道，函数名只是一个指向函数的变量，我们也可以用另一个变量指向这个函数来引用函数，相当于起了一个别名。因此，我们也可以在函数的返回值中返回一个函数，然后将返回值赋值给一个变量，这样就可以通过这个变量来调用返回的函数。</p><blockquote><p>我们在一个函数中又定义了一个函数，并且，内部函数可以引用外部函数的参数和局部变量，当外部函数返回内部函数时，相关参数和变量都保存在返回的函数中，这种称为“闭包**（Closure）**”的程序结构拥有极大的威力。</p></blockquote><p>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。因为这个变量相当于一个静态变量，现在变了，前面相应的结果也会变。</p><blockquote><p>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p></blockquote><p>通过 <code>函数.__name__</code> 可以获得函数的真实名字。</p><h3 id=匿名函数>匿名函数<a hidden class=anchor aria-hidden=true href=#匿名函数>#</a></h3><p>通过 <code>lambda</code> 可以创建匿名函数，这个就类似于matlab里面的那个 <code>@</code> 创建的匿名函数。</p><p>格式为： <code>lambda 变量: 返回值</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>list</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=o>*</span><span class=n>x</span><span class=p>,</span><span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>11</span><span class=p>))))</span> <span class=c1># [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span>
</span></span></code></pre></div><p>我们也可以把匿名函数当作函数的返回值返回。</p><h3 id=装饰器>装饰器<a hidden class=anchor aria-hidden=true href=#装饰器>#</a></h3><p>我们可能想在调用函数之前在前面打印一下函数的运行日志，或者其他的一些内容，其他的操作。</p><p>这样我们就可以通过装饰器来实现，装饰器是为了给函数加一些其他的修饰，但是不需要在原本函数的基础上做改变。</p><p>本质上，<strong>装饰器(decorator)</strong> 是一个返回函数的高阶函数，一个能打印日志的 <strong>decorator</strong> 可以如下定义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>log</span><span class=p>(</span><span class=n>func</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>wrapper</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span><span class=o>**</span><span class=n>kw</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;call </span><span class=si>%s</span><span class=s2>()&#34;</span> <span class=o>%</span> <span class=n>func</span><span class=o>.</span><span class=vm>__name__</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span><span class=o>**</span><span class=n>kw</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>wrapper</span>
</span></span></code></pre></div><p>调用如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@log</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>now</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=nb>print</span><span class=p>(</span><span class=s1>&#39;2020-4-18&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>now</span><span class=p>())</span> <span class=c1># 输出 call now() 2020-4-18</span>
</span></span></code></pre></div><p>在这里， <code>@log</code> 可以等效为 <code>now = log(now)</code> ，那么我们应该怎么理解呢，首先，在我们调用之前，我们就把这个函数传入这个<code>log</code>函数，然后进入 <code>wrapper</code> 函数，先输出了日志，然后返回了一个 <code>func()</code> 函数，然后结束这个函数的定义，又返回了 <code>wrapper</code> 函数，这样就是将日志和原函数组合在一起了。所以最后一起输出</p><h3 id=偏函数>偏函数<a hidden class=anchor aria-hidden=true href=#偏函数>#</a></h3><p>偏函数可以看做一个函数其中某一个参数固定，然后另成一个新函数，这样到时候我们重复调用的时候就会比较方便了。</p><blockquote><p>当函数的参数个数太多，需要简化时，使用<code>functools.partial</code>可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</p></blockquote><p><strong>当用 <code>functools.partial</code> 之前我们需要引入 <code>functools</code> 模块。</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>functools</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>int2</span> <span class=o>=</span> <span class=n>functools</span><span class=o>.</span><span class=n>partial</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span><span class=n>base</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=s1>&#39;10110&#39;</span><span class=p>,</span><span class=n>base</span><span class=o>=</span><span class=mi>2</span><span class=p>))</span> <span class=c1># 以二进制来转化这个字符串，得到22</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>int2</span><span class=p>(</span><span class=s1>&#39;10110&#39;</span><span class=p>))</span> <span class=c1># 和上述等价</span>
</span></span></code></pre></div><h2 id=模块>模块<a hidden class=anchor aria-hidden=true href=#模块>#</a></h2><p>这个就是类似于头文件的感觉，模块里面包含了很多别人已经写好了的函数，你引入之后可以直接拿来用，能够大大提高自己的编程效率。</p><p>模块是放在包里的，这样可以避免不同模块之间的冲突，包中可以有很多的模块，并且所有包里都有一个相同名字的模块 ， <code>__init__.py</code> ，这个文件说明这个目录是一个包，里面的其他的内容是模块。</p><p>模块命名为 <code>包名.模块名</code> ，这样就有效避免了模块与模块之间的冲突</p><blockquote><p>模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。</p><p>创建自己的模块时，要注意：</p><ul><li>模块名要遵循Python变量命名规范，不要使用中文、特殊字符；</li><li>模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行<code>import abc</code>，若成功则说明系统存在此模块。</li></ul></blockquote><h3 id=使用模块>使用模块<a hidden class=anchor aria-hidden=true href=#使用模块>#</a></h3><p>在使用模块之前只需要 <code>import 模块名</code> ，就可以通过 <strong>模块名.方法</strong> 的方式来调用这个模块里面的方法。</p><p>当我们在命令行运行模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入模块时，<code>if</code>判断将失败，因此，这种<code>if</code>测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p><h4 id=封装>封装<a hidden class=anchor aria-hidden=true href=#封装>#</a></h4><p>在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过<code>_</code>前缀来实现的。</p><p>正常的函数和变量名是公开的（public）。但是外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</p><h3 id=安装第三方模块>安装第三方模块<a hidden class=anchor aria-hidden=true href=#安装第三方模块>#</a></h3><p>我们用包管理工具 <code>pip</code> 来安装第三方模块。</p><p>安装一个模块只需要 <code>pip install 库名</code> ，这样就成功安装了一个包了。</p><p>此外，我们也可以直接安装 <a href=https://www.anaconda.com/>Anaconda</a> ，这是一个基于Python的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库，我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用。</p><p>下载地址为 ： <a href=https://www.anaconda.com/download/>Anaconda官网</a></p><h3 id=模块搜索路径>模块搜索路径<a hidden class=anchor aria-hidden=true href=#模块搜索路径>#</a></h3><p>当我们加载一个模块时，Python会在指定路径搜索对应的模块文件，如果找不到就会返回错误。</p><p>默认情况下，Python解释器会搜索当前目录，所有已安装的内置模块和第三方模块，搜索路径存放在 <code>sys</code> 模块的 <code>path</code> 变量中。我们可以通过 <code>sys.path</code> 来查看。</p><p>我们要改动这个目录，往里面添加我们需要的，有两个方法。</p><ul><li>直接通过 <code>sys.path.append()</code> 添加对应的路径，但是运行结束后会失效。</li><li>设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</li></ul><h2 id=资料补充>资料补充<a hidden class=anchor aria-hidden=true href=#资料补充>#</a></h2><ul><li><a href=https://www.liaoxuefeng.com/wiki/1016959663602400>廖雪峰的Python教程</a></li><li><a href=https://www.jianshu.com/p/62f155eb6ac5>Anaconda介绍、安装及使用教程</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.zzsqwq.cn/tags/python/>Python</a></li></ul><nav class=paginav><a class=prev href=https://blog.zzsqwq.cn/posts/67/><span class=title>« Prev</span><br><span>高精度计算pi</span>
</a><a class=next href=https://blog.zzsqwq.cn/posts/64/><span class=title>Next »</span><br><span>C++大数类的实现</span></a></nav></footer><div class=comments><script>let getTheme=window.localStorage&&window.localStorage.getItem("pref-theme");getTheme=getTheme??"preferred_color_scheme";let s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","zzsqwq/hugo-blog-comment"),s.setAttribute("data-repo-id","R_kgDOGgU1qQ"),s.setAttribute("data-category","Announcements"),s.setAttribute("data-category-id","DIC_kwDOGgU1qc4CSX1m"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","top"),s.setAttribute("data-theme",getTheme),s.setAttribute("data-lang",""),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.zzsqwq.cn/>Zs's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a> | <a href=http://beian.miit.gov.cn/ target=_blank>鲁ICP备2020034310号</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>function sendMessage(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light"),sendMessage({setConfig:{theme:"light"}})):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"),sendMessage({setConfig:{theme:"dark"}}))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>