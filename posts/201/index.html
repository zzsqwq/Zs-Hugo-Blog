<!doctype html><html lang=cn>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta http-equiv=content-language content="cn">
<meta name=color-scheme content="light dark">
<meta name=author content="zzsqwq">
<meta name=description content="前言    前段时间在 Github 学完了关于 git 的小游戏 learnGitBranching ，受益匪浅。
它通过可视化的方式将分支的关系，每条命令的作用等都明明白白的体现出来，可以很直观的感受到你每条命令对整个分支树，每一个 ref 的作用。
通过这种学习感觉自己对 Git 的理解更加深入一步，能够理解其中的原理，而不是浅尝辄止，照猫画虎。
学习中记了一些零零散散的思路，想要写一篇笔记记录出来，之前已经写过一个简单的 Git 教程，这篇教程将会更加深入，希望可以帮助大家更好的掌握 Git。
窃认为，想要学好 Git ，必须要理解清楚其中的分区以及引用，学会了这两个，各种基本操作就很容易理解了。接下来的笔记也基本以此思路展开。
Git中的分区    首先，Git中存在三大分区，分别是工作区、暂存区、版本库。其中，
工作区即我们工作的目录，暂存区是我们执行 git add 后文件存在的区域。
我们可以通过 git status 对两种状态进行查看，例如：
~/test master* base ❯ git status On branch master Changes to be committed: (use &#34;git restore --staged <file>...&#34; to unstage) modified: test Changes not staged for commit: (use &#34;git add <file>...&#34; to update what will be committed) (use &#34;git restore <file>.">
<meta name=keywords content="blog,developer,personal">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="关于Git的一些理解">
<meta name=twitter:description content="前言    前段时间在 Github 学完了关于 git 的小游戏 learnGitBranching ，受益匪浅。
它通过可视化的方式将分支的关系，每条命令的作用等都明明白白的体现出来，可以很直观的感受到你每条命令对整个分支树，每一个 ref 的作用。
通过这种学习感觉自己对 Git 的理解更加深入一步，能够理解其中的原理，而不是浅尝辄止，照猫画虎。
学习中记了一些零零散散的思路，想要写一篇笔记记录出来，之前已经写过一个简单的 Git 教程，这篇教程将会更加深入，希望可以帮助大家更好的掌握 Git。
窃认为，想要学好 Git ，必须要理解清楚其中的分区以及引用，学会了这两个，各种基本操作就很容易理解了。接下来的笔记也基本以此思路展开。
Git中的分区    首先，Git中存在三大分区，分别是工作区、暂存区、版本库。其中，
工作区即我们工作的目录，暂存区是我们执行 git add 后文件存在的区域。
我们可以通过 git status 对两种状态进行查看，例如：
~/test master* base ❯ git status On branch master Changes to be committed: (use &#34;git restore --staged <file>...&#34; to unstage) modified: test Changes not staged for commit: (use &#34;git add <file>...&#34; to update what will be committed) (use &#34;git restore <file>.">
<meta property="og:title" content="关于Git的一些理解">
<meta property="og:description" content="前言    前段时间在 Github 学完了关于 git 的小游戏 learnGitBranching ，受益匪浅。
它通过可视化的方式将分支的关系，每条命令的作用等都明明白白的体现出来，可以很直观的感受到你每条命令对整个分支树，每一个 ref 的作用。
通过这种学习感觉自己对 Git 的理解更加深入一步，能够理解其中的原理，而不是浅尝辄止，照猫画虎。
学习中记了一些零零散散的思路，想要写一篇笔记记录出来，之前已经写过一个简单的 Git 教程，这篇教程将会更加深入，希望可以帮助大家更好的掌握 Git。
窃认为，想要学好 Git ，必须要理解清楚其中的分区以及引用，学会了这两个，各种基本操作就很容易理解了。接下来的笔记也基本以此思路展开。
Git中的分区    首先，Git中存在三大分区，分别是工作区、暂存区、版本库。其中，
工作区即我们工作的目录，暂存区是我们执行 git add 后文件存在的区域。
我们可以通过 git status 对两种状态进行查看，例如：
~/test master* base ❯ git status On branch master Changes to be committed: (use &#34;git restore --staged <file>...&#34; to unstage) modified: test Changes not staged for commit: (use &#34;git add <file>...&#34; to update what will be committed) (use &#34;git restore <file>.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zzsqwq.github.io/posts/201/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-07-23T14:17:00+00:00">
<meta property="article:modified_time" content="2021-07-23T14:17:00+00:00">
<title>
关于Git的一些理解 · Zs's Blog
</title>
<link rel=canonical href=https://zzsqwq.github.io/posts/201/>
<link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin>
<link rel=stylesheet href=/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css integrity="sha256-2f3b/+byfmmYXcX+BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin=anonymous media=screen>
<link rel=stylesheet href=/css/coder-dark.min.ccbbada2e264e4fdbf9b2181cccc2cdb289a63dc9520a1e96ac2b9a45778df29.css integrity="sha256-zLutouJk5P2/myGBzMws2yiaY9yVIKHpasK5pFd43yk=" crossorigin=anonymous media=screen>
<link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32>
<link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16>
<link rel=apple-touch-icon href=/images/apple-touch-icon.png>
<link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png>
<meta name=generator content="Hugo 0.89.4">
</head>
<body class="preload-transitions colorscheme-auto">
<div class=float-container>
<a id=dark-mode-toggle class=colorscheme-toggle>
<i class="fa fa-adjust fa-fw" aria-hidden=true></i>
</a>
</div>
<main class=wrapper>
<nav class=navigation>
<section class=container>
<a class=navigation-title href=/>
Zs's Blog
</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle>
<i class="fa fa-bars fa-fw" aria-hidden=true></i>
</label>
<ul class=navigation-list>
<li class=navigation-item>
<a class=navigation-link href=/about/>About</a>
</li>
<li class=navigation-item>
<a class=navigation-link href=/posts/>Blog</a>
</li>
<li class=navigation-item>
<a class=navigation-link href=/projects/>Projects</a>
</li>
<li class=navigation-item>
<a class=navigation-link href=/friends/>Friends</a>
</li>
<li class=navigation-item>
<a class=navigation-link href=/contact/>Contact Me</a>
</li>
</ul>
</section>
</nav>
<div class=content>
<section class="container post">
<article>
<header>
<div class=post-title>
<h1 class=title>
<a class=title-link href=https://zzsqwq.github.io/posts/201/>
关于Git的一些理解
</a>
</h1>
</div>
<div class=post-meta>
<div class=date>
<span class=posted-on>
<i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2021-07-23T14:17:00Z>
July 23, 2021
</time>
</span>
<span class=reading-time>
<i class="fa fa-clock-o" aria-hidden=true></i>
</span>
</div>
<div class=categories>
<i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/ubuntu/>Ubuntu</a>
<span class=separator>•</span>
<a href=/categories/git/>Git</a></div>
<div class=tags>
<i class="fa fa-tag" aria-hidden=true></i>
<span class=tag>
<a href=/tags/git/>Git</a>
</span></div>
</div>
</header>
<div>
<h1 id=前言>
前言
<a class=heading-link href=#%e5%89%8d%e8%a8%80>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h1>
<p>前段时间在 Github 学完了关于 git 的小游戏 <a href=https://github.com/pcottle/learnGitBranching>learnGitBranching</a> ，受益匪浅。</p>
<p>它通过可视化的方式将分支的关系，每条命令的作用等都明明白白的体现出来，可以很直观的感受到你每条命令对整个分支树，每一个 ref 的作用。</p>
<p>通过这种学习感觉自己对 Git 的理解更加深入一步，能够理解其中的原理，而不是浅尝辄止，照猫画虎。</p>
<p>学习中记了一些零零散散的思路，想要写一篇笔记记录出来，之前已经写过一个简单的 Git 教程，这篇教程将会更加深入，希望可以帮助大家更好的掌握 Git。</p>
<p>窃认为，想要学好 Git ，必须要理解清楚其中的分区以及引用，学会了这两个，各种基本操作就很容易理解了。接下来的笔记也基本以此思路展开。</p>
<h1 id=git中的分区>
Git中的分区
<a class=heading-link href=#git%e4%b8%ad%e7%9a%84%e5%88%86%e5%8c%ba>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h1>
<p><img src=https://www.zzsqwq.cn/usr/uploads/2021/07/612956951.jpg alt=Git中的三大分区，图片来源自掘金GabrielPanda></p>
<p>首先，Git中存在三大分区，分别是<strong>工作区、暂存区、版本库</strong>。其中，</p>
<p><strong>工作区</strong>即我们工作的目录，<strong>暂存区</strong>是我们执行 <code>git add</code> 后文件存在的区域。</p>
<p>我们可以通过 <code>git status</code> 对两种状态进行查看，例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>~/test master*
base ❯ git status  
On branch master
Changes to be committed:
  (use &#34;git restore --staged &lt;file&gt;...&#34; to unstage)
	modified:   test

Changes not staged for commit:
  (use &#34;git add &lt;file&gt;...&#34; to update what will be committed)
  (use &#34;git restore &lt;file&gt;...&#34; to discard changes in working directory)
	modified:   test
</code></pre></div><p>上图中存在两部分， 分别为 <code>Changes to be committed</code> 这里是表示的版本库与暂存区的区别，还有<code>Changes not staged for commit</code> ，它表示的是工作区与暂存区的区别。</p>
<p><strong>版本库</strong>是我们执行 <code>git commit -m "xxx"</code> 后，文件存在的区域。在上述过程中，Git 记录暂存区与版本库的差异，生成版本号，记录下来。我们可以通过 <code>git log</code> 来查看我们产生的更改，内容如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>commit 9da52a0e4800547ca46bd6bb919d1105cea43f1e (HEAD -&gt; master)
Author: zs &lt;2459958352@qq.com&gt;
Date:   Thu Jul 22 22:09:45 2021 +0800

    test commit
</code></pre></div><p>其中包含了版本号、当前节点上的 ref 记录、作者、邮箱、日期以及此次提交的注释。</p>
<h1 id=git中的引用>
Git中的引用
<a class=heading-link href=#git%e4%b8%ad%e7%9a%84%e5%bc%95%e7%94%a8>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h1>
<p>在 Git 中，引用到处可见，引用类似于给某一个 <code>commit-id</code> 即某一次提交的 <code>SHA-1</code> 值起一个简单的名字，如 <code>branch</code> ，<code>tag</code> 这些都是引用。</p>
<p>Git 中存在一个命令， <code>git update-ref</code> ，你可能几乎没见过，但可能天天在用。</p>
<p>当运行类似于 <code>git branch &lt;branch></code> 这样的命令时，Git 实际上会运行 <code>git update-ref</code> 命令，例如，运行 <code>git branch zs</code>，就等效于</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ git update-ref refs/heads/zs &lt;commit-id&gt;
</code></pre></div><p>这里的 <code>commit-id</code> 就是当前提交的 <code>commit-id</code> ，那他是如何获得的呢？</p>
<p>使用过 Git 的人一定知道，Git 中存在一个名叫 <code>HEAD</code> 的引用，它可能是引用，也可能是引用的引用。即它很多时候是指向某一个引用，如指向分支 <code>master</code> 这个引用。不过，它也可以与引用分离，称为<code>游离的HEAD</code>，即不指向某个引用，而指向单独的一个 <code>commit</code> 。</p>
<p>可以通过 <code>git commit commit-id</code> 来实现，不过，我们一般<strong>不推荐这种操作</strong>。下面的讨论，我们都是基于 <code>HEAD</code> 是指向某一分支的。</p>
<p>下面是关于一个引用的小例子：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>~/test master*
base ❯ git branch zs                                                    

~/test master*
base ❯ cat .git/refs/heads/zs 
9da52a0e4800547ca46bd6bb919d1105cea43f1e

~/test master*
base ❯ git update-ref refs/heads/test 9da52a

~/test master*
base ❯ cat .git/HEAD             
ref: refs/heads/master

~/test master*
base ❯ cat .git/refs/heads/master
9da52a0e4800547ca46bd6bb919d1105cea43f1e

~/test master*
base ❯ cat .git/refs/heads/test 
9da52a0e4800547ca46bd6bb919d1105cea43f1e
</code></pre></div><p>可以发现，例子中 HEAD 指向 master ，master,zs,test 同时都指向 id 为 <code>9da52a</code> 的提交。</p>
<h1 id=撤销更改>
撤销更改
<a class=heading-link href=#%e6%92%a4%e9%94%80%e6%9b%b4%e6%94%b9>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h1>
<h2 id=撤销本地更改>
撤销本地更改
<a class=heading-link href=#%e6%92%a4%e9%94%80%e6%9c%ac%e5%9c%b0%e6%9b%b4%e6%94%b9>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2>
<ul>
<li>通过<strong>版本库</strong>撤销<strong>暂存区</strong>更改，<strong>工作区</strong>不改</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ git reset HEAD^ <span style=font-style:italic>#撤销一次更改</span>
$ git reset HEAD~nums <span style=font-style:italic>#撤销HEAD往前nums次更改</span>
</code></pre></div><ul>
<li>直接通过<strong>版本库</strong>撤销<strong>工作区</strong>的更改</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ git reset HEAD^ --hard     <span style=font-style:italic>#撤销一次更改</span>
$ git reset HEAD~nums --hard <span style=font-style:italic>#撤销HEAD往前nums次更改</span>
</code></pre></div><p>可以发现只要加了 <code>--hard</code> ，就可以直接也把工作区改掉，不过建议三思而后行！</p>
<h2 id=撤销远程更改>
撤销远程更改
<a class=heading-link href=#%e6%92%a4%e9%94%80%e8%bf%9c%e7%a8%8b%e6%9b%b4%e6%94%b9>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2>
<p>上面说的是你本地的<strong>工作区</strong> or <strong>暂存区</strong>的撤销</p>
<p>如果你已经把更改推送到了远端仓库，那么你想要去掉那次改动怎么办？</p>
<p>可能你会想，直接通过 <code>git reset</code> 切换到上面的某个需要的节点，然后再改？But，很容易想到这样会产生严重的冲突。<strong>一旦commit已经被push到远程仓库，那么是坚决不允许去reset它的。</strong></p>
<p>还好，Git 给我们提供了一个更好的选择，你可以通过 <code>git revert</code> 产生一个类似于补丁的东西来消除掉更改，很容易理解，这样没有改变树的结构，相对于 <code>git reset</code> 他会往前走而不是回溯，这不会对之前的历史产生重要的影响。</p>
<p>需要注意的是， <code>git revert </code> 的用法：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ git revert HEAD <span style=font-style:italic>#撤销掉HEAD这次更改，回到HEAD的上次版本</span>
$ git revert &lt;commit_id&gt; <span style=font-style:italic>#撤销掉这次cmmit的修改</span>
</code></pre></div><h1 id=两种合并方式>
两种合并方式
<a class=heading-link href=#%e4%b8%a4%e7%a7%8d%e5%90%88%e5%b9%b6%e6%96%b9%e5%bc%8f>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h1>
<p>我们知道，Git 中存在两种合并分支的方式，分别为 <code>git merge</code> 和 <code>git rebase</code> 。</p>
<p>两种方式各有优劣，简单说，<code>rabase</code> 是把两条分支的提交记录整理到某一主分支上，它有着历史的完整记录。而 <code>merge</code> 虽然也是整理了提交，但是某一分支的中间提交更改的过程合并后并不会体现在主分支上，中间过程可以说是在主分支上不可见的。</p>
<p>很容易发现，<code>rebase</code> 产生的主分支提交记录会更加的详细，它记录了每一步小的改动。而 <code>merge</code> 产生的更简洁，有点类似于封装的意味，只是告诉你我这个提交完成了这个任务的开发，内部的实现细节却不会告诉你。</p>
<p>而 <code>rebase</code> 相比与 <code>merge</code> 也会更加繁琐一些，你也可以通过 <code>git rebase -i</code> 来通过可视化界面（可视化文本列表）的方式，来对记录做取舍与改动，不过还是没有 <code>merge</code> 方便，远程仓库的合并操作一般都是使用 <code>merge</code> 。</p>
<p>需要注意的是，两种方法的使用习惯很不一样：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ git merge &lt;branch&gt;
</code></pre></div><p>代表的是将 <code>&lt;branch></code> 分支合并到当前 <code>HEAD</code> 所在的分支。</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ git rebase &lt;branch1&gt; &lt;branch2&gt;
</code></pre></div><p>代表的是将 <code>branch2</code> 合并到 <code>&lt;branch1></code> 的位置。如果省略 <code>&lt;branch2></code> ，那么就是合并 <code>HEAD</code> 所在分支到 <code>&lt;branch1></code> 分支。</p>
<p>可以发现 <code>merge</code> 体现的是一种， <code>merge xx</code> 到当前位置。而 <code>rebase</code> 体现的是将自己合并到 <code>xx</code> 那里去。一个是别人过来，一个是自己过去。建议两个命令改成 <code>merge from</code> ，<code>rebase into</code>，哈哈。</p>
<p>顺便提一下， <code>merge</code> 会导致一个节点有多个父节点，通过上文我们知道可以通过 <code>~</code> 在一条线上移动，在这里，我们可以通过 <code>^</code> 来指定第几个父节点，如 <code>HEAD^3</code> 就是指 <code>HEAD</code> 所在节点的第三个父节点。</p>
<h1 id=整理提交记录>
整理提交记录
<a class=heading-link href=#%e6%95%b4%e7%90%86%e6%8f%90%e4%ba%a4%e8%ae%b0%e5%bd%95>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h1>
<p>我们有时会需要把另一个分支的部分更改放到主分支上来，即整理我们所有的提交记录，拿到我们所需要的来组成一个完整功能。</p>
<p>为了完成这件事，我们想到，这有点像合并分支，不过可能不需要某一个分支上的全部更改，只需要其中的一部分就可以了。</p>
<p>上面提到，通过 <code>git rebase -i</code> 可以进行交互式的 <code>rebase</code> ，可以对提交记录进行取舍，因此这样就可以满足我们的需求，只不过可能合并的时候需要想明白是从哪里变到哪里，有一些烧脑。</p>
<p>幸运的是，Git 还给我们提供了另一个更加简洁的方式——<code>git cherry-pick</code> ，语法如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ git cherry-pick &lt;commid-id&gt;
</code></pre></div><p>你可以通过这种方式，将树上的任意一个节点的提交添加到当前 <code>HEAD</code> 所在分支的下方，这真是功能强大的命令！你也可以通过空格间隔，来顺序摘取多个提交。</p>
<h1 id=两条万能指令>
两条万能指令
<a class=heading-link href=#%e4%b8%a4%e6%9d%a1%e4%b8%87%e8%83%bd%e6%8c%87%e4%bb%a4>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h1>
<p>除了上面我觉得值得说道的问题，我还想推荐两条我认为非常有用的指令，掌握了他们，你就可以在分支树上随心所欲的移动！</p>
<ul>
<li>移动分支</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ git branch -f &lt;branch&gt; &lt;commit-id&gt;
</code></pre></div><p>通过这条指令，你可以将 <code>&lt;branch></code> 的引用指向 <code>commit-id</code> ，如果你读懂了上面的内容，你会发现它只是通过 <code>update-ref</code> 更新了对应的引用。</p>
<ul>
<li>移动 HEAD</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ git checkout &lt;branch&gt;
$ git checkout &lt;commit-id&gt;
</code></pre></div><p>通过这条指令，你可以自由的移动 <code>HEAD</code> 引用，前者让他指向了 <code>&lt;branch></code> 分支，后者让他指向了SHA-1为 <code>&lt;commit-id></code> 的提交。</p>
<h1 id=推荐的资料>
推荐的资料
<a class=heading-link href=#%e6%8e%a8%e8%8d%90%e7%9a%84%e8%b5%84%e6%96%99>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h1>
<p>在学习的过程中，看了很多资料，一并推荐给大家！</p>
<ul>
<li>
<p><a href=https://github.com/pcottle/learnGitBranching>learnGitBranching</a>：有趣的闯关游戏，但也干货满满。</p>
</li>
<li>
<p><a href=http://events.jianshu.io/p/9b3d7b6fe738>Git三大分区概念</a>：讲解了关于分区的概念，还有直观清晰的图片！</p>
</li>
<li>
<p><a href=https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%BC%95%E7%94%A8>Git的引用</a>：来自 Git 官方的讲解，十分硬核。</p>
</li>
</ul>
</div>
<footer>
<div id=commento></div>
<script src=http://commento.zzsqwq.cn/js/commento.js></script>
</footer>
</article>
</section>
</div>
<footer class=footer>
<section class=container>
©
2019 -
2021
zzsqwq
·
<a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.
</section>
</footer>
</main>
<script src=/js/coder.min.03b17769f4f91ae35667e1f2a1ca8c16f50562576cf90ff32b3179926914daa5.js integrity="sha256-A7F3afT5GuNWZ+HyocqMFvUFYlds+Q/zKzF5kmkU2qU="></script>
</body>
</html>