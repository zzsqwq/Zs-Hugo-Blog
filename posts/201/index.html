<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>关于Git的一些理解 | Zs's Blog</title>
<meta name=keywords content="Git"><meta name=description content='前言 前段时间在 Github 学完了关于 git 的小游戏 learnGitBranching ，受益匪浅。
它通过可视化的方式将分支的关系，每条命令的作用等都明明白白的体现出来，可以很直观的感受到你每条命令对整个分支树，每一个 ref 的作用。
通过这种学习感觉自己对 Git 的理解更加深入一步，能够理解其中的原理，而不是浅尝辄止，照猫画虎。
学习中记了一些零零散散的思路，想要写一篇笔记记录出来，之前已经写过一个简单的 Git 教程，这篇教程将会更加深入，希望可以帮助大家更好的掌握 Git。
窃认为，想要学好 Git ，必须要理解清楚其中的分区以及引用，学会了这两个，各种基本操作就很容易理解了。接下来的笔记也基本以此思路展开。
Git中的分区 首先，Git中存在三大分区，分别是工作区、暂存区、版本库。其中，
工作区即我们工作的目录，暂存区是我们执行 git add 后文件存在的区域。
我们可以通过 git status 对两种状态进行查看，例如：
~/test master* base ❯ git status On branch master Changes to be committed: (use "git restore --staged <file>..." to unstage) modified: test Changes not staged for commit: (use "git add <file>..." to update what will be committed) (use "git restore <file>.'><meta name=author content="zzsqwq"><link rel=canonical href=https://blog.zzsqwq.cn/posts/201/><meta name=google-site-verification content="G-WF7TH97J9X"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.zzsqwq.cn/images/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://blog.zzsqwq.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.zzsqwq.cn/images/favicon-32x32.ico><link rel=apple-touch-icon href=https://blog.zzsqwq.cn/apple-touch-icon.png><link rel=mask-icon href=https://blog.zzsqwq.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.zzsqwq.cn/posts/201/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-WF7TH97J9X"></script><script>var doNotTrack=!1,dnt;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WF7TH97J9X")}</script><meta property="og:title" content="关于Git的一些理解"><meta property="og:description" content='前言 前段时间在 Github 学完了关于 git 的小游戏 learnGitBranching ，受益匪浅。
它通过可视化的方式将分支的关系，每条命令的作用等都明明白白的体现出来，可以很直观的感受到你每条命令对整个分支树，每一个 ref 的作用。
通过这种学习感觉自己对 Git 的理解更加深入一步，能够理解其中的原理，而不是浅尝辄止，照猫画虎。
学习中记了一些零零散散的思路，想要写一篇笔记记录出来，之前已经写过一个简单的 Git 教程，这篇教程将会更加深入，希望可以帮助大家更好的掌握 Git。
窃认为，想要学好 Git ，必须要理解清楚其中的分区以及引用，学会了这两个，各种基本操作就很容易理解了。接下来的笔记也基本以此思路展开。
Git中的分区 首先，Git中存在三大分区，分别是工作区、暂存区、版本库。其中，
工作区即我们工作的目录，暂存区是我们执行 git add 后文件存在的区域。
我们可以通过 git status 对两种状态进行查看，例如：
~/test master* base ❯ git status On branch master Changes to be committed: (use "git restore --staged <file>..." to unstage) modified: test Changes not staged for commit: (use "git add <file>..." to update what will be committed) (use "git restore <file>.'><meta property="og:type" content="article"><meta property="og:url" content="https://blog.zzsqwq.cn/posts/201/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-23T14:17:00+00:00"><meta property="article:modified_time" content="2021-07-23T14:17:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="关于Git的一些理解"><meta name=twitter:description content='前言 前段时间在 Github 学完了关于 git 的小游戏 learnGitBranching ，受益匪浅。
它通过可视化的方式将分支的关系，每条命令的作用等都明明白白的体现出来，可以很直观的感受到你每条命令对整个分支树，每一个 ref 的作用。
通过这种学习感觉自己对 Git 的理解更加深入一步，能够理解其中的原理，而不是浅尝辄止，照猫画虎。
学习中记了一些零零散散的思路，想要写一篇笔记记录出来，之前已经写过一个简单的 Git 教程，这篇教程将会更加深入，希望可以帮助大家更好的掌握 Git。
窃认为，想要学好 Git ，必须要理解清楚其中的分区以及引用，学会了这两个，各种基本操作就很容易理解了。接下来的笔记也基本以此思路展开。
Git中的分区 首先，Git中存在三大分区，分别是工作区、暂存区、版本库。其中，
工作区即我们工作的目录，暂存区是我们执行 git add 后文件存在的区域。
我们可以通过 git status 对两种状态进行查看，例如：
~/test master* base ❯ git status On branch master Changes to be committed: (use "git restore --staged <file>..." to unstage) modified: test Changes not staged for commit: (use "git add <file>..." to update what will be committed) (use "git restore <file>.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.zzsqwq.cn/posts/"},{"@type":"ListItem","position":2,"name":"关于Git的一些理解","item":"https://blog.zzsqwq.cn/posts/201/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"关于Git的一些理解","name":"关于Git的一些理解","description":"前言 前段时间在 Github 学完了关于 git 的小游戏 learnGitBranching ，受益匪浅。\n它通过可视化的方式将分支的关系，每条命令的作用等都明明白白的体现出来，可以很直观的感受到你每条命令对整个分支树，每一个 ref 的作用。\n通过这种学习感觉自己对 Git 的理解更加深入一步，能够理解其中的原理，而不是浅尝辄止，照猫画虎。\n学习中记了一些零零散散的思路，想要写一篇笔记记录出来，之前已经写过一个简单的 Git 教程，这篇教程将会更加深入，希望可以帮助大家更好的掌握 Git。\n窃认为，想要学好 Git ，必须要理解清楚其中的分区以及引用，学会了这两个，各种基本操作就很容易理解了。接下来的笔记也基本以此思路展开。\nGit中的分区 首先，Git中存在三大分区，分别是工作区、暂存区、版本库。其中，\n工作区即我们工作的目录，暂存区是我们执行 git add 后文件存在的区域。\n我们可以通过 git status 对两种状态进行查看，例如：\n~/test master* base ❯ git status On branch master Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: test Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git restore \u0026lt;file\u0026gt;.","keywords":["Git"],"articleBody":"前言 前段时间在 Github 学完了关于 git 的小游戏 learnGitBranching ，受益匪浅。\n它通过可视化的方式将分支的关系，每条命令的作用等都明明白白的体现出来，可以很直观的感受到你每条命令对整个分支树，每一个 ref 的作用。\n通过这种学习感觉自己对 Git 的理解更加深入一步，能够理解其中的原理，而不是浅尝辄止，照猫画虎。\n学习中记了一些零零散散的思路，想要写一篇笔记记录出来，之前已经写过一个简单的 Git 教程，这篇教程将会更加深入，希望可以帮助大家更好的掌握 Git。\n窃认为，想要学好 Git ，必须要理解清楚其中的分区以及引用，学会了这两个，各种基本操作就很容易理解了。接下来的笔记也基本以此思路展开。\nGit中的分区 首先，Git中存在三大分区，分别是工作区、暂存区、版本库。其中，\n工作区即我们工作的目录，暂存区是我们执行 git add 后文件存在的区域。\n我们可以通过 git status 对两种状态进行查看，例如：\n~/test master* base ❯ git status On branch master Changes to be committed: (use \"git restore --staged ...\" to unstage) modified: test Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git restore ...\" to discard changes in working directory) modified: test 上图中存在两部分， 分别为 Changes to be committed 这里是表示的版本库与暂存区的区别，还有Changes not staged for commit ，它表示的是工作区与暂存区的区别。\n版本库是我们执行 git commit -m \"xxx\" 后，文件存在的区域。在上述过程中，Git 记录暂存区与版本库的差异，生成版本号，记录下来。我们可以通过 git log 来查看我们产生的更改，内容如下：\ncommit 9da52a0e4800547ca46bd6bb919d1105cea43f1e (HEAD -\u003e master) Author: zs \u003c2459958352@qq.com\u003e Date: Thu Jul 22 22:09:45 2021 +0800 test commit 其中包含了版本号、当前节点上的 ref 记录、作者、邮箱、日期以及此次提交的注释。\nGit中的引用 在 Git 中，引用到处可见，引用类似于给某一个 commit-id 即某一次提交的 SHA-1 值起一个简单的名字，如 branch ，tag 这些都是引用。\nGit 中存在一个命令， git update-ref ，你可能几乎没见过，但可能天天在用。\n当运行类似于 git branch 这样的命令时，Git 实际上会运行 git update-ref 命令，例如，运行 git branch zs，就等效于\n$ git update-ref refs/heads/zs 这里的 commit-id 就是当前提交的 commit-id ，那他是如何获得的呢？\n使用过 Git 的人一定知道，Git 中存在一个名叫 HEAD 的引用，它可能是引用，也可能是引用的引用。即它很多时候是指向某一个引用，如指向分支 master 这个引用。不过，它也可以与引用分离，称为游离的HEAD，即不指向某个引用，而指向单独的一个 commit 。\n可以通过 git commit commit-id 来实现，不过，我们一般不推荐这种操作。下面的讨论，我们都是基于 HEAD 是指向某一分支的。\n下面是关于一个引用的小例子：\n~/test master* base ❯ git branch zs ~/test master* base ❯ cat .git/refs/heads/zs 9da52a0e4800547ca46bd6bb919d1105cea43f1e ~/test master* base ❯ git update-ref refs/heads/test 9da52a ~/test master* base ❯ cat .git/HEAD ref: refs/heads/master ~/test master* base ❯ cat .git/refs/heads/master 9da52a0e4800547ca46bd6bb919d1105cea43f1e ~/test master* base ❯ cat .git/refs/heads/test 9da52a0e4800547ca46bd6bb919d1105cea43f1e 可以发现，例子中 HEAD 指向 master ，master,zs,test 同时都指向 id 为 9da52a 的提交。\n撤销更改 撤销本地更改 通过版本库撤销暂存区更改，工作区不改 $ git reset HEAD^ #撤销一次更改 $ git reset HEAD~nums #撤销HEAD往前nums次更改 直接通过版本库撤销工作区的更改 $ git reset HEAD^ --hard #撤销一次更改 $ git reset HEAD~nums --hard #撤销HEAD往前nums次更改 可以发现只要加了 --hard ，就可以直接也把工作区改掉，不过建议三思而后行！\n撤销远程更改 上面说的是你本地的工作区 or 暂存区的撤销\n如果你已经把更改推送到了远端仓库，那么你想要去掉那次改动怎么办？\n可能你会想，直接通过 git reset 切换到上面的某个需要的节点，然后再改？But，很容易想到这样会产生严重的冲突。一旦commit已经被push到远程仓库，那么是坚决不允许去reset它的。\n还好，Git 给我们提供了一个更好的选择，你可以通过 git revert 产生一个类似于补丁的东西来消除掉更改，很容易理解，这样没有改变树的结构，相对于 git reset 他会往前走而不是回溯，这不会对之前的历史产生重要的影响。\n需要注意的是， git revert 的用法：\n$ git revert HEAD #撤销掉HEAD这次更改，回到HEAD的上次版本 $ git revert #撤销掉这次cmmit的修改 两种合并方式 我们知道，Git 中存在两种合并分支的方式，分别为 git merge 和 git rebase 。\n两种方式各有优劣，简单说，rabase 是把两条分支的提交记录整理到某一主分支上，它有着历史的完整记录。而 merge 虽然也是整理了提交，但是某一分支的中间提交更改的过程合并后并不会体现在主分支上，中间过程可以说是在主分支上不可见的。\n很容易发现，rebase 产生的主分支提交记录会更加的详细，它记录了每一步小的改动。而 merge 产生的更简洁，有点类似于封装的意味，只是告诉你我这个提交完成了这个任务的开发，内部的实现细节却不会告诉你。\n而 rebase 相比与 merge 也会更加繁琐一些，你也可以通过 git rebase -i 来通过可视化界面（可视化文本列表）的方式，来对记录做取舍与改动，不过还是没有 merge 方便，远程仓库的合并操作一般都是使用 merge 。\n需要注意的是，两种方法的使用习惯很不一样：\n$ git merge 代表的是将 分支合并到当前 HEAD 所在的分支。\n$ git rebase 代表的是将 branch2 合并到 的位置。如果省略 ，那么就是合并 HEAD 所在分支到 分支。\n可以发现 merge 体现的是一种， merge xx 到当前位置。而 rebase 体现的是将自己合并到 xx 那里去。一个是别人过来，一个是自己过去。建议两个命令改成 merge from ，rebase into，哈哈。\n顺便提一下， merge 会导致一个节点有多个父节点，通过上文我们知道可以通过 ~ 在一条线上移动，在这里，我们可以通过 ^ 来指定第几个父节点，如 HEAD^3 就是指 HEAD 所在节点的第三个父节点。\n整理提交记录 我们有时会需要把另一个分支的部分更改放到主分支上来，即整理我们所有的提交记录，拿到我们所需要的来组成一个完整功能。\n为了完成这件事，我们想到，这有点像合并分支，不过可能不需要某一个分支上的全部更改，只需要其中的一部分就可以了。\n上面提到，通过 git rebase -i 可以进行交互式的 rebase ，可以对提交记录进行取舍，因此这样就可以满足我们的需求，只不过可能合并的时候需要想明白是从哪里变到哪里，有一些烧脑。\n幸运的是，Git 还给我们提供了另一个更加简洁的方式——git cherry-pick ，语法如下：\n$ git cherry-pick 你可以通过这种方式，将树上的任意一个节点的提交添加到当前 HEAD 所在分支的下方，这真是功能强大的命令！你也可以通过空格间隔，来顺序摘取多个提交。\n两条万能指令 除了上面我觉得值得说道的问题，我还想推荐两条我认为非常有用的指令，掌握了他们，你就可以在分支树上随心所欲的移动！\n移动分支 $ git branch -f 通过这条指令，你可以将 的引用指向 commit-id ，如果你读懂了上面的内容，你会发现它只是通过 update-ref 更新了对应的引用。\n移动 HEAD $ git checkout $ git checkout 通过这条指令，你可以自由的移动 HEAD 引用，前者让他指向了 分支，后者让他指向了SHA-1为 的提交。\n推荐的资料 在学习的过程中，看了很多资料，一并推荐给大家！\nlearnGitBranching：有趣的闯关游戏，但也干货满满。\nGit三大分区概念：讲解了关于分区的概念，还有直观清晰的图片！\nGit的引用：来自 Git 官方的讲解，十分硬核。\n","wordCount":"434","inLanguage":"en","datePublished":"2021-07-23T14:17:00Z","dateModified":"2021-07-23T14:17:00Z","author":{"@type":"Person","name":"zzsqwq"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.zzsqwq.cn/posts/201/"},"publisher":{"@type":"Organization","name":"Zs's Blog","logo":{"@type":"ImageObject","url":"https://blog.zzsqwq.cn/images/avatar.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.zzsqwq.cn/ accesskey=h title="Zs's Blog (Alt + H)">Zs's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.zzsqwq.cn/about title=About><span>About</span></a></li><li><a href=https://blog.zzsqwq.cn/archives title=Posts><span>Posts</span></a></li><li><a href=https://blog.zzsqwq.cn/friends title=Friends><span>Friends</span></a></li><li><a href=https://blog.zzsqwq.cn/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.zzsqwq.cn/>Home</a>&nbsp;»&nbsp;<a href=https://blog.zzsqwq.cn/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">关于Git的一些理解</h1><div class=post-meta><span title='2021-07-23 14:17:00 +0000 UTC'>July 23, 2021</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;zzsqwq&nbsp;|&nbsp;<a href=https://github.com/zzsqwq/zzsqwq.github.io/tree/master/content/posts/%e5%85%b3%e4%ba%8eGit%e7%9a%84%e4%b8%80%e4%ba%9b%e7%90%86%e8%a7%a3.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#git%e4%b8%ad%e7%9a%84%e5%88%86%e5%8c%ba aria-label=Git中的分区>Git中的分区</a></li><li><a href=#git%e4%b8%ad%e7%9a%84%e5%bc%95%e7%94%a8 aria-label=Git中的引用>Git中的引用</a></li><li><a href=#%e6%92%a4%e9%94%80%e6%9b%b4%e6%94%b9 aria-label=撤销更改>撤销更改</a><ul><li><a href=#%e6%92%a4%e9%94%80%e6%9c%ac%e5%9c%b0%e6%9b%b4%e6%94%b9 aria-label=撤销本地更改>撤销本地更改</a></li><li><a href=#%e6%92%a4%e9%94%80%e8%bf%9c%e7%a8%8b%e6%9b%b4%e6%94%b9 aria-label=撤销远程更改>撤销远程更改</a></li></ul></li><li><a href=#%e4%b8%a4%e7%a7%8d%e5%90%88%e5%b9%b6%e6%96%b9%e5%bc%8f aria-label=两种合并方式>两种合并方式</a></li><li><a href=#%e6%95%b4%e7%90%86%e6%8f%90%e4%ba%a4%e8%ae%b0%e5%bd%95 aria-label=整理提交记录>整理提交记录</a></li><li><a href=#%e4%b8%a4%e6%9d%a1%e4%b8%87%e8%83%bd%e6%8c%87%e4%bb%a4 aria-label=两条万能指令>两条万能指令</a></li><li><a href=#%e6%8e%a8%e8%8d%90%e7%9a%84%e8%b5%84%e6%96%99 aria-label=推荐的资料>推荐的资料</a></li></ul></div></details></div><div class=post-content><h1 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h1><p>前段时间在 Github 学完了关于 git 的小游戏 <a href=https://github.com/pcottle/learnGitBranching>learnGitBranching</a> ，受益匪浅。</p><p>它通过可视化的方式将分支的关系，每条命令的作用等都明明白白的体现出来，可以很直观的感受到你每条命令对整个分支树，每一个 ref 的作用。</p><p>通过这种学习感觉自己对 Git 的理解更加深入一步，能够理解其中的原理，而不是浅尝辄止，照猫画虎。</p><p>学习中记了一些零零散散的思路，想要写一篇笔记记录出来，之前已经写过一个简单的 Git 教程，这篇教程将会更加深入，希望可以帮助大家更好的掌握 Git。</p><p>窃认为，想要学好 Git ，必须要理解清楚其中的分区以及引用，学会了这两个，各种基本操作就很容易理解了。接下来的笔记也基本以此思路展开。</p><h1 id=git中的分区>Git中的分区<a hidden class=anchor aria-hidden=true href=#git中的分区>#</a></h1><p><img loading=lazy src=https://blog.zzsqwq.cn/usr/uploads/2021/07/612956951.jpg alt=Git中的三大分区，图片来源自掘金GabrielPanda></p><p>首先，Git中存在三大分区，分别是<strong>工作区、暂存区、版本库</strong>。其中，</p><p><strong>工作区</strong>即我们工作的目录，<strong>暂存区</strong>是我们执行 <code>git add</code> 后文件存在的区域。</p><p>我们可以通过 <code>git status</code> 对两种状态进行查看，例如：</p><pre tabindex=0><code class=language-sheel data-lang=sheel>~/test master*
base ❯ git status  
On branch master
Changes to be committed:
  (use &#34;git restore --staged &lt;file&gt;...&#34; to unstage)
	modified:   test

Changes not staged for commit:
  (use &#34;git add &lt;file&gt;...&#34; to update what will be committed)
  (use &#34;git restore &lt;file&gt;...&#34; to discard changes in working directory)
	modified:   test
</code></pre><p>上图中存在两部分， 分别为 <code>Changes to be committed</code> 这里是表示的版本库与暂存区的区别，还有<code>Changes not staged for commit</code> ，它表示的是工作区与暂存区的区别。</p><p><strong>版本库</strong>是我们执行 <code>git commit -m "xxx"</code> 后，文件存在的区域。在上述过程中，Git 记录暂存区与版本库的差异，生成版本号，记录下来。我们可以通过 <code>git log</code> 来查看我们产生的更改，内容如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>commit 9da52a0e4800547ca46bd6bb919d1105cea43f1e <span class=o>(</span>HEAD -&gt; master<span class=o>)</span>
</span></span><span class=line><span class=cl>Author: zs &lt;2459958352@qq.com&gt;
</span></span><span class=line><span class=cl>Date:   Thu Jul <span class=m>22</span> 22:09:45 <span class=m>2021</span> +0800
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>test</span> commit
</span></span></code></pre></div><p>其中包含了版本号、当前节点上的 ref 记录、作者、邮箱、日期以及此次提交的注释。</p><h1 id=git中的引用>Git中的引用<a hidden class=anchor aria-hidden=true href=#git中的引用>#</a></h1><p>在 Git 中，引用到处可见，引用类似于给某一个 <code>commit-id</code> 即某一次提交的 <code>SHA-1</code> 值起一个简单的名字，如 <code>branch</code> ，<code>tag</code> 这些都是引用。</p><p>Git 中存在一个命令， <code>git update-ref</code> ，你可能几乎没见过，但可能天天在用。</p><p>当运行类似于 <code>git branch &lt;branch></code> 这样的命令时，Git 实际上会运行 <code>git update-ref</code> 命令，例如，运行 <code>git branch zs</code>，就等效于</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git update-ref refs/heads/zs &lt;commit-id&gt;
</span></span></code></pre></div><p>这里的 <code>commit-id</code> 就是当前提交的 <code>commit-id</code> ，那他是如何获得的呢？</p><p>使用过 Git 的人一定知道，Git 中存在一个名叫 <code>HEAD</code> 的引用，它可能是引用，也可能是引用的引用。即它很多时候是指向某一个引用，如指向分支 <code>master</code> 这个引用。不过，它也可以与引用分离，称为<code>游离的HEAD</code>，即不指向某个引用，而指向单独的一个 <code>commit</code> 。</p><p>可以通过 <code>git commit commit-id</code> 来实现，不过，我们一般<strong>不推荐这种操作</strong>。下面的讨论，我们都是基于 <code>HEAD</code> 是指向某一分支的。</p><p>下面是关于一个引用的小例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>~/test master*
</span></span><span class=line><span class=cl>base ❯ git branch zs                                                    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>~/test master*
</span></span><span class=line><span class=cl>base ❯ cat .git/refs/heads/zs 
</span></span><span class=line><span class=cl>9da52a0e4800547ca46bd6bb919d1105cea43f1e
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>~/test master*
</span></span><span class=line><span class=cl>base ❯ git update-ref refs/heads/test 9da52a
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>~/test master*
</span></span><span class=line><span class=cl>base ❯ cat .git/HEAD             
</span></span><span class=line><span class=cl>ref: refs/heads/master
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>~/test master*
</span></span><span class=line><span class=cl>base ❯ cat .git/refs/heads/master
</span></span><span class=line><span class=cl>9da52a0e4800547ca46bd6bb919d1105cea43f1e
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>~/test master*
</span></span><span class=line><span class=cl>base ❯ cat .git/refs/heads/test 
</span></span><span class=line><span class=cl>9da52a0e4800547ca46bd6bb919d1105cea43f1e
</span></span></code></pre></div><p>可以发现，例子中 HEAD 指向 master ，master,zs,test 同时都指向 id 为 <code>9da52a</code> 的提交。</p><h1 id=撤销更改>撤销更改<a hidden class=anchor aria-hidden=true href=#撤销更改>#</a></h1><h2 id=撤销本地更改>撤销本地更改<a hidden class=anchor aria-hidden=true href=#撤销本地更改>#</a></h2><ul><li>通过<strong>版本库</strong>撤销<strong>暂存区</strong>更改，<strong>工作区</strong>不改</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git reset HEAD^ <span class=c1>#撤销一次更改</span>
</span></span><span class=line><span class=cl>$ git reset HEAD~nums <span class=c1>#撤销HEAD往前nums次更改</span>
</span></span></code></pre></div><ul><li>直接通过<strong>版本库</strong>撤销<strong>工作区</strong>的更改</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git reset HEAD^ --hard     <span class=c1>#撤销一次更改</span>
</span></span><span class=line><span class=cl>$ git reset HEAD~nums --hard <span class=c1>#撤销HEAD往前nums次更改</span>
</span></span></code></pre></div><p>可以发现只要加了 <code>--hard</code> ，就可以直接也把工作区改掉，不过建议三思而后行！</p><h2 id=撤销远程更改>撤销远程更改<a hidden class=anchor aria-hidden=true href=#撤销远程更改>#</a></h2><p>上面说的是你本地的<strong>工作区</strong> or <strong>暂存区</strong>的撤销</p><p>如果你已经把更改推送到了远端仓库，那么你想要去掉那次改动怎么办？</p><p>可能你会想，直接通过 <code>git reset</code> 切换到上面的某个需要的节点，然后再改？But，很容易想到这样会产生严重的冲突。<strong>一旦commit已经被push到远程仓库，那么是坚决不允许去reset它的。</strong></p><p>还好，Git 给我们提供了一个更好的选择，你可以通过 <code>git revert</code> 产生一个类似于补丁的东西来消除掉更改，很容易理解，这样没有改变树的结构，相对于 <code>git reset</code> 他会往前走而不是回溯，这不会对之前的历史产生重要的影响。</p><p>需要注意的是， <code>git revert </code>的用法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git revert HEAD <span class=c1>#撤销掉HEAD这次更改，回到HEAD的上次版本</span>
</span></span><span class=line><span class=cl>$ git revert &lt;commit_id&gt; <span class=c1>#撤销掉这次cmmit的修改</span>
</span></span></code></pre></div><h1 id=两种合并方式>两种合并方式<a hidden class=anchor aria-hidden=true href=#两种合并方式>#</a></h1><p>我们知道，Git 中存在两种合并分支的方式，分别为 <code>git merge</code> 和 <code>git rebase</code> 。</p><p>两种方式各有优劣，简单说，<code>rabase</code> 是把两条分支的提交记录整理到某一主分支上，它有着历史的完整记录。而 <code>merge</code> 虽然也是整理了提交，但是某一分支的中间提交更改的过程合并后并不会体现在主分支上，中间过程可以说是在主分支上不可见的。</p><p>很容易发现，<code>rebase</code> 产生的主分支提交记录会更加的详细，它记录了每一步小的改动。而 <code>merge</code> 产生的更简洁，有点类似于封装的意味，只是告诉你我这个提交完成了这个任务的开发，内部的实现细节却不会告诉你。</p><p>而 <code>rebase</code> 相比与 <code>merge</code> 也会更加繁琐一些，你也可以通过 <code>git rebase -i</code> 来通过可视化界面（可视化文本列表）的方式，来对记录做取舍与改动，不过还是没有 <code>merge</code> 方便，远程仓库的合并操作一般都是使用 <code>merge</code> 。</p><p>需要注意的是，两种方法的使用习惯很不一样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git merge &lt;branch&gt;
</span></span></code></pre></div><p>代表的是将 <code>&lt;branch></code> 分支合并到当前 <code>HEAD</code> 所在的分支。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git rebase &lt;branch1&gt; &lt;branch2&gt;
</span></span></code></pre></div><p>代表的是将 <code>branch2</code> 合并到 <code>&lt;branch1></code> 的位置。如果省略 <code>&lt;branch2></code> ，那么就是合并 <code>HEAD</code> 所在分支到 <code>&lt;branch1></code> 分支。</p><p>可以发现 <code>merge</code> 体现的是一种， <code>merge xx</code> 到当前位置。而 <code>rebase</code> 体现的是将自己合并到 <code>xx</code> 那里去。一个是别人过来，一个是自己过去。建议两个命令改成 <code>merge from</code> ，<code>rebase into</code>，哈哈。</p><p>顺便提一下， <code>merge</code> 会导致一个节点有多个父节点，通过上文我们知道可以通过 <code>~</code> 在一条线上移动，在这里，我们可以通过 <code>^</code> 来指定第几个父节点，如 <code>HEAD^3</code> 就是指 <code>HEAD</code> 所在节点的第三个父节点。</p><h1 id=整理提交记录>整理提交记录<a hidden class=anchor aria-hidden=true href=#整理提交记录>#</a></h1><p>我们有时会需要把另一个分支的部分更改放到主分支上来，即整理我们所有的提交记录，拿到我们所需要的来组成一个完整功能。</p><p>为了完成这件事，我们想到，这有点像合并分支，不过可能不需要某一个分支上的全部更改，只需要其中的一部分就可以了。</p><p>上面提到，通过 <code>git rebase -i</code> 可以进行交互式的 <code>rebase</code> ，可以对提交记录进行取舍，因此这样就可以满足我们的需求，只不过可能合并的时候需要想明白是从哪里变到哪里，有一些烧脑。</p><p>幸运的是，Git 还给我们提供了另一个更加简洁的方式——<code>git cherry-pick</code> ，语法如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git cherry-pick &lt;commid-id&gt;
</span></span></code></pre></div><p>你可以通过这种方式，将树上的任意一个节点的提交添加到当前 <code>HEAD</code> 所在分支的下方，这真是功能强大的命令！你也可以通过空格间隔，来顺序摘取多个提交。</p><h1 id=两条万能指令>两条万能指令<a hidden class=anchor aria-hidden=true href=#两条万能指令>#</a></h1><p>除了上面我觉得值得说道的问题，我还想推荐两条我认为非常有用的指令，掌握了他们，你就可以在分支树上随心所欲的移动！</p><ul><li>移动分支</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git branch -f &lt;branch&gt; &lt;commit-id&gt;
</span></span></code></pre></div><p>通过这条指令，你可以将 <code>&lt;branch></code> 的引用指向 <code>commit-id</code> ，如果你读懂了上面的内容，你会发现它只是通过 <code>update-ref</code> 更新了对应的引用。</p><ul><li>移动 HEAD</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git checkout &lt;branch&gt;
</span></span><span class=line><span class=cl>$ git checkout &lt;commit-id&gt;
</span></span></code></pre></div><p>通过这条指令，你可以自由的移动 <code>HEAD</code> 引用，前者让他指向了 <code>&lt;branch></code> 分支，后者让他指向了SHA-1为 <code>&lt;commit-id></code> 的提交。</p><h1 id=推荐的资料>推荐的资料<a hidden class=anchor aria-hidden=true href=#推荐的资料>#</a></h1><p>在学习的过程中，看了很多资料，一并推荐给大家！</p><ul><li><p><a href=https://github.com/pcottle/learnGitBranching>learnGitBranching</a>：有趣的闯关游戏，但也干货满满。</p></li><li><p><a href=http://events.jianshu.io/p/9b3d7b6fe738>Git三大分区概念</a>：讲解了关于分区的概念，还有直观清晰的图片！</p></li><li><p><a href=https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%BC%95%E7%94%A8>Git的引用</a>：来自 Git 官方的讲解，十分硬核。</p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.zzsqwq.cn/tags/git/>Git</a></li></ul><nav class=paginav><a class=prev href=https://blog.zzsqwq.cn/posts/215/><span class=title>« Prev</span><br><span>2021版小新Pro14 Ubuntu 20.04 配置指南</span>
</a><a class=next href=https://blog.zzsqwq.cn/posts/198/><span class=title>Next »</span><br><span>利用树莓派为HP LaserJet 1020配置无线打印功能</span></a></nav></footer><div class=comments><script>let getTheme=window.localStorage&&window.localStorage.getItem("pref-theme");getTheme=getTheme??"preferred_color_scheme";let s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","zzsqwq/hugo-blog-comment"),s.setAttribute("data-repo-id","R_kgDOGgU1qQ"),s.setAttribute("data-category","Announcements"),s.setAttribute("data-category-id","DIC_kwDOGgU1qc4CSX1m"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","top"),s.setAttribute("data-theme",getTheme),s.setAttribute("data-lang",""),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.zzsqwq.cn/>Zs's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a> | <a href=http://beian.miit.gov.cn/ target=_blank>鲁ICP备2020034310号</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>function sendMessage(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light"),sendMessage({setConfig:{theme:"light"}})):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"),sendMessage({setConfig:{theme:"dark"}}))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>