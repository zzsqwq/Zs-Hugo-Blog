<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta http-equiv=content-language content="en">
<meta name=color-scheme content="light dark">
<meta name=author content="zzsqwq">
<meta name=description content="
  高精度计算PI值
  
    
  


  题目描述
  
    
  

​    使用双向链表作为存储结构，请根据用户输入的一个整数（该整数表示精确到小数点后的位数，可能要求精确到小数点后 500 位），高精度计算PI值。提示：可以利用反三角函数幂级展开式来进行计算。">
<meta name=keywords content="blog,developer,personal">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="高精度计算pi">
<meta name=twitter:description content="
  高精度计算PI值
  
    
  


  题目描述
  
    
  

​    使用双向链表作为存储结构，请根据用户输入的一个整数（该整数表示精确到小数点后的位数，可能要求精确到小数点后 500 位），高精度计算PI值。提示：可以利用反三角函数幂级展开式来进行计算。">
<meta property="og:title" content="高精度计算pi">
<meta property="og:description" content="
  高精度计算PI值
  
    
  


  题目描述
  
    
  

​    使用双向链表作为存储结构，请根据用户输入的一个整数（该整数表示精确到小数点后的位数，可能要求精确到小数点后 500 位），高精度计算PI值。提示：可以利用反三角函数幂级展开式来进行计算。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.zzsqwq.cn/posts/67/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-04-20T01:25:00+00:00">
<meta property="article:modified_time" content="2020-04-20T01:25:00+00:00">
<title>
高精度计算pi · Zs's Blog
</title>
<link rel=canonical href=https://www.zzsqwq.cn/posts/67/>
<link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin>
<link rel=stylesheet href=/css/coder.min.51826c3279995d763cb22e72350b665aa46733ab8df12b1cae00617abd81a149.css integrity="sha256-UYJsMnmZXXY8si5yNQtmWqRnM6uN8SscrgBher2BoUk=" crossorigin=anonymous media=screen>
<link rel=stylesheet href=/css/coder-dark.min.ccbbada2e264e4fdbf9b2181cccc2cdb289a63dc9520a1e96ac2b9a45778df29.css integrity="sha256-zLutouJk5P2/myGBzMws2yiaY9yVIKHpasK5pFd43yk=" crossorigin=anonymous media=screen>
<link rel=stylesheet href=/scss/css/adjust_width.min.5ee0ad9e8f1b17d7a2309a71c69cb872e2afd31d618222760117de63b651a440.css integrity="sha256-XuCtno8bF9eiMJpxxpy4cuKv0x1hgiJ2ARfeY7ZRpEA=" crossorigin=anonymous media=screen>
<link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32>
<link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16>
<link rel=apple-touch-icon href=/images/apple-touch-icon.png>
<link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png>
<meta name=generator content="Hugo 0.90.0">
</head>
<body class="preload-transitions colorscheme-auto">
<div class=float-container>
<a id=dark-mode-toggle class=colorscheme-toggle>
<i class="fa fa-adjust fa-fw" aria-hidden=true></i>
</a>
</div>
<main class=wrapper>
<nav class=navigation>
<section class=container>
<a class=navigation-title href=/>
Zs's Blog
</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle>
<i class="fa fa-bars fa-fw" aria-hidden=true></i>
</label>
<ul class=navigation-list>
<li class=navigation-item>
<a class=navigation-link href=/about/>About</a>
</li>
<li class=navigation-item>
<a class=navigation-link href=/posts/>Blog</a>
</li>
<li class=navigation-item>
<a class=navigation-link href=/projects/>Projects</a>
</li>
<li class=navigation-item>
<a class=navigation-link href=/friends/>Friends</a>
</li>
<li class=navigation-item>
<a class=navigation-link href=/contact/>Contact Me</a>
</li>
</ul>
</section>
</nav>
<div class=content>
<section class="container post">
<article>
<header>
<div class=post-title>
<h1 class=title>
<a class=title-link href=https://www.zzsqwq.cn/posts/67/>
高精度计算pi
</a>
</h1>
</div>
<div class=post-meta>
<div class=date>
<span class=posted-on>
<i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2020-04-20T01:25:00Z>
April 20, 2020
</time>
</span>
<span class=reading-time>
<i class="fa fa-clock-o" aria-hidden=true></i>
3-minute read
</span>
</div>
<div class=categories>
<i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a></div>
<div class=tags>
<i class="fa fa-tag" aria-hidden=true></i>
<span class=tag>
<a href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a>
</span></div>
</div>
</header>
<div>
<h2 id=高精度计算pi值>
高精度计算PI值
<a class=heading-link href=#%e9%ab%98%e7%b2%be%e5%ba%a6%e8%ae%a1%e7%ae%97pi%e5%80%bc>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2>
<h3 id=题目描述>
题目描述
<a class=heading-link href=#%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3>
<p>​ 使用双向链表作为存储结构，请根据用户输入的一个整数（该整数表示精确到小数点后的位数，可能要求精确到小数点后 <strong>500</strong> 位），高精度计算PI值。<strong>提示：可以利用反三角函数幂级展开式来进行计算。</strong></p>
<h3 id=解题思路>
解题思路
<a class=heading-link href=#%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3>
<h4 id=求pi的算法>
求PI的算法
<a class=heading-link href=#%e6%b1%82pi%e7%9a%84%e7%ae%97%e6%b3%95>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4>
<p>​ 首先这道题是要求必须使用双向链表作为存储结构的，这个需要注意，而且也不能用数组计算完了之后挨个赋值给链表的每个节点，<del>这是耍赖</del> 。</p>
<p>​ 那么我们开始再想，用什么公式来求 <strong>PI</strong> 呢？这是一个问题。先没管题目的提示，我去百度了一通，发现了一个很神奇的算法，用三行就可以计算到圆周率小数点后800+位。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>long</span> a<span style=color:#f92672>=</span><span style=color:#ae81ff>1000</span>,b,c<span style=color:#f92672>=</span><span style=color:#ae81ff>2800</span>,d,e,f[<span style=color:#ae81ff>2801</span>],g;
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
    <span style=color:#66d9ef>for</span>(;b<span style=color:#f92672>-</span>c;) f[b<span style=color:#f92672>++</span>]<span style=color:#f92672>=</span>a<span style=color:#f92672>/</span><span style=color:#ae81ff>5</span>;
    <span style=color:#66d9ef>for</span>(;d<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>,g<span style=color:#f92672>=</span>c<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>;c<span style=color:#f92672>-=</span><span style=color:#ae81ff>14</span>,printf(<span style=color:#e6db74>&#34;%.3d&#34;</span>,e<span style=color:#f92672>+</span>d<span style=color:#f92672>/</span>a),e<span style=color:#f92672>=</span>d<span style=color:#f92672>%</span>a)
    <span style=color:#66d9ef>for</span>(b<span style=color:#f92672>=</span>c;d<span style=color:#f92672>+=</span>f[b]<span style=color:#f92672>*</span>a,f[b]<span style=color:#f92672>=</span>d<span style=color:#f92672>%--</span>g,d<span style=color:#f92672>/=</span>g<span style=color:#f92672>--</span>,<span style=color:#f92672>--</span>b;d<span style=color:#f92672>*=</span>b);
}
</code></pre></div><p>​ 实验了一下发现居然真的是，而且效率还挺高的？看了一会实现的原理一直没看懂，作罢。</p>
<p>​ 最后发现是找不到什么除了幂级展开还有啥高效率的算法了好像，还是考虑题目提示的 <strong>三角函数幂级展开</strong>。然后继续在网上搜索了一下，在学长的一个博客里发现了公式。
$$
f_{i} =
\begin{cases}
1 & {i=1}\\
f_{i-1}\times \frac{i-1}{2\times i-1} & {i>1}
\end{cases}
$$</p>
<p>​ 那么拿到了这个式子，我们就可以分析一下，怎么和链表结合起来做了。</p>
<h4 id=链表的设计>
链表的设计
<a class=heading-link href=#%e9%93%be%e8%a1%a8%e7%9a%84%e8%ae%be%e8%ae%a1>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4>
<p>​ 双向链表，也就是每个节点有一个数据域，有前和后两个指针。我考虑到我们做加法和乘法是需要从后往前做，除法是需要从前往后做。因此需要双向遍历，我又添加了一个尾指针，记录当前链表的尾节点的地址，方便从后往前遍历，头节点可以保证从前往后遍历。设计如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>node</span>
{
    <span style=color:#66d9ef>int</span> data;
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span>nxt; 
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span>pre;
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span>tail;
    node()   <span style=color:#75715e>//构造函数，用于初始化
</span><span style=color:#75715e></span>    {
        nxt <span style=color:#f92672>=</span> NULL;
        pre <span style=color:#f92672>=</span> NULL;
           tail <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>;
        data <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    }
}
</code></pre></div><p>​ 数据域就用来存储每一位数字，好比 <strong>3.1415926</strong> 就从第一个节点到第八个节点依次存 <strong>31415926</strong> 。</p>
<h4 id=乘法的实现>
乘法的实现
<a class=heading-link href=#%e4%b9%98%e6%b3%95%e7%9a%84%e5%ae%9e%e7%8e%b0>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4>
<p>​ 另出一个函数，函数声明类似于 <code>void Multi(List L,int k)</code></p>
<p>​ 乘法我们模拟竖式的乘法运算，考虑到这是一个 <strong>高精度大数 * 低精度整数</strong> ，因此我们只需要从尾部到头部依次对每一位做乘法即可，考虑到进位问题，可以有两种办法</p>
<ul>
<li>可以是先做完乘法，然后再回到尾部，再从尾到头依次处理进位，这样的好处是这两种操作分隔开了，操作起来难度不大，也比较好想。</li>
<li>可以是边做乘法边进位，我们定义一个 <code>temp</code> 用来存储低位到高一位的进位，这里要注意的是，对于某一位的操作不是先加上进位再做乘法，是先做乘法，再加低位的进位。</li>
</ul>
<p>​ 但是有一个问题我们需要注意，就是好比 <strong>52 * 3</strong> ，这时候原来的两位数变成三位数了，因此需要我们在头节点和第一个节点之间增加新的节点，并且可能增加的不只是一个，只要 <code>temp</code> 这个进位大于等于10就需要一直创建新的节点来保证进位。</p>
<h4 id=除法的实现>
除法的实现
<a class=heading-link href=#%e9%99%a4%e6%b3%95%e7%9a%84%e5%ae%9e%e7%8e%b0>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4>
<p>​ 另出一个函数，函数声明类似于 <code>void Division(List L,int k)</code></p>
<p>​ 除法也是模拟竖式运算，这个是从头到尾进行处理，这一位的数据做完除法，余数作为下一位的**“进位”** ，这里可以边做边 <strong>“进位”</strong> 。这里这个进位不是乘法的那种进位，注意区分。</p>
<p>​ 需要注意的是最后可能有除不尽的情况，这样我们就可以一直在尾部插入节点，然后处理一直处理数据到<strong>最大位数</strong> 或者 <strong>到 “进位” 为0为止</strong> 。最后不要忘记重置一下尾指针，指向新的尾节点。</p>
<h4 id=加法的实现>
加法的实现
<a class=heading-link href=#%e5%8a%a0%e6%b3%95%e7%9a%84%e5%ae%9e%e7%8e%b0>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4>
<p>​ 函数声明类似于 <code>void Sum(List L,List p)</code> 。</p>
<p>​ 加法的实现也是需要从后往前遍历，然后依次对每一位做加法。先取两个链表的尾节点出来，然后依次向前遍历相加，我们可以把相加的答案放在前面那个链表里面，注意这样是不需要返回值的，因为链表内部是通过地址索引的，我们改变的就是传入链表的值。</p>
<h4 id=最后的整合>
最后的整合
<a class=heading-link href=#%e6%9c%80%e5%90%8e%e7%9a%84%e6%95%b4%e5%90%88>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4>
<p>​ 最后我们总共需要一个和链表，一个 $f_{i}$。 和链表用于计算所有式子的累加和，而 $f_{i-1}$ 其实就是 $f_i$ 的上个阶段 。我们每次把 $f_i$ 和 和链表进行累加即可。</p>
<p>​ 最后再对<strong>和链表乘2</strong> 即可。</p>
<h3 id=代码实现>
代码实现
<a class=heading-link href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;cmath&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> maxsize <span style=color:#f92672>=</span> <span style=color:#ae81ff>600</span>;  <span style=color:#75715e>// 设定求小数点后多少位
</span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>node</span>  <span style=color:#75715e>// 双向链表的结构体
</span><span style=color:#75715e></span>{

    <span style=color:#66d9ef>int</span> data;
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span>nxt;
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span>pre;
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span>tail;
    node()              <span style=color:#75715e>//构造函数，用于初始化
</span><span style=color:#75715e></span>    {
        data <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        tail  <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>;
        nxt <span style=color:#f92672>=</span> NULL;
        pre <span style=color:#f92672>=</span> NULL;
    }

}Node,<span style=color:#f92672>*</span>List;

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Mult</span>(List Head,<span style=color:#66d9ef>int</span> k);      <span style=color:#75715e>// 对链表每一位 *k
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Divi</span>(List Head,<span style=color:#66d9ef>int</span> k);      <span style=color:#75715e>// 对链表每一位 ÷k
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Sum</span>(List a,List b);         <span style=color:#75715e>// 对两个链表的数求和，所得数放在前面链表中
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>InitList</span>(List <span style=color:#f92672>&amp;</span>L);          <span style=color:#75715e>// 初始化链表，并把第一个节点值设为 1
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>InitSum</span>(List <span style=color:#f92672>&amp;</span>L);           <span style=color:#75715e>// 初始化最后存和的链表，并把第一个节点置为1
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Output</span>(List L,<span style=color:#66d9ef>int</span> k);       <span style=color:#75715e>// 输出一个链表，保留 k 位小数
</span><span style=color:#75715e></span>

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
{
    <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    scanf(<span style=color:#e6db74>&#34;%d&#34;</span>,<span style=color:#f92672>&amp;</span>n);             
    List Head,S;
    InitList(Head); 
    InitSum(S);
    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>;i<span style=color:#f92672>&lt;=</span><span style=color:#ae81ff>3000</span>;i<span style=color:#f92672>++</span>)     <span style=color:#75715e>//计算pi值
</span><span style=color:#75715e></span>    {
        Mult(Head,i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
        Divi(Head,<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
        Sum(S,Head);
    }

    Mult(S,<span style=color:#ae81ff>2</span>);
    Output(S,n);
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Mult</span>(List Head,<span style=color:#66d9ef>int</span> k)    <span style=color:#75715e>// 对以Head为头节点的链表中的每一位做乘法
</span><span style=color:#75715e></span>{
    List p <span style=color:#f92672>=</span> Head<span style=color:#f92672>-&gt;</span>tail;      <span style=color:#75715e>// 先把指针指向链表的末尾，方便从后往前做乘法
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span>(p <span style=color:#f92672>!=</span> Head)          <span style=color:#75715e>// 从前往后开始算乘法
</span><span style=color:#75715e></span>    {
        p<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>*=</span> k;
        p <span style=color:#f92672>=</span> p<span style=color:#f92672>-&gt;</span>pre;
<span style=color:#75715e>//      printf(&#34;I have done Multi.\n&#34;);
</span><span style=color:#75715e></span>    }
    p <span style=color:#f92672>=</span> Head<span style=color:#f92672>-&gt;</span>tail;
    <span style=color:#66d9ef>while</span>(p <span style=color:#f92672>!=</span> Head<span style=color:#f92672>-&gt;</span>nxt)     <span style=color:#75715e>//开始处理进位 
</span><span style=color:#75715e></span>    {
        p<span style=color:#f92672>-&gt;</span>pre<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>+=</span> p<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>/</span><span style=color:#ae81ff>10</span>;
        p<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>%=</span> <span style=color:#ae81ff>10</span>;
        p <span style=color:#f92672>=</span> p<span style=color:#f92672>-&gt;</span>pre;
    }
    <span style=color:#66d9ef>while</span>( p<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>10</span>)      <span style=color:#75715e>//一直处理最高位的进位 
</span><span style=color:#75715e></span>    {
        List s <span style=color:#f92672>=</span> (List)malloc(<span style=color:#66d9ef>sizeof</span>(Node));
        s<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> p<span style=color:#f92672>-&gt;</span>data<span style=color:#f92672>/</span><span style=color:#ae81ff>10</span>;
        p<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>%=</span> <span style=color:#ae81ff>10</span>;
        s<span style=color:#f92672>-&gt;</span>pre <span style=color:#f92672>=</span> Head;
        s<span style=color:#f92672>-&gt;</span>nxt <span style=color:#f92672>=</span> p;
        p<span style=color:#f92672>-&gt;</span>pre <span style=color:#f92672>=</span> s;
        Head<span style=color:#f92672>-&gt;</span>nxt <span style=color:#f92672>=</span> s;
        p <span style=color:#f92672>=</span> s;
    }
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Divi</span>(List Head,<span style=color:#66d9ef>int</span> k) <span style=color:#75715e>// 对链表每一位除k
</span><span style=color:#75715e></span>{
    <span style=color:#66d9ef>int</span> temp <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,depth <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;     <span style=color:#75715e>//temp用于进位计算 ，depth 用于计算链表长度
</span><span style=color:#75715e></span>    List p <span style=color:#f92672>=</span> Head<span style=color:#f92672>-&gt;</span>nxt;
    List t;                     <span style=color:#75715e>// 存尾部节点
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span>(p <span style=color:#f92672>!=</span> NULL)            <span style=color:#75715e>//模拟做除法
</span><span style=color:#75715e></span>    {
        depth<span style=color:#f92672>++</span>; 
        p<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>+=</span> temp<span style=color:#f92672>*</span><span style=color:#ae81ff>10</span>; 
        temp <span style=color:#f92672>=</span> p<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>%</span> k;
        p<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>/=</span> k;
        t <span style=color:#f92672>=</span> p;
        p <span style=color:#f92672>=</span> p<span style=color:#f92672>-&gt;</span>nxt;
    }
    p <span style=color:#f92672>=</span> t;
    <span style=color:#66d9ef>while</span>(temp<span style=color:#f92672>!=</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> depth <span style=color:#f92672>&lt;=</span> maxsize)  <span style=color:#75715e>// 如果除不尽，就一直往后拓展节点，但注意不要超过最大位数
</span><span style=color:#75715e></span>    {
<span style=color:#75715e>//      printf(&#34;I have done Division!\n&#34;);
</span><span style=color:#75715e></span>        depth<span style=color:#f92672>++</span>;
        List s <span style=color:#f92672>=</span> (List)malloc(<span style=color:#66d9ef>sizeof</span>(Node));
        s<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> temp<span style=color:#f92672>*</span><span style=color:#ae81ff>10</span>;
        s<span style=color:#f92672>-&gt;</span>nxt <span style=color:#f92672>=</span> NULL;
        s<span style=color:#f92672>-&gt;</span>pre <span style=color:#f92672>=</span> p;
        temp <span style=color:#f92672>=</span> s<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>%</span> k;
        s<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>/=</span> k;
        p<span style=color:#f92672>-&gt;</span>nxt <span style=color:#f92672>=</span> s;
        p <span style=color:#f92672>=</span> s;
    }
    Head<span style=color:#f92672>-&gt;</span>tail <span style=color:#f92672>=</span> p;
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Sum</span>(List a,List b)  <span style=color:#75715e>// 对两个链表的数求和，所得数放在前面链表中
</span><span style=color:#75715e></span>{
    List p <span style=color:#f92672>=</span> a<span style=color:#f92672>-&gt;</span>tail,k <span style=color:#f92672>=</span> b<span style=color:#f92672>-&gt;</span>tail;  <span style=color:#75715e>// 先指向各自的尾部，开始从前往后加
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span>(p<span style=color:#f92672>!=</span>a <span style=color:#f92672>&amp;&amp;</span> k<span style=color:#f92672>!=</span>b)  <span style=color:#75715e>// 遍历到有一个到头节点为止
</span><span style=color:#75715e></span>    {
        p<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>+=</span> k<span style=color:#f92672>-&gt;</span>data;
        p<span style=color:#f92672>-&gt;</span>pre<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>+=</span> p<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>/</span> <span style=color:#ae81ff>10</span>;
        p<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>%=</span> <span style=color:#ae81ff>10</span>;
        p <span style=color:#f92672>=</span> p<span style=color:#f92672>-&gt;</span>pre;
        k <span style=color:#f92672>=</span> k<span style=color:#f92672>-&gt;</span>pre;
    }
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>InitList</span>(List <span style=color:#f92672>&amp;</span>L) <span style=color:#75715e>// 初始化链表，并把第一个节点值设为 1
</span><span style=color:#75715e></span>{
   L <span style=color:#f92672>=</span> (List)malloc(<span style=color:#66d9ef>sizeof</span>(Node));
   L<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
   List s <span style=color:#f92672>=</span> (List)malloc(<span style=color:#66d9ef>sizeof</span>(Node));
   s<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
   s<span style=color:#f92672>-&gt;</span>pre <span style=color:#f92672>=</span> L;
   L<span style=color:#f92672>-&gt;</span>nxt <span style=color:#f92672>=</span> s;
   L<span style=color:#f92672>-&gt;</span>pre <span style=color:#f92672>=</span> NULL;
   L<span style=color:#f92672>-&gt;</span>tail <span style=color:#f92672>=</span> s;
   s<span style=color:#f92672>-&gt;</span>nxt <span style=color:#f92672>=</span> NULL; 
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>InitSum</span>(List <span style=color:#f92672>&amp;</span>L) <span style=color:#75715e>// 初始化最后存和的链表，并把第一个节点置为1
</span><span style=color:#75715e></span>{
    L <span style=color:#f92672>=</span> (List)malloc(<span style=color:#66d9ef>sizeof</span>(Node));
    L<span style=color:#f92672>-&gt;</span>nxt <span style=color:#f92672>=</span> NULL;
    L<span style=color:#f92672>-&gt;</span>pre <span style=color:#f92672>=</span> NULL;
    L<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    List p <span style=color:#f92672>=</span> L;
    <span style=color:#66d9ef>int</span> depth <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>while</span>(depth <span style=color:#f92672>&lt;=</span> maxsize)
    {
        List s <span style=color:#f92672>=</span> (List)malloc(<span style=color:#66d9ef>sizeof</span>(Node));
        s<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        s<span style=color:#f92672>-&gt;</span>pre <span style=color:#f92672>=</span> p;
        p<span style=color:#f92672>-&gt;</span>nxt <span style=color:#f92672>=</span> s;
        s<span style=color:#f92672>-&gt;</span>nxt <span style=color:#f92672>=</span> NULL;
        p <span style=color:#f92672>=</span> s;
        depth<span style=color:#f92672>++</span>;
    }
    L<span style=color:#f92672>-&gt;</span>nxt<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
    L<span style=color:#f92672>-&gt;</span>tail <span style=color:#f92672>=</span> p;
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Output</span>(List L,<span style=color:#66d9ef>int</span> k) <span style=color:#75715e>//输出一个列表，保留 k 位小数
</span><span style=color:#75715e></span>{
    List p <span style=color:#f92672>=</span> L<span style=color:#f92672>-&gt;</span>nxt;
    printf(<span style=color:#e6db74>&#34;%d.&#34;</span>,p<span style=color:#f92672>-&gt;</span>data);
    p <span style=color:#f92672>=</span> p<span style=color:#f92672>-&gt;</span>nxt;
    <span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>while</span>(p <span style=color:#f92672>!=</span> NULL <span style=color:#f92672>&amp;&amp;</span> t<span style=color:#f92672>&lt;</span>k) 
    {
        t<span style=color:#f92672>++</span>;
        printf(<span style=color:#e6db74>&#34;%d&#34;</span>,p<span style=color:#f92672>-&gt;</span>data);
        p <span style=color:#f92672>=</span> p<span style=color:#f92672>-&gt;</span>nxt;
    }
    printf(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
}
</code></pre></div><h3 id=参考链接>
参考链接
<a class=heading-link href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3>
<ul>
<li><a href=https://blog.csdn.net/FSAHFGSADHSAKNDAS/article/details/88745656>数据结构实验：高精度计算圆周率</a></li>
<li><a href=https://blog.csdn.net/LittleWhiteLv/article/details/81587555>圆周率高精度算法</a></li>
</ul>
</div>
<footer>
<script src=https://utteranc.es/client.js repo=zzsqwq/hugo-blog-comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script>
</footer>
</article>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload="renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:!0},{left:'$',right:'$',display:!1},{left:'\\(',right:'\\)',display:!1},{left:'\\[',right:'\\]',display:!0}]})"></script>
</section>
</div>
<footer class=footer>
<section class=container>
©
2019 -
2021
zzsqwq
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.
</section>
</footer>
</main>
<script src=/js/coder.min.03b17769f4f91ae35667e1f2a1ca8c16f50562576cf90ff32b3179926914daa5.js integrity="sha256-A7F3afT5GuNWZ+HyocqMFvUFYlds+Q/zKzF5kmkU2qU="></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Z6EM6V1PVC"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-Z6EM6V1PVC',{anonymize_ip:!1})}</script>
</body>
</html>