<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>高精度计算pi | Zs's Blog</title><meta name=keywords content="数据结构"><meta name=description content="高精度计算PI值
题目描述
使用双向链表作为存储结构，请根据用户输入的一个整数（该整数表示精确到小数点后的位数，可能要求精确到小数点后 500 位），高精度计算PI值。提示：可以利用反三角函数幂级展开式来进行计算。"><meta name=author content="zzsqwq"><link rel=canonical href=https://blog.zzsqwq.cn/posts/67/><meta name=google-site-verification content="G-WF7TH97J9X"><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.zzsqwq.cn/images/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://blog.zzsqwq.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.zzsqwq.cn/images/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.zzsqwq.cn/apple-touch-icon.png><link rel=mask-icon href=https://blog.zzsqwq.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-WF7TH97J9X"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WF7TH97J9X",{anonymize_ip:!1})}</script><meta property="og:title" content="高精度计算pi"><meta property="og:description" content="高精度计算PI值
题目描述
使用双向链表作为存储结构，请根据用户输入的一个整数（该整数表示精确到小数点后的位数，可能要求精确到小数点后 500 位），高精度计算PI值。提示：可以利用反三角函数幂级展开式来进行计算。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.zzsqwq.cn/posts/67/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-04-20T01:25:00+00:00"><meta property="article:modified_time" content="2020-04-20T01:25:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="高精度计算pi"><meta name=twitter:description content="高精度计算PI值
题目描述
使用双向链表作为存储结构，请根据用户输入的一个整数（该整数表示精确到小数点后的位数，可能要求精确到小数点后 500 位），高精度计算PI值。提示：可以利用反三角函数幂级展开式来进行计算。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.zzsqwq.cn/posts/"},{"@type":"ListItem","position":3,"name":"高精度计算pi","item":"https://blog.zzsqwq.cn/posts/67/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"高精度计算pi","name":"高精度计算pi","description":"高精度计算PI值 题目描述 使用双向链表作为存储结构，请根据用户输入的一个整数（该整数表示精确到小数点后的位数，可能要求精确到小数点后 500 位），高精度计算PI值。提示：可以利用反三角函数幂级展开式来进行计算。\n","keywords":["数据结构"],"articleBody":"高精度计算PI值 题目描述 使用双向链表作为存储结构，请根据用户输入的一个整数（该整数表示精确到小数点后的位数，可能要求精确到小数点后 500 位），高精度计算PI值。提示：可以利用反三角函数幂级展开式来进行计算。\n解题思路 求PI的算法 首先这道题是要求必须使用双向链表作为存储结构的，这个需要注意，而且也不能用数组计算完了之后挨个赋值给链表的每个节点，这是耍赖 。\n那么我们开始再想，用什么公式来求 PI 呢？这是一个问题。先没管题目的提示，我去百度了一通，发现了一个很神奇的算法，用三行就可以计算到圆周率小数点后800+位。\n#include using namespace std; long a=1000,b,c=2800,d,e,f[2801],g; int main(){ for(;b-c;) f[b++]=a/5; for(;d=0,g=c*2;c-=14,printf(\"%.3d\",e+d/a),e=d%a) for(b=c;d+=f[b]*a,f[b]=d%--g,d/=g--,--b;d*=b); } ​实验了一下发现居然真的是，而且效率还挺高的？看了一会实现的原理一直没看懂，作罢。\n​最后发现是找不到什么除了幂级展开还有啥高效率的算法了好像，还是考虑题目提示的 三角函数幂级展开。然后继续在网上搜索了一下，在学长的一个博客里发现了公式。 $$ f_{i} = \\begin{cases} 1 \u0026 {i=1}\\\\ f_{i-1}\\times \\frac{i-1}{2\\times i-1} \u0026 {i\u003e1} \\end{cases} $$\n那么拿到了这个式子，我们就可以分析一下，怎么和链表结合起来做了。\n链表的设计 双向链表，也就是每个节点有一个数据域，有前和后两个指针。我考虑到我们做加法和乘法是需要从后往前做，除法是需要从前往后做。因此需要双向遍历，我又添加了一个尾指针，记录当前链表的尾节点的地址，方便从后往前遍历，头节点可以保证从前往后遍历。设计如下：\ntypedef struct node { int data; struct node *nxt; struct node *pre; struct node *tail; node() //构造函数，用于初始化 { nxt = NULL; pre = NULL; tail = this; data = 0; } } 数据域就用来存储每一位数字，好比 3.1415926 就从第一个节点到第八个节点依次存 31415926 。\n乘法的实现 另出一个函数，函数声明类似于 void Multi(List L,int k)\n乘法我们模拟竖式的乘法运算，考虑到这是一个 高精度大数 * 低精度整数 ，因此我们只需要从尾部到头部依次对每一位做乘法即可，考虑到进位问题，可以有两种办法\n可以是先做完乘法，然后再回到尾部，再从尾到头依次处理进位，这样的好处是这两种操作分隔开了，操作起来难度不大，也比较好想。 可以是边做乘法边进位，我们定义一个 temp 用来存储低位到高一位的进位，这里要注意的是，对于某一位的操作不是先加上进位再做乘法，是先做乘法，再加低位的进位。 但是有一个问题我们需要注意，就是好比 52 * 3 ，这时候原来的两位数变成三位数了，因此需要我们在头节点和第一个节点之间增加新的节点，并且可能增加的不只是一个，只要 temp 这个进位大于等于10就需要一直创建新的节点来保证进位。\n除法的实现 另出一个函数，函数声明类似于 void Division(List L,int k)\n除法也是模拟竖式运算，这个是从头到尾进行处理，这一位的数据做完除法，余数作为下一位的**“进位”** ，这里可以边做边 “进位” 。这里这个进位不是乘法的那种进位，注意区分。\n需要注意的是最后可能有除不尽的情况，这样我们就可以一直在尾部插入节点，然后处理一直处理数据到最大位数 或者 到 “进位” 为0为止 。最后不要忘记重置一下尾指针，指向新的尾节点。\n加法的实现 函数声明类似于 void Sum(List L,List p) 。\n加法的实现也是需要从后往前遍历，然后依次对每一位做加法。先取两个链表的尾节点出来，然后依次向前遍历相加，我们可以把相加的答案放在前面那个链表里面，注意这样是不需要返回值的，因为链表内部是通过地址索引的，我们改变的就是传入链表的值。\n最后的整合 最后我们总共需要一个和链表，一个 $f_{i}$。 和链表用于计算所有式子的累加和，而 $f_{i-1}$ 其实就是 $f_i$ 的上个阶段 。我们每次把 $f_i$ 和 和链表进行累加即可。\n最后再对和链表乘2 即可。\n代码实现 #include #include #include #include #include using namespace std; const int maxsize = 600; // 设定求小数点后多少位 typedef struct node // 双向链表的结构体 { int data; struct node *nxt; struct node *pre; struct node *tail; node() //构造函数，用于初始化 { data = 0; tail = this; nxt = NULL; pre = NULL; } }Node,*List; void Mult(List Head,int k); // 对链表每一位 *k void Divi(List Head,int k); // 对链表每一位 ÷k void Sum(List a,List b); // 对两个链表的数求和，所得数放在前面链表中 void InitList(List \u0026L); // 初始化链表，并把第一个节点值设为 1 void InitSum(List \u0026L); // 初始化最后存和的链表，并把第一个节点置为1 void Output(List L,int k); // 输出一个链表，保留 k 位小数 int main() { int n = 0; scanf(\"%d\",\u0026n); List Head,S; InitList(Head); InitSum(S); for(int i=2;i\u003c=3000;i++) //计算pi值 { Mult(Head,i-1); Divi(Head,2*i-1); Sum(S,Head); } Mult(S,2); Output(S,n); return 0; } void Mult(List Head,int k) // 对以Head为头节点的链表中的每一位做乘法 { List p = Head-\u003etail; // 先把指针指向链表的末尾，方便从后往前做乘法 while(p != Head) // 从前往后开始算乘法 { p-\u003edata *= k; p = p-\u003epre; // printf(\"I have done Multi.\\n\"); } p = Head-\u003etail; while(p != Head-\u003enxt) //开始处理进位 { p-\u003epre-\u003edata += p-\u003edata /10; p-\u003edata %= 10; p = p-\u003epre; } while( p-\u003edata \u003e 10) //一直处理最高位的进位 { List s = (List)malloc(sizeof(Node)); s-\u003edata = p-\u003edata/10; p-\u003edata %= 10; s-\u003epre = Head; s-\u003enxt = p; p-\u003epre = s; Head-\u003enxt = s; p = s; } } void Divi(List Head,int k) // 对链表每一位除k { int temp = 0,depth = 0; //temp用于进位计算 ，depth 用于计算链表长度 List p = Head-\u003enxt; List t; // 存尾部节点 while(p != NULL) //模拟做除法 { depth++; p-\u003edata += temp*10; temp = p-\u003edata % k; p-\u003edata /= k; t = p; p = p-\u003enxt; } p = t; while(temp!=0 \u0026\u0026 depth \u003c= maxsize) // 如果除不尽，就一直往后拓展节点，但注意不要超过最大位数 { // printf(\"I have done Division!\\n\"); depth++; List s = (List)malloc(sizeof(Node)); s-\u003edata = temp*10; s-\u003enxt = NULL; s-\u003epre = p; temp = s-\u003edata % k; s-\u003edata /= k; p-\u003enxt = s; p = s; } Head-\u003etail = p; } void Sum(List a,List b) // 对两个链表的数求和，所得数放在前面链表中 { List p = a-\u003etail,k = b-\u003etail; // 先指向各自的尾部，开始从前往后加 while(p!=a \u0026\u0026 k!=b) // 遍历到有一个到头节点为止 { p-\u003edata += k-\u003edata; p-\u003epre-\u003edata += p-\u003edata / 10; p-\u003edata %= 10; p = p-\u003epre; k = k-\u003epre; } } void InitList(List \u0026L) // 初始化链表，并把第一个节点值设为 1 { L = (List)malloc(sizeof(Node)); L-\u003edata = 0; List s = (List)malloc(sizeof(Node)); s-\u003edata = 1; s-\u003epre = L; L-\u003enxt = s; L-\u003epre = NULL; L-\u003etail = s; s-\u003enxt = NULL; } void InitSum(List \u0026L) // 初始化最后存和的链表，并把第一个节点置为1 { L = (List)malloc(sizeof(Node)); L-\u003enxt = NULL; L-\u003epre = NULL; L-\u003edata = 0; List p = L; int depth = 0; while(depth \u003c= maxsize) { List s = (List)malloc(sizeof(Node)); s-\u003edata = 0; s-\u003epre = p; p-\u003enxt = s; s-\u003enxt = NULL; p = s; depth++; } L-\u003enxt-\u003edata = 1; L-\u003etail = p; } void Output(List L,int k) //输出一个列表，保留 k 位小数 { List p = L-\u003enxt; printf(\"%d.\",p-\u003edata); p = p-\u003enxt; int t = 0; while(p != NULL \u0026\u0026 t\u003ck) { t++; printf(\"%d\",p-\u003edata); p = p-\u003enxt; } printf(\"\\n\"); } 参考链接 数据结构实验：高精度计算圆周率 圆周率高精度算法 ","wordCount":"607","inLanguage":"en","datePublished":"2020-04-20T01:25:00Z","dateModified":"2020-04-20T01:25:00Z","author":{"@type":"Person","name":"zzsqwq"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.zzsqwq.cn/posts/67/"},"publisher":{"@type":"Organization","name":"Zs's Blog","logo":{"@type":"ImageObject","url":"https://blog.zzsqwq.cn/images/avatar.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.zzsqwq.cn accesskey=h title="Zs's Blog (Alt + H)">Zs's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.zzsqwq.cn/about title=About><span>About</span></a></li><li><a href=https://blog.zzsqwq.cn/posts title=Posts><span>Posts</span></a></li><li><a href=https://blog.zzsqwq.cn/friends title=Friends><span>Friends</span></a></li><li><a href=https://blog.zzsqwq.cn/contact title=Contact><span>Contact</span></a></li><li><a href=https://blog.zzsqwq.cn/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.zzsqwq.cn>Home</a>&nbsp;»&nbsp;<a href=https://blog.zzsqwq.cn/posts/>Posts</a></div><h1 class=post-title>高精度计算pi</h1><div class=post-meta><span title='2020-04-20 01:25:00 +0000 UTC'>April 20, 2020</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;zzsqwq&nbsp;|&nbsp;<a href=https://github.com/zzsqwq/zzsqwq.github.io/tree/master/content/posts/%e9%ab%98%e7%b2%be%e5%ba%a6%e8%ae%a1%e7%ae%97pi.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e9%ab%98%e7%b2%be%e5%ba%a6%e8%ae%a1%e7%ae%97pi%e5%80%bc aria-label=高精度计算PI值>高精度计算PI值</a><ul><li><a href=#%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0 aria-label=题目描述>题目描述</a></li><li><a href=#%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af aria-label=解题思路>解题思路</a><ul><li><a href=#%e6%b1%82pi%e7%9a%84%e7%ae%97%e6%b3%95 aria-label=求PI的算法>求PI的算法</a></li><li><a href=#%e9%93%be%e8%a1%a8%e7%9a%84%e8%ae%be%e8%ae%a1 aria-label=链表的设计>链表的设计</a></li><li><a href=#%e4%b9%98%e6%b3%95%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label=乘法的实现>乘法的实现</a></li><li><a href=#%e9%99%a4%e6%b3%95%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label=除法的实现>除法的实现</a></li><li><a href=#%e5%8a%a0%e6%b3%95%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label=加法的实现>加法的实现</a></li><li><a href=#%e6%9c%80%e5%90%8e%e7%9a%84%e6%95%b4%e5%90%88 aria-label=最后的整合>最后的整合</a></li></ul></li><li><a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0 aria-label=代码实现>代码实现</a></li><li><a href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5 aria-label=参考链接>参考链接</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=高精度计算pi值>高精度计算PI值<a hidden class=anchor aria-hidden=true href=#高精度计算pi值>#</a></h2><h3 id=题目描述>题目描述<a hidden class=anchor aria-hidden=true href=#题目描述>#</a></h3><p>使用双向链表作为存储结构，请根据用户输入的一个整数（该整数表示精确到小数点后的位数，可能要求精确到小数点后 <strong>500</strong> 位），高精度计算PI值。<strong>提示：可以利用反三角函数幂级展开式来进行计算。</strong></p><h3 id=解题思路>解题思路<a hidden class=anchor aria-hidden=true href=#解题思路>#</a></h3><h4 id=求pi的算法>求PI的算法<a hidden class=anchor aria-hidden=true href=#求pi的算法>#</a></h4><p>首先这道题是要求必须使用双向链表作为存储结构的，这个需要注意，而且也不能用数组计算完了之后挨个赋值给链表的每个节点，<del>这是耍赖</del> 。</p><p>那么我们开始再想，用什么公式来求 <strong>PI</strong> 呢？这是一个问题。先没管题目的提示，我去百度了一通，发现了一个很神奇的算法，用三行就可以计算到圆周率小数点后800+位。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;cstdio&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>long</span> <span class=n>a</span><span class=o>=</span><span class=mi>1000</span><span class=p>,</span><span class=n>b</span><span class=p>,</span><span class=n>c</span><span class=o>=</span><span class=mi>2800</span><span class=p>,</span><span class=n>d</span><span class=p>,</span><span class=n>e</span><span class=p>,</span><span class=n>f</span><span class=p>[</span><span class=mi>2801</span><span class=p>],</span><span class=n>g</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(;</span><span class=n>b</span><span class=o>-</span><span class=n>c</span><span class=p>;)</span> <span class=n>f</span><span class=p>[</span><span class=n>b</span><span class=o>++</span><span class=p>]</span><span class=o>=</span><span class=n>a</span><span class=o>/</span><span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(;</span><span class=n>d</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span><span class=n>g</span><span class=o>=</span><span class=n>c</span><span class=o>*</span><span class=mi>2</span><span class=p>;</span><span class=n>c</span><span class=o>-=</span><span class=mi>14</span><span class=p>,</span><span class=n>printf</span><span class=p>(</span><span class=s>&#34;%.3d&#34;</span><span class=p>,</span><span class=n>e</span><span class=o>+</span><span class=n>d</span><span class=o>/</span><span class=n>a</span><span class=p>),</span><span class=n>e</span><span class=o>=</span><span class=n>d</span><span class=o>%</span><span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>b</span><span class=o>=</span><span class=n>c</span><span class=p>;</span><span class=n>d</span><span class=o>+=</span><span class=n>f</span><span class=p>[</span><span class=n>b</span><span class=p>]</span><span class=o>*</span><span class=n>a</span><span class=p>,</span><span class=n>f</span><span class=p>[</span><span class=n>b</span><span class=p>]</span><span class=o>=</span><span class=n>d</span><span class=o>%--</span><span class=n>g</span><span class=p>,</span><span class=n>d</span><span class=o>/=</span><span class=n>g</span><span class=o>--</span><span class=p>,</span><span class=o>--</span><span class=n>b</span><span class=p>;</span><span class=n>d</span><span class=o>*=</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>​实验了一下发现居然真的是，而且效率还挺高的？看了一会实现的原理一直没看懂，作罢。</p><p>​最后发现是找不到什么除了幂级展开还有啥高效率的算法了好像，还是考虑题目提示的 <strong>三角函数幂级展开</strong>。然后继续在网上搜索了一下，在学长的一个博客里发现了公式。
$$
f_{i} =
\begin{cases}
1 & {i=1}\\
f_{i-1}\times \frac{i-1}{2\times i-1} & {i>1}
\end{cases}
$$</p><p>那么拿到了这个式子，我们就可以分析一下，怎么和链表结合起来做了。</p><h4 id=链表的设计>链表的设计<a hidden class=anchor aria-hidden=true href=#链表的设计>#</a></h4><p>双向链表，也就是每个节点有一个数据域，有前和后两个指针。我考虑到我们做加法和乘法是需要从后往前做，除法是需要从前往后做。因此需要双向遍历，我又添加了一个尾指针，记录当前链表的尾节点的地址，方便从后往前遍历，头节点可以保证从前往后遍历。设计如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>node</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>node</span> <span class=o>*</span><span class=n>nxt</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>node</span> <span class=o>*</span><span class=n>pre</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>node</span> <span class=o>*</span><span class=n>tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>node</span><span class=p>()</span>   <span class=c1>//构造函数，用于初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>nxt</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>pre</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>           <span class=n>tail</span> <span class=o>=</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>data</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>数据域就用来存储每一位数字，好比 <strong>3.1415926</strong> 就从第一个节点到第八个节点依次存 <strong>31415926</strong> 。</p><h4 id=乘法的实现>乘法的实现<a hidden class=anchor aria-hidden=true href=#乘法的实现>#</a></h4><p>另出一个函数，函数声明类似于 <code>void Multi(List L,int k)</code></p><p>乘法我们模拟竖式的乘法运算，考虑到这是一个 <strong>高精度大数 * 低精度整数</strong> ，因此我们只需要从尾部到头部依次对每一位做乘法即可，考虑到进位问题，可以有两种办法</p><ul><li>可以是先做完乘法，然后再回到尾部，再从尾到头依次处理进位，这样的好处是这两种操作分隔开了，操作起来难度不大，也比较好想。</li><li>可以是边做乘法边进位，我们定义一个 <code>temp</code> 用来存储低位到高一位的进位，这里要注意的是，对于某一位的操作不是先加上进位再做乘法，是先做乘法，再加低位的进位。</li></ul><p>但是有一个问题我们需要注意，就是好比 <strong>52 * 3</strong> ，这时候原来的两位数变成三位数了，因此需要我们在头节点和第一个节点之间增加新的节点，并且可能增加的不只是一个，只要 <code>temp</code> 这个进位大于等于10就需要一直创建新的节点来保证进位。</p><h4 id=除法的实现>除法的实现<a hidden class=anchor aria-hidden=true href=#除法的实现>#</a></h4><p>另出一个函数，函数声明类似于 <code>void Division(List L,int k)</code></p><p>除法也是模拟竖式运算，这个是从头到尾进行处理，这一位的数据做完除法，余数作为下一位的**“进位”** ，这里可以边做边 <strong>“进位”</strong> 。这里这个进位不是乘法的那种进位，注意区分。</p><p>需要注意的是最后可能有除不尽的情况，这样我们就可以一直在尾部插入节点，然后处理一直处理数据到<strong>最大位数</strong> 或者 <strong>到 “进位” 为0为止</strong> 。最后不要忘记重置一下尾指针，指向新的尾节点。</p><h4 id=加法的实现>加法的实现<a hidden class=anchor aria-hidden=true href=#加法的实现>#</a></h4><p>函数声明类似于 <code>void Sum(List L,List p)</code> 。</p><p>加法的实现也是需要从后往前遍历，然后依次对每一位做加法。先取两个链表的尾节点出来，然后依次向前遍历相加，我们可以把相加的答案放在前面那个链表里面，注意这样是不需要返回值的，因为链表内部是通过地址索引的，我们改变的就是传入链表的值。</p><h4 id=最后的整合>最后的整合<a hidden class=anchor aria-hidden=true href=#最后的整合>#</a></h4><p>最后我们总共需要一个和链表，一个 $f_{i}$。 和链表用于计算所有式子的累加和，而 $f_{i-1}$ 其实就是 $f_i$ 的上个阶段 。我们每次把 $f_i$ 和 和链表进行累加即可。</p><p>最后再对<strong>和链表乘2</strong> 即可。</p><h3 id=代码实现>代码实现<a hidden class=anchor aria-hidden=true href=#代码实现>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;cstdio&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;cstring&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;cmath&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;algorithm&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>maxsize</span> <span class=o>=</span> <span class=mi>600</span><span class=p>;</span>  <span class=c1>// 设定求小数点后多少位
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>node</span>  <span class=c1>// 双向链表的结构体
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>node</span> <span class=o>*</span><span class=n>nxt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>node</span> <span class=o>*</span><span class=n>pre</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>node</span> <span class=o>*</span><span class=n>tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>node</span><span class=p>()</span>              <span class=c1>//构造函数，用于初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>data</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>tail</span>  <span class=o>=</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>nxt</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>pre</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>Node</span><span class=p>,</span><span class=o>*</span><span class=n>List</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Mult</span><span class=p>(</span><span class=n>List</span> <span class=n>Head</span><span class=p>,</span><span class=kt>int</span> <span class=n>k</span><span class=p>);</span>      <span class=c1>// 对链表每一位 *k
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>Divi</span><span class=p>(</span><span class=n>List</span> <span class=n>Head</span><span class=p>,</span><span class=kt>int</span> <span class=n>k</span><span class=p>);</span>      <span class=c1>// 对链表每一位 ÷k
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>Sum</span><span class=p>(</span><span class=n>List</span> <span class=n>a</span><span class=p>,</span><span class=n>List</span> <span class=n>b</span><span class=p>);</span>         <span class=c1>// 对两个链表的数求和，所得数放在前面链表中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>InitList</span><span class=p>(</span><span class=n>List</span> <span class=o>&amp;</span><span class=n>L</span><span class=p>);</span>          <span class=c1>// 初始化链表，并把第一个节点值设为 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>InitSum</span><span class=p>(</span><span class=n>List</span> <span class=o>&amp;</span><span class=n>L</span><span class=p>);</span>           <span class=c1>// 初始化最后存和的链表，并把第一个节点置为1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>Output</span><span class=p>(</span><span class=n>List</span> <span class=n>L</span><span class=p>,</span><span class=kt>int</span> <span class=n>k</span><span class=p>);</span>       <span class=c1>// 输出一个链表，保留 k 位小数
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>scanf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span><span class=o>&amp;</span><span class=n>n</span><span class=p>);</span>             
</span></span><span class=line><span class=cl>    <span class=n>List</span> <span class=n>Head</span><span class=p>,</span><span class=n>S</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>InitList</span><span class=p>(</span><span class=n>Head</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=n>InitSum</span><span class=p>(</span><span class=n>S</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>2</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=mi>3000</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>     <span class=c1>//计算pi值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Mult</span><span class=p>(</span><span class=n>Head</span><span class=p>,</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Divi</span><span class=p>(</span><span class=n>Head</span><span class=p>,</span><span class=mi>2</span><span class=o>*</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Sum</span><span class=p>(</span><span class=n>S</span><span class=p>,</span><span class=n>Head</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Mult</span><span class=p>(</span><span class=n>S</span><span class=p>,</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Output</span><span class=p>(</span><span class=n>S</span><span class=p>,</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Mult</span><span class=p>(</span><span class=n>List</span> <span class=n>Head</span><span class=p>,</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span>    <span class=c1>// 对以Head为头节点的链表中的每一位做乘法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span> <span class=n>p</span> <span class=o>=</span> <span class=n>Head</span><span class=o>-&gt;</span><span class=n>tail</span><span class=p>;</span>      <span class=c1>// 先把指针指向链表的末尾，方便从后往前做乘法
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span><span class=p>(</span><span class=n>p</span> <span class=o>!=</span> <span class=n>Head</span><span class=p>)</span>          <span class=c1>// 从前往后开始算乘法
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>*=</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>pre</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//      printf(&#34;I have done Multi.\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span> <span class=o>=</span> <span class=n>Head</span><span class=o>-&gt;</span><span class=n>tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>p</span> <span class=o>!=</span> <span class=n>Head</span><span class=o>-&gt;</span><span class=n>nxt</span><span class=p>)</span>     <span class=c1>//开始处理进位 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>-&gt;</span><span class=n>pre</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>/</span><span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>%=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>pre</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>&gt;</span> <span class=mi>10</span><span class=p>)</span>      <span class=c1>//一直处理最高位的进位 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>List</span> <span class=n>s</span> <span class=o>=</span> <span class=p>(</span><span class=n>List</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>Node</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span><span class=o>/</span><span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>%=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=o>-&gt;</span><span class=n>pre</span> <span class=o>=</span> <span class=n>Head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=o>-&gt;</span><span class=n>nxt</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>-&gt;</span><span class=n>pre</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Head</span><span class=o>-&gt;</span><span class=n>nxt</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Divi</span><span class=p>(</span><span class=n>List</span> <span class=n>Head</span><span class=p>,</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=c1>// 对链表每一位除k
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>temp</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span><span class=n>depth</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>     <span class=c1>//temp用于进位计算 ，depth 用于计算链表长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>List</span> <span class=n>p</span> <span class=o>=</span> <span class=n>Head</span><span class=o>-&gt;</span><span class=n>nxt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span> <span class=n>t</span><span class=p>;</span>                     <span class=c1>// 存尾部节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span><span class=p>(</span><span class=n>p</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>            <span class=c1>//模拟做除法
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>depth</span><span class=o>++</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+=</span> <span class=n>temp</span><span class=o>*</span><span class=mi>10</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>        <span class=n>temp</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>%</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>/=</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>nxt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span> <span class=o>=</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>temp</span><span class=o>!=</span><span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>depth</span> <span class=o>&lt;=</span> <span class=n>maxsize</span><span class=p>)</span>  <span class=c1>// 如果除不尽，就一直往后拓展节点，但注意不要超过最大位数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=c1>//      printf(&#34;I have done Division!\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>depth</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>List</span> <span class=n>s</span> <span class=o>=</span> <span class=p>(</span><span class=n>List</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>Node</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>temp</span><span class=o>*</span><span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=o>-&gt;</span><span class=n>nxt</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=o>-&gt;</span><span class=n>pre</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>temp</span> <span class=o>=</span> <span class=n>s</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>%</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>/=</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>-&gt;</span><span class=n>nxt</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>Head</span><span class=o>-&gt;</span><span class=n>tail</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Sum</span><span class=p>(</span><span class=n>List</span> <span class=n>a</span><span class=p>,</span><span class=n>List</span> <span class=n>b</span><span class=p>)</span>  <span class=c1>// 对两个链表的数求和，所得数放在前面链表中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span> <span class=n>p</span> <span class=o>=</span> <span class=n>a</span><span class=o>-&gt;</span><span class=n>tail</span><span class=p>,</span><span class=n>k</span> <span class=o>=</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>tail</span><span class=p>;</span>  <span class=c1>// 先指向各自的尾部，开始从前往后加
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span><span class=p>(</span><span class=n>p</span><span class=o>!=</span><span class=n>a</span> <span class=o>&amp;&amp;</span> <span class=n>k</span><span class=o>!=</span><span class=n>b</span><span class=p>)</span>  <span class=c1>// 遍历到有一个到头节点为止
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+=</span> <span class=n>k</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>-&gt;</span><span class=n>pre</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>/</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>%=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>pre</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>k</span> <span class=o>=</span> <span class=n>k</span><span class=o>-&gt;</span><span class=n>pre</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>InitList</span><span class=p>(</span><span class=n>List</span> <span class=o>&amp;</span><span class=n>L</span><span class=p>)</span> <span class=c1>// 初始化链表，并把第一个节点值设为 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=n>L</span> <span class=o>=</span> <span class=p>(</span><span class=n>List</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>Node</span><span class=p>));</span>
</span></span><span class=line><span class=cl>   <span class=n>L</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=n>List</span> <span class=n>s</span> <span class=o>=</span> <span class=p>(</span><span class=n>List</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>Node</span><span class=p>));</span>
</span></span><span class=line><span class=cl>   <span class=n>s</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=n>s</span><span class=o>-&gt;</span><span class=n>pre</span> <span class=o>=</span> <span class=n>L</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=n>L</span><span class=o>-&gt;</span><span class=n>nxt</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=n>L</span><span class=o>-&gt;</span><span class=n>pre</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=n>L</span><span class=o>-&gt;</span><span class=n>tail</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=n>s</span><span class=o>-&gt;</span><span class=n>nxt</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>InitSum</span><span class=p>(</span><span class=n>List</span> <span class=o>&amp;</span><span class=n>L</span><span class=p>)</span> <span class=c1>// 初始化最后存和的链表，并把第一个节点置为1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>L</span> <span class=o>=</span> <span class=p>(</span><span class=n>List</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>Node</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>L</span><span class=o>-&gt;</span><span class=n>nxt</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>L</span><span class=o>-&gt;</span><span class=n>pre</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>L</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span> <span class=n>p</span> <span class=o>=</span> <span class=n>L</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>depth</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>depth</span> <span class=o>&lt;=</span> <span class=n>maxsize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>List</span> <span class=n>s</span> <span class=o>=</span> <span class=p>(</span><span class=n>List</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>Node</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=o>-&gt;</span><span class=n>pre</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>-&gt;</span><span class=n>nxt</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=o>-&gt;</span><span class=n>nxt</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>depth</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>L</span><span class=o>-&gt;</span><span class=n>nxt</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>L</span><span class=o>-&gt;</span><span class=n>tail</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Output</span><span class=p>(</span><span class=n>List</span> <span class=n>L</span><span class=p>,</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=c1>//输出一个列表，保留 k 位小数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span> <span class=n>p</span> <span class=o>=</span> <span class=n>L</span><span class=o>-&gt;</span><span class=n>nxt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%d.&#34;</span><span class=p>,</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>nxt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>t</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>p</span> <span class=o>!=</span> <span class=nb>NULL</span> <span class=o>&amp;&amp;</span> <span class=n>t</span><span class=o>&lt;</span><span class=n>k</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>nxt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=参考链接>参考链接<a hidden class=anchor aria-hidden=true href=#参考链接>#</a></h3><ul><li><a href=https://blog.csdn.net/FSAHFGSADHSAKNDAS/article/details/88745656>数据结构实验：高精度计算圆周率</a></li><li><a href=https://blog.csdn.net/LittleWhiteLv/article/details/81587555>圆周率高精度算法</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.zzsqwq.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a></li></ul><nav class=paginav><a class=prev href=https://blog.zzsqwq.cn/posts/5/><span class=title>« Prev</span><br><span>排位一和二记录</span></a>
<a class=next href=https://blog.zzsqwq.cn/posts/66/><span class=title>Next »</span><br><span>Python初步学习</span></a></nav></footer><div class=comments><script>let getTheme=window.localStorage&&window.localStorage.getItem("pref-theme");getTheme=getTheme??"preferred_color_scheme";let s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","zzsqwq/hugo-blog-comment"),s.setAttribute("data-repo-id","R_kgDOGgU1qQ"),s.setAttribute("data-category","Announcements"),s.setAttribute("data-category-id","DIC_kwDOGgU1qc4CSX1m"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","top"),s.setAttribute("data-theme",getTheme),s.setAttribute("data-lang",""),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.zzsqwq.cn>Zs's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>function sendMessage(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light"),sendMessage({setConfig:{theme:"light"}})):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"),sendMessage({setConfig:{theme:"dark"}}))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>