<!doctype html><html lang=cn>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta http-equiv=content-language content="cn">
<meta name=color-scheme content="light dark">
<meta name=author content="zzsqwq">
<meta name=description content="
  高精度计算PI值
  
    
  


  题目描述
  
    
  

​	   使用双向链表作为存储结构，请根据用户输入的一个整数（该整数表示精确到小数点后的位数，可能要求精确到小数点后 500 位），高精度计算PI值。提示：可以利用反三角函数幂级展开式来进行计算。">
<meta name=keywords content="blog,developer,personal">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="高精度计算pi">
<meta name=twitter:description content="
  高精度计算PI值
  
    
  


  题目描述
  
    
  

​	   使用双向链表作为存储结构，请根据用户输入的一个整数（该整数表示精确到小数点后的位数，可能要求精确到小数点后 500 位），高精度计算PI值。提示：可以利用反三角函数幂级展开式来进行计算。">
<meta property="og:title" content="高精度计算pi">
<meta property="og:description" content="
  高精度计算PI值
  
    
  


  题目描述
  
    
  

​	   使用双向链表作为存储结构，请根据用户输入的一个整数（该整数表示精确到小数点后的位数，可能要求精确到小数点后 500 位），高精度计算PI值。提示：可以利用反三角函数幂级展开式来进行计算。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zzsqwq.github.io/posts/67/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-04-20T01:25:00+00:00">
<meta property="article:modified_time" content="2020-04-20T01:25:00+00:00">
<title>
高精度计算pi · Zs's Blog
</title>
<link rel=canonical href=https://zzsqwq.github.io/posts/67/>
<link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin>
<link rel=stylesheet href=/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css integrity="sha256-2f3b/+byfmmYXcX+BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin=anonymous media=screen>
<link rel=stylesheet href=/css/coder-dark.min.ccbbada2e264e4fdbf9b2181cccc2cdb289a63dc9520a1e96ac2b9a45778df29.css integrity="sha256-zLutouJk5P2/myGBzMws2yiaY9yVIKHpasK5pFd43yk=" crossorigin=anonymous media=screen>
<link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32>
<link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16>
<link rel=apple-touch-icon href=/images/apple-touch-icon.png>
<link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png>
<meta name=generator content="Hugo 0.89.4">
</head>
<body class="preload-transitions colorscheme-auto">
<div class=float-container>
<a id=dark-mode-toggle class=colorscheme-toggle>
<i class="fa fa-adjust fa-fw" aria-hidden=true></i>
</a>
</div>
<main class=wrapper>
<nav class=navigation>
<section class=container>
<a class=navigation-title href=/>
Zs's Blog
</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle>
<i class="fa fa-bars fa-fw" aria-hidden=true></i>
</label>
<ul class=navigation-list>
<li class=navigation-item>
<a class=navigation-link href=/about/>About</a>
</li>
<li class=navigation-item>
<a class=navigation-link href=/posts/>Blog</a>
</li>
<li class=navigation-item>
<a class=navigation-link href=/projects/>Projects</a>
</li>
<li class=navigation-item>
<a class=navigation-link href=/friends/>Friends</a>
</li>
<li class=navigation-item>
<a class=navigation-link href=/contact/>Contact Me</a>
</li>
</ul>
</section>
</nav>
<div class=content>
<section class="container post">
<article>
<header>
<div class=post-title>
<h1 class=title>
<a class=title-link href=https://zzsqwq.github.io/posts/67/>
高精度计算pi
</a>
</h1>
</div>
<div class=post-meta>
<div class=date>
<span class=posted-on>
<i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2020-04-20T01:25:00Z>
April 20, 2020
</time>
</span>
<span class=reading-time>
<i class="fa fa-clock-o" aria-hidden=true></i>
</span>
</div>
<div class=categories>
<i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a></div>
<div class=tags>
<i class="fa fa-tag" aria-hidden=true></i>
<span class=tag>
<a href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a>
</span></div>
</div>
</header>
<div>
<h2 id=高精度计算pi值>
高精度计算PI值
<a class=heading-link href=#%e9%ab%98%e7%b2%be%e5%ba%a6%e8%ae%a1%e7%ae%97pi%e5%80%bc>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2>
<h3 id=题目描述>
题目描述
<a class=heading-link href=#%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3>
<p>​    使用双向链表作为存储结构，请根据用户输入的一个整数（该整数表示精确到小数点后的位数，可能要求精确到小数点后 <strong>500</strong> 位），高精度计算PI值。<strong>提示：可以利用反三角函数幂级展开式来进行计算。</strong></p>
<h3 id=解题思路>
解题思路
<a class=heading-link href=#%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3>
<h4 id=求pi的算法>
求PI的算法
<a class=heading-link href=#%e6%b1%82pi%e7%9a%84%e7%ae%97%e6%b3%95>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4>
<p>​    首先这道题是要求必须使用双向链表作为存储结构的，这个需要注意，而且也不能用数组计算完了之后挨个赋值给链表的每个节点，<del>这是耍赖</del> 。</p>
<p>​    那么我们开始再想，用什么公式来求 <strong>PI</strong> 呢？这是一个问题。先没管题目的提示，我去百度了一通，发现了一个很神奇的算法，用三行就可以计算到圆周率小数点后800+位。</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span>#include</span><span>&lt;cstdio&gt;</span><span>
</span><span></span>
<span style=font-weight:700>using</span> <span style=font-weight:700>namespace</span> std;

<span>long</span> a=1000,b,c=2800,d,e,f[2801],g;
<span>int</span> main(){
    <span style=font-weight:700>for</span>(;b-c;) f[b++]=a/5;
    <span style=font-weight:700>for</span>(;d=0,g=c*2;c-=14,printf(<span style=font-style:italic>&#34;%.3d&#34;</span>,e+d/a),e=d%a)
    <span style=font-weight:700>for</span>(b=c;d+=f[b]*a,f[b]=d%--g,d/=g--,--b;d*=b);
}
</code></pre></div><p>​    实验了一下发现居然真的是，而且效率还挺高的？看了一会实现的原理一直没看懂，作罢。</p>
<p>​    最后发现是找不到什么除了幂级展开还有啥高效率的算法了好像，还是考虑题目提示的 <strong>三角函数幂级展开</strong>。然后继续在网上搜索了一下，在学长的一个博客里发现了公式。
$$
f_{i} =
\begin{cases}
1 & {i=1}\
f_{i-1}\times \frac{i-1}{2\times i-1} & {i>1}
\end{cases}
$$</p>
<p>$$
\frac{\pi}{2} = \sum_{i=1}^{\infty}{f_i}
$$</p>
<p>​    那么拿到了这个式子，我们就可以分析一下，怎么和链表结合起来做了。</p>
<h4 id=链表的设计>
链表的设计
<a class=heading-link href=#%e9%93%be%e8%a1%a8%e7%9a%84%e8%ae%be%e8%ae%a1>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4>
<p>​    双向链表，也就是每个节点有一个数据域，有前和后两个指针。我考虑到我们做加法和乘法是需要从后往前做，除法是需要从前往后做。因此需要双向遍历，我又添加了一个尾指针，记录当前链表的尾节点的地址，方便从后往前遍历，头节点可以保证从前往后遍历。设计如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=font-weight:700>typedef</span> <span style=font-weight:700>struct</span> <span style=font-weight:700>node</span>
{
    <span>int</span> data;
    <span style=font-weight:700>struct</span> <span style=font-weight:700>node</span> *nxt; 
    <span style=font-weight:700>struct</span> <span style=font-weight:700>node</span> *pre;
    <span style=font-weight:700>struct</span> <span style=font-weight:700>node</span> *tail;
    node()   <span style=font-style:italic>//构造函数，用于初始化
</span><span style=font-style:italic></span>    {
        nxt = NULL;
        pre = NULL;
       	tail = <span style=font-weight:700>this</span>;
        data = 0;
    }
}
</code></pre></div><p>​    数据域就用来存储每一位数字，好比 <strong>3.1415926</strong> 就从第一个节点到第八个节点依次存 <strong>31415926</strong> 。</p>
<h4 id=乘法的实现>
乘法的实现
<a class=heading-link href=#%e4%b9%98%e6%b3%95%e7%9a%84%e5%ae%9e%e7%8e%b0>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4>
<p>​    另出一个函数，函数声明类似于 <code>void Multi(List L,int k)</code></p>
<p>​    乘法我们模拟竖式的乘法运算，考虑到这是一个 <strong>高精度大数 * 低精度整数</strong> ，因此我们只需要从尾部到头部依次对每一位做乘法即可，考虑到进位问题，可以有两种办法</p>
<ul>
<li>可以是先做完乘法，然后再回到尾部，再从尾到头依次处理进位，这样的好处是这两种操作分隔开了，操作起来难度不大，也比较好想。</li>
<li>可以是边做乘法边进位，我们定义一个 <code>temp</code> 用来存储低位到高一位的进位，这里要注意的是，对于某一位的操作不是先加上进位再做乘法，是先做乘法，再加低位的进位。</li>
</ul>
<p>​    但是有一个问题我们需要注意，就是好比 <strong>52 * 3</strong> ，这时候原来的两位数变成三位数了，因此需要我们在头节点和第一个节点之间增加新的节点，并且可能增加的不只是一个，只要 <code>temp</code> 这个进位大于等于10就需要一直创建新的节点来保证进位。</p>
<h4 id=除法的实现>
除法的实现
<a class=heading-link href=#%e9%99%a4%e6%b3%95%e7%9a%84%e5%ae%9e%e7%8e%b0>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4>
<p>​    另出一个函数，函数声明类似于 <code>void Division(List L,int k)</code></p>
<p>​    除法也是模拟竖式运算，这个是从头到尾进行处理，这一位的数据做完除法，余数作为下一位的**“进位”** ，这里可以边做边 <strong>“进位”</strong> 。这里这个进位不是乘法的那种进位，注意区分。</p>
<p>​    需要注意的是最后可能有除不尽的情况，这样我们就可以一直在尾部插入节点，然后处理一直处理数据到<strong>最大位数</strong> 或者 <strong>到 “进位” 为0为止</strong> 。最后不要忘记重置一下尾指针，指向新的尾节点。</p>
<h4 id=加法的实现>
加法的实现
<a class=heading-link href=#%e5%8a%a0%e6%b3%95%e7%9a%84%e5%ae%9e%e7%8e%b0>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4>
<p>​    函数声明类似于 <code>void Sum(List L,List p)</code> 。</p>
<p>​    加法的实现也是需要从后往前遍历，然后依次对每一位做加法。先取两个链表的尾节点出来，然后依次向前遍历相加，我们可以把相加的答案放在前面那个链表里面，注意这样是不需要返回值的，因为链表内部是通过地址索引的，我们改变的就是传入链表的值。</p>
<h4 id=最后的整合>
最后的整合
<a class=heading-link href=#%e6%9c%80%e5%90%8e%e7%9a%84%e6%95%b4%e5%90%88>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4>
<p>​    最后我们总共需要一个和链表，一个 $f_{i}$。 和链表用于计算所有式子的累加和，而 $f_{i-1}$ 其实就是 $f_i$ 的上个阶段 。我们每次把 $f_i$ 和 和链表进行累加即可。</p>
<p>​    最后再对<strong>和链表乘2</strong> 即可。</p>
<h3 id=代码实现>
代码实现
<a class=heading-link href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span>#include</span><span>&lt;cstdio&gt;</span><span>
</span><span>#include</span><span>&lt;cstring&gt;</span><span>
</span><span>#include</span><span>&lt;cmath&gt;</span><span>
</span><span>#include</span><span>&lt;iostream&gt;</span><span>
</span><span>#include</span><span>&lt;algorithm&gt;</span><span>
</span><span></span>
<span style=font-weight:700>using</span> <span style=font-weight:700>namespace</span> std;

<span style=font-weight:700>const</span> <span>int</span> maxsize = 600;  <span style=font-style:italic>// 设定求小数点后多少位
</span><span style=font-style:italic></span><span style=font-weight:700>typedef</span> <span style=font-weight:700>struct</span> <span style=font-weight:700>node</span>  <span style=font-style:italic>// 双向链表的结构体
</span><span style=font-style:italic></span>{
    
    <span>int</span> data;
    <span style=font-weight:700>struct</span> <span style=font-weight:700>node</span> *nxt;
    <span style=font-weight:700>struct</span> <span style=font-weight:700>node</span> *pre;
    <span style=font-weight:700>struct</span> <span style=font-weight:700>node</span> *tail;
    node()              <span style=font-style:italic>//构造函数，用于初始化
</span><span style=font-style:italic></span>    {
        data = 0;
        tail  = <span style=font-weight:700>this</span>;
        nxt = NULL;
        pre = NULL;
    }
    
}Node,*List;

<span>void</span> Mult(List Head,<span>int</span> k);      <span style=font-style:italic>// 对链表每一位 *k
</span><span style=font-style:italic></span><span>void</span> Divi(List Head,<span>int</span> k);      <span style=font-style:italic>// 对链表每一位 ÷k
</span><span style=font-style:italic></span><span>void</span> Sum(List a,List b);         <span style=font-style:italic>// 对两个链表的数求和，所得数放在前面链表中
</span><span style=font-style:italic></span><span>void</span> InitList(List &amp;L);          <span style=font-style:italic>// 初始化链表，并把第一个节点值设为 1
</span><span style=font-style:italic></span><span>void</span> InitSum(List &amp;L);           <span style=font-style:italic>// 初始化最后存和的链表，并把第一个节点置为1
</span><span style=font-style:italic></span><span>void</span> Output(List L,<span>int</span> k);       <span style=font-style:italic>// 输出一个链表，保留 k 位小数
</span><span style=font-style:italic></span>

<span>int</span> main()
{
    <span>int</span> n = 0;
    scanf(<span style=font-style:italic>&#34;%d&#34;</span>,&amp;n);             
    List Head,S;
    InitList(Head); 
    InitSum(S);
    <span style=font-weight:700>for</span>(<span>int</span> i=2;i&lt;=3000;i++)     <span style=font-style:italic>//计算pi值
</span><span style=font-style:italic></span>    {
        Mult(Head,i-1);
        Divi(Head,2*i-1);
        Sum(S,Head);
    }
    
    Mult(S,2);
    Output(S,n);
    <span style=font-weight:700>return</span> 0;
}

<span>void</span> Mult(List Head,<span>int</span> k)    <span style=font-style:italic>// 对以Head为头节点的链表中的每一位做乘法
</span><span style=font-style:italic></span>{
    List p = Head-&gt;tail;      <span style=font-style:italic>// 先把指针指向链表的末尾，方便从后往前做乘法
</span><span style=font-style:italic></span>    <span style=font-weight:700>while</span>(p != Head)          <span style=font-style:italic>// 从前往后开始算乘法
</span><span style=font-style:italic></span>    {
        p-&gt;data *= k;
        p = p-&gt;pre;
<span style=font-style:italic>//      printf(&#34;I have done Multi.\n&#34;);
</span><span style=font-style:italic></span>    }
    p = Head-&gt;tail;
    <span style=font-weight:700>while</span>(p != Head-&gt;nxt)     <span style=font-style:italic>//开始处理进位 
</span><span style=font-style:italic></span>    {
        p-&gt;pre-&gt;data += p-&gt;data /10;
        p-&gt;data %= 10;
        p = p-&gt;pre;
    }
    <span style=font-weight:700>while</span>( p-&gt;data &gt; 10)      <span style=font-style:italic>//一直处理最高位的进位 
</span><span style=font-style:italic></span>    {
        List s = (List)malloc(<span style=font-weight:700>sizeof</span>(Node));
        s-&gt;data = p-&gt;data/10;
        p-&gt;data %= 10;
        s-&gt;pre = Head;
        s-&gt;nxt = p;
        p-&gt;pre = s;
        Head-&gt;nxt = s;
        p = s;
    }
}

<span>void</span> Divi(List Head,<span>int</span> k) <span style=font-style:italic>// 对链表每一位除k
</span><span style=font-style:italic></span>{
    <span>int</span> temp = 0,depth = 0;     <span style=font-style:italic>//temp用于进位计算 ，depth 用于计算链表长度
</span><span style=font-style:italic></span>    List p = Head-&gt;nxt;
    List t;                     <span style=font-style:italic>// 存尾部节点
</span><span style=font-style:italic></span>    <span style=font-weight:700>while</span>(p != NULL)            <span style=font-style:italic>//模拟做除法
</span><span style=font-style:italic></span>    {
        depth++; 
        p-&gt;data += temp*10; 
        temp = p-&gt;data % k;
        p-&gt;data /= k;
        t = p;
        p = p-&gt;nxt;
    }
    p = t;
    <span style=font-weight:700>while</span>(temp!=0 &amp;&amp; depth &lt;= maxsize)  <span style=font-style:italic>// 如果除不尽，就一直往后拓展节点，但注意不要超过最大位数
</span><span style=font-style:italic></span>    {
<span style=font-style:italic>//      printf(&#34;I have done Division!\n&#34;);
</span><span style=font-style:italic></span>        depth++;
        List s = (List)malloc(<span style=font-weight:700>sizeof</span>(Node));
        s-&gt;data = temp*10;
        s-&gt;nxt = NULL;
        s-&gt;pre = p;
        temp = s-&gt;data % k;
        s-&gt;data /= k;
        p-&gt;nxt = s;
        p = s;
    }
    Head-&gt;tail = p;
}

<span>void</span> Sum(List a,List b)  <span style=font-style:italic>// 对两个链表的数求和，所得数放在前面链表中
</span><span style=font-style:italic></span>{
    List p = a-&gt;tail,k = b-&gt;tail;  <span style=font-style:italic>// 先指向各自的尾部，开始从前往后加
</span><span style=font-style:italic></span>    <span style=font-weight:700>while</span>(p!=a &amp;&amp; k!=b)  <span style=font-style:italic>// 遍历到有一个到头节点为止
</span><span style=font-style:italic></span>    {
        p-&gt;data += k-&gt;data;
        p-&gt;pre-&gt;data += p-&gt;data / 10;
        p-&gt;data %= 10;
        p = p-&gt;pre;
        k = k-&gt;pre;
    }
}

<span>void</span> InitList(List &amp;L) <span style=font-style:italic>// 初始化链表，并把第一个节点值设为 1
</span><span style=font-style:italic></span>{
   L = (List)malloc(<span style=font-weight:700>sizeof</span>(Node));
   L-&gt;data = 0;
   List s = (List)malloc(<span style=font-weight:700>sizeof</span>(Node));
   s-&gt;data = 1;
   s-&gt;pre = L;
   L-&gt;nxt = s;
   L-&gt;pre = NULL;
   L-&gt;tail = s;
   s-&gt;nxt = NULL; 
}

<span>void</span> InitSum(List &amp;L) <span style=font-style:italic>// 初始化最后存和的链表，并把第一个节点置为1
</span><span style=font-style:italic></span>{
    L = (List)malloc(<span style=font-weight:700>sizeof</span>(Node));
    L-&gt;nxt = NULL;
    L-&gt;pre = NULL;
    L-&gt;data = 0;
    List p = L;
    <span>int</span> depth = 0;
    <span style=font-weight:700>while</span>(depth &lt;= maxsize)
    {
        List s = (List)malloc(<span style=font-weight:700>sizeof</span>(Node));
        s-&gt;data = 0;
        s-&gt;pre = p;
        p-&gt;nxt = s;
        s-&gt;nxt = NULL;
        p = s;
        depth++;
    }
    L-&gt;nxt-&gt;data = 1;
    L-&gt;tail = p;
}

<span>void</span> Output(List L,<span>int</span> k) <span style=font-style:italic>//输出一个列表，保留 k 位小数
</span><span style=font-style:italic></span>{
    List p = L-&gt;nxt;
    printf(<span style=font-style:italic>&#34;%d.&#34;</span>,p-&gt;data);
    p = p-&gt;nxt;
    <span>int</span> t = 0;
    <span style=font-weight:700>while</span>(p != NULL &amp;&amp; t&lt;k) 
    {
        t++;
        printf(<span style=font-style:italic>&#34;%d&#34;</span>,p-&gt;data);
        p = p-&gt;nxt;
    }
    printf(<span style=font-style:italic>&#34;</span><span style=font-weight:700;font-style:italic>\n</span><span style=font-style:italic>&#34;</span>);
}
</code></pre></div><h3 id=参考链接>
参考链接
<a class=heading-link href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3>
<ul>
<li><a href=https://blog.csdn.net/FSAHFGSADHSAKNDAS/article/details/88745656>数据结构实验：高精度计算圆周率</a></li>
<li><a href=https://blog.csdn.net/LittleWhiteLv/article/details/81587555>圆周率高精度算法</a></li>
</ul>
</div>
<footer>
<script src=https://utteranc.es/client.js repo=zzsqwq/hugo-blog-comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script>
</footer>
</article>
</section>
</div>
<footer class=footer>
<section class=container>
©
2019 -
2021
zzsqwq
·
<a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.
</section>
</footer>
</main>
<script src=/js/coder.min.03b17769f4f91ae35667e1f2a1ca8c16f50562576cf90ff32b3179926914daa5.js integrity="sha256-A7F3afT5GuNWZ+HyocqMFvUFYlds+Q/zKzF5kmkU2qU="></script>
</body>
</html>