<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker-Gitlab 与主机共用 ssh 的 22 端口 | Zs's Blog</title>
<meta name=keywords content="Docker,Gitlab,ssh"><meta name=description content="背景 在使用 Docker 搭建 Gitlab/Gitee 会导致无法与主机端共用 22 端口，这导致 ssh 连接的时候会使用形如 ssh://git@git.xxxx.cn:4022/zs/zsblog.git 的 ssh 链接，而不是像官方 Gitlab 那种非常干净的 git@git.xxxx.cn/zs/zsblog.git 链接。这对于我这种强迫症而言非常的难受啊，但因为主机的 22 端口已经被占用了，无法共用，所以需要考虑两者共享端口的问题。
虽说是两者共用，但其实还是使用类似于端口转发的特点，简单说就是在主机设置 git 用户，然后通过一个脚本将 git 用户的所有 ssh 流量转发到 Gitlab 容器中，从而完成对应的事情。
关于 Gitee 的设置，Gitee 官方的 Docker 部署教程1已经说的很清楚了，按照该步骤执行完全没问题。
而关于 Gitlab 貌似没有比较详尽的教程，搜索后发现了一个 Issue2 以及一篇博文3，后者讲的比较清楚，但是经过实践后发现存在一定问题，因此决定将可行的方案记录下来。
具体步骤 一、初始设置 在开始之前，docker-compose.yml 中设置比较关键的几个配置如下：
gitlab-web: image: 'gitlab/gitlab-ce:latest' container_name: 'gitlab' restart: always environment: GITLAB_OMNIBUS_CONFIG: | gitlab_rails['gitlab_shell_ssh_port'] = 4022 ports: - '3090:80' - '4022:22' - '6060:6060' volumes: - '/srv/gitlab/config:/etc/gitlab' - '/srv/gitlab/logs:/var/log/gitlab' - '/srv/gitlab/data:/var/opt/gitlab' - ."><meta name=author content="zzsqwq"><link rel=canonical href=https://blog.zzsqwq.cn/posts/docker-gitlab-ssh/><meta name=google-site-verification content="G-WF7TH97J9X"><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://blog.zzsqwq.cn/images/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://blog.zzsqwq.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.zzsqwq.cn/images/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.zzsqwq.cn/apple-touch-icon.png><link rel=mask-icon href=https://blog.zzsqwq.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-WF7TH97J9X"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WF7TH97J9X",{anonymize_ip:!1})}</script><meta property="og:title" content="Docker-Gitlab 与主机共用 ssh 的 22 端口"><meta property="og:description" content="背景 在使用 Docker 搭建 Gitlab/Gitee 会导致无法与主机端共用 22 端口，这导致 ssh 连接的时候会使用形如 ssh://git@git.xxxx.cn:4022/zs/zsblog.git 的 ssh 链接，而不是像官方 Gitlab 那种非常干净的 git@git.xxxx.cn/zs/zsblog.git 链接。这对于我这种强迫症而言非常的难受啊，但因为主机的 22 端口已经被占用了，无法共用，所以需要考虑两者共享端口的问题。
虽说是两者共用，但其实还是使用类似于端口转发的特点，简单说就是在主机设置 git 用户，然后通过一个脚本将 git 用户的所有 ssh 流量转发到 Gitlab 容器中，从而完成对应的事情。
关于 Gitee 的设置，Gitee 官方的 Docker 部署教程1已经说的很清楚了，按照该步骤执行完全没问题。
而关于 Gitlab 貌似没有比较详尽的教程，搜索后发现了一个 Issue2 以及一篇博文3，后者讲的比较清楚，但是经过实践后发现存在一定问题，因此决定将可行的方案记录下来。
具体步骤 一、初始设置 在开始之前，docker-compose.yml 中设置比较关键的几个配置如下：
gitlab-web: image: 'gitlab/gitlab-ce:latest' container_name: 'gitlab' restart: always environment: GITLAB_OMNIBUS_CONFIG: | gitlab_rails['gitlab_shell_ssh_port'] = 4022 ports: - '3090:80' - '4022:22' - '6060:6060' volumes: - '/srv/gitlab/config:/etc/gitlab' - '/srv/gitlab/logs:/var/log/gitlab' - '/srv/gitlab/data:/var/opt/gitlab' - ."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.zzsqwq.cn/posts/docker-gitlab-ssh/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-24T13:46:00+00:00"><meta property="article:modified_time" content="2022-04-24T13:46:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker-Gitlab 与主机共用 ssh 的 22 端口"><meta name=twitter:description content="背景 在使用 Docker 搭建 Gitlab/Gitee 会导致无法与主机端共用 22 端口，这导致 ssh 连接的时候会使用形如 ssh://git@git.xxxx.cn:4022/zs/zsblog.git 的 ssh 链接，而不是像官方 Gitlab 那种非常干净的 git@git.xxxx.cn/zs/zsblog.git 链接。这对于我这种强迫症而言非常的难受啊，但因为主机的 22 端口已经被占用了，无法共用，所以需要考虑两者共享端口的问题。
虽说是两者共用，但其实还是使用类似于端口转发的特点，简单说就是在主机设置 git 用户，然后通过一个脚本将 git 用户的所有 ssh 流量转发到 Gitlab 容器中，从而完成对应的事情。
关于 Gitee 的设置，Gitee 官方的 Docker 部署教程1已经说的很清楚了，按照该步骤执行完全没问题。
而关于 Gitlab 貌似没有比较详尽的教程，搜索后发现了一个 Issue2 以及一篇博文3，后者讲的比较清楚，但是经过实践后发现存在一定问题，因此决定将可行的方案记录下来。
具体步骤 一、初始设置 在开始之前，docker-compose.yml 中设置比较关键的几个配置如下：
gitlab-web: image: 'gitlab/gitlab-ce:latest' container_name: 'gitlab' restart: always environment: GITLAB_OMNIBUS_CONFIG: | gitlab_rails['gitlab_shell_ssh_port'] = 4022 ports: - '3090:80' - '4022:22' - '6060:6060' volumes: - '/srv/gitlab/config:/etc/gitlab' - '/srv/gitlab/logs:/var/log/gitlab' - '/srv/gitlab/data:/var/opt/gitlab' - ."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.zzsqwq.cn/posts/"},{"@type":"ListItem","position":3,"name":"Docker-Gitlab 与主机共用 ssh 的 22 端口","item":"https://blog.zzsqwq.cn/posts/docker-gitlab-ssh/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker-Gitlab 与主机共用 ssh 的 22 端口","name":"Docker-Gitlab 与主机共用 ssh 的 22 端口","description":"背景 在使用 Docker 搭建 Gitlab/Gitee 会导致无法与主机端共用 22 端口，这导致 ssh 连接的时候会使用形如 ssh://git@git.xxxx.cn:4022/zs/zsblog.git 的 ssh 链接，而不是像官方 Gitlab 那种非常干净的 git@git.xxxx.cn/zs/zsblog.git 链接。这对于我这种强迫症而言非常的难受啊，但因为主机的 22 端口已经被占用了，无法共用，所以需要考虑两者共享端口的问题。\n虽说是两者共用，但其实还是使用类似于端口转发的特点，简单说就是在主机设置 git 用户，然后通过一个脚本将 git 用户的所有 ssh 流量转发到 Gitlab 容器中，从而完成对应的事情。\n关于 Gitee 的设置，Gitee 官方的 Docker 部署教程1已经说的很清楚了，按照该步骤执行完全没问题。\n而关于 Gitlab 貌似没有比较详尽的教程，搜索后发现了一个 Issue2 以及一篇博文3，后者讲的比较清楚，但是经过实践后发现存在一定问题，因此决定将可行的方案记录下来。\n具体步骤 一、初始设置 在开始之前，docker-compose.yml 中设置比较关键的几个配置如下：\ngitlab-web: image: \u0026#39;gitlab/gitlab-ce:latest\u0026#39; container_name: \u0026#39;gitlab\u0026#39; restart: always environment: GITLAB_OMNIBUS_CONFIG: | gitlab_rails[\u0026#39;gitlab_shell_ssh_port\u0026#39;] = 4022 ports: - \u0026#39;3090:80\u0026#39; - \u0026#39;4022:22\u0026#39; - \u0026#39;6060:6060\u0026#39; volumes: - \u0026#39;/srv/gitlab/config:/etc/gitlab\u0026#39; - \u0026#39;/srv/gitlab/logs:/var/log/gitlab\u0026#39; - \u0026#39;/srv/gitlab/data:/var/opt/gitlab\u0026#39; - .","keywords":["Docker","Gitlab","ssh"],"articleBody":"背景 在使用 Docker 搭建 Gitlab/Gitee 会导致无法与主机端共用 22 端口，这导致 ssh 连接的时候会使用形如 ssh://git@git.xxxx.cn:4022/zs/zsblog.git 的 ssh 链接，而不是像官方 Gitlab 那种非常干净的 git@git.xxxx.cn/zs/zsblog.git 链接。这对于我这种强迫症而言非常的难受啊，但因为主机的 22 端口已经被占用了，无法共用，所以需要考虑两者共享端口的问题。\n虽说是两者共用，但其实还是使用类似于端口转发的特点，简单说就是在主机设置 git 用户，然后通过一个脚本将 git 用户的所有 ssh 流量转发到 Gitlab 容器中，从而完成对应的事情。\n关于 Gitee 的设置，Gitee 官方的 Docker 部署教程1已经说的很清楚了，按照该步骤执行完全没问题。\n而关于 Gitlab 貌似没有比较详尽的教程，搜索后发现了一个 Issue2 以及一篇博文3，后者讲的比较清楚，但是经过实践后发现存在一定问题，因此决定将可行的方案记录下来。\n具体步骤 一、初始设置 在开始之前，docker-compose.yml 中设置比较关键的几个配置如下：\ngitlab-web: image: 'gitlab/gitlab-ce:latest' container_name: 'gitlab' restart: always environment: GITLAB_OMNIBUS_CONFIG: | gitlab_rails['gitlab_shell_ssh_port'] = 4022 ports: - '3090:80' - '4022:22' - '6060:6060' volumes: - '/srv/gitlab/config:/etc/gitlab' - '/srv/gitlab/logs:/var/log/gitlab' - '/srv/gitlab/data:/var/opt/gitlab' - .... #一些其他的配置 如上设置基本可以确保 Gitlab 形如 ssh://git@git.xxxx.cn:4022/zs/zsblog.git 的链接可以使用。\n二、在 Host 宿主机创建与 Gitlab 相同的 git user 为了确保后续一些麻烦的权限问题，我们需要在宿主机也创建一个 git 用户。\n首先我们要检查 Gitlab 容器中 git 用户的 UID 以及 GID，如果不出意外的话，两者都已被硬编码为 998 。不过为了以防万一，我们可以通过下述指令进一步确认：\n❯ docker exec -it gitlab cat /etc/passwd | awk -F':' '{if($1==\"git\") printf(\"uid: %s; gid: %s\\n\"), $3, $4}' # 不出意外结果如下，证明 git 账户的 UID 与 GID 都为 998. uid: 998; gid: 998 这条指令会给出我们对应的 UID 以及 GID。\n接下来我们需要在宿主机中也创建 git 用户，确保 UID 及 GID 都与 Gitlab 容器内的一致。大家可以通过如下指令查看是否已有 git 用户，以及其 UID 与 GID。\n❯ cat /etc/passwd | awk -F':' '{if($1==\"git\") printf(\"uid: %s; gid: %s\\n\"), $3, $4}' 如果没有任何结果，说明没有 git 用户 如果有结果，并且 UID 与 GID 不为 998，说明需要重新该一下对应的 UID 与 GID，大家可以自行搜索解决方案。 我们还需要查看 /etc/passwd 与 /etc/group 两个文件确保 998 没有被使用，如果有使用也需要做对应改变。 如果没有 git 用户，则使用下面指令创建并指定家目录为 /home/git （在 root 用户下）\n❯ groupadd -g 998 git ❯ useradd -m -u 998 -g git -s /bin/sh -d /home/git git 如果已有，则确保其 UID 与 GID 和 Gitlab 容器中 git 用户相同，并确保有家目录 /home/git。\n三、复制 Gitlab 密钥文件 Gitlab 的密钥文件目前存放在容器的 /var/opt/gitlab/.ssh 中，然后根据你在 docker-compose.yml 配置的映射位置看，好比我配置的映射是 /srv/gitlab/data:/var/opt/gitlab，你就可以直接在 /srv/gitlab/data/.ssh 目录下找到对应的密钥文件。\n然后首先在 root 用户权限下执行\n❯ cp -r /srv/gitlab/data/.ssh /home/git/.ssh 将对应的文件夹复制到 git 用户家目录下，然后执行\n❯ chown -R git:git /home/git/.ssh 将所有的文件的权限及组权限都更改为 git 用户\n现在 git 用户的 .ssh 目录结构应该如下，也要确保 .ssh 文件权限为 700，authorized_keys 权限为 6004：\n❯ ls -la total 72 drwx------ 2 git git 4096 Apr 24 15:40 . drwxr-xr-x 5 git git 4096 Apr 24 02:00 .. -rw------- 1 git git 50122 Apr 24 02:00 authorized_keys -rw-r--r-- 1 git git 0 Apr 24 01:57 authorized_keys.lock -rw------- 1 git git 1679 Apr 24 01:48 id_rsa -rw-r--r-- 1 git git 390 Apr 24 01:48 id_rsa.pub -rw-r--r-- 1 git git 222 Apr 24 02:00 known_hosts 四、生成密钥文件 切换到 git 用户并生成密钥对\n❯ su - git ❯ ssh-keygen #然后一路回车 然后将公钥加入 authorized_keys\n❯ cat ~/.ssh/id_rsa.pub \u003e\u003e ~/.ssh/authorized_keys 五、创建脚本文件 我们不妨看一下现在的 authorized_keys 文件，里面应该有形如下面的内容一些行\ncommand=\"/opt/gitlab/embedded/service/gitlab-shell/bin/gitlab-shell key-105\",no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ssh-ed25519 xxxxxxxx 这里说明我们提交时会执行一个 /opt/gitlab/embedded/service/gitlab-shell/bin/gitlab-shell 脚本，这里本应该执行的是容器内的脚本，但是我们现在把它放在了容器外，因此我们需要设置一个脚本将请求转发进去，因此选择在本机的 /opt/gitlab/embedded/service/gitlab-shell/bin 目录下创建一个名为 gitlab-shell 的脚本，命令如下：\n# 创建文件夹 ❯ sudo mkdir -p /opt/gitlab/embedded/service/gitlab-shell/bin # 进入文件夹 ❯ cd /opt/gitlab/embedded/service/gitlab-shell/bin # 创建文件 ❯ sudo vim gitlab-shell 文件内容如下：\n#!/bin/sh ssh -i /home/git/.ssh/id_rsa -p 4022 -o StrictHostKeyChecking=no git@127.0.0.1 \"SSH_ORIGINAL_COMMAND=\\\"$SSH_ORIGINAL_COMMAND\\\" $0 $@\" 需要注意的是，这里的 4022 是指在 docker-compose.yml 文件映射的 4022:22 端口，如果你是 xxx:22 ，则需要在这里填写 xxx，对应起来。内\n然后不要忘记添加执行权限\n❯ sudo chmod +x /opt/gitlab/embedded/service/gitlab-shell/bin/gitlab-shell 六、挂载额外的文件到 Gitlab 容器 修改我们的 docker-compose.yml ，注释掉 gitlab_rails['gitlab_shell_ssh_port'] = 4022 以及添加 '/home/git/.ssh/:/var/opt/gitlab/.ssh' ，将 git 用户的 .ssh 目录挂载到容器内。\ngitlab-web: image: 'gitlab/gitlab-ce:latest' container_name: 'gitlab' restart: always environment: GITLAB_OMNIBUS_CONFIG: | .... ports: - '3090:80' - '4022:22' - '6060:6060' volumes: - '/srv/gitlab/config:/etc/gitlab' - '/srv/gitlab/logs:/var/log/gitlab' - '/srv/gitlab/data:/var/opt/gitlab' - '/home/git/.ssh/:/var/opt/gitlab/.ssh' - .... #一些其他的配置 最后，重启容器即可生效。\n❯ docker-compose up -d 简单的原理说明 使用的原理就是将主机 git 用户的所有 ssh 流量都转发到容器内部。\n转发使用的是宿主机中的/opt/gitlab/embedded/service/gitlab-shell/bin/gitlab-shell 脚本，而因为已经将主机 git 用户 id_rsa.pub 添加到了 authorized_keys 中，因此可以直接免密转发内容到容器内部。\n随后，容器内的 gitlab-shell 脚本对请求进行处理，完成 ssh 请求。\n这里很巧妙的使用了同一个位置的脚本，这也是需要将 git 用户的 .ssh 目录挂载到 Gitlab 内部的原因，但是每个脚本却作用不同，十分的巧妙。\n使用 Docker 安装 ↩ ↩︎\nSharing SSH port between host and the container ↩︎\nExposing ssh port in dockerized gitlab-ce ↩︎\n公钥添加到authorized_keys到文件中之后仍无法免密登陆 ↩︎\n","wordCount":"498","inLanguage":"en","datePublished":"2022-04-24T13:46:00Z","dateModified":"2022-04-24T13:46:00Z","author":{"@type":"Person","name":"zzsqwq"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.zzsqwq.cn/posts/docker-gitlab-ssh/"},"publisher":{"@type":"Organization","name":"Zs's Blog","logo":{"@type":"ImageObject","url":"https://blog.zzsqwq.cn/images/avatar.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.zzsqwq.cn accesskey=h title="Zs's Blog (Alt + H)">Zs's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.zzsqwq.cn/about title=About><span>About</span></a></li><li><a href=https://blog.zzsqwq.cn/posts title=Posts><span>Posts</span></a></li><li><a href=https://blog.zzsqwq.cn/friends title=Friends><span>Friends</span></a></li><li><a href=https://blog.zzsqwq.cn/contact title=Contact><span>Contact</span></a></li><li><a href=https://blog.zzsqwq.cn/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.zzsqwq.cn>Home</a>&nbsp;»&nbsp;<a href=https://blog.zzsqwq.cn/posts/>Posts</a></div><h1 class=post-title>Docker-Gitlab 与主机共用 ssh 的 22 端口</h1><div class=post-meta><span title='2022-04-24 13:46:00 +0000 UTC'>April 24, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;zzsqwq&nbsp;|&nbsp;<a href=https://github.com/zzsqwq/zzsqwq.github.io/tree/master/content/posts/gitlab-ssh-use-22-port.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e8%83%8c%e6%99%af aria-label=背景>背景</a></li><li><a href=#%e5%85%b7%e4%bd%93%e6%ad%a5%e9%aa%a4 aria-label=具体步骤>具体步骤</a><ul><li><a href=#%e4%b8%80%e5%88%9d%e5%a7%8b%e8%ae%be%e7%bd%ae aria-label=一、初始设置>一、初始设置</a></li><li><a href=#%e4%ba%8c%e5%9c%a8-host-%e5%ae%bf%e4%b8%bb%e6%9c%ba%e5%88%9b%e5%bb%ba%e4%b8%8e-gitlab-%e7%9b%b8%e5%90%8c%e7%9a%84-git-user aria-label="二、在 Host 宿主机创建与 Gitlab 相同的 git user">二、在 Host 宿主机创建与 Gitlab 相同的 git user</a></li><li><a href=#%e4%b8%89%e5%a4%8d%e5%88%b6-gitlab-%e5%af%86%e9%92%a5%e6%96%87%e4%bb%b6 aria-label="三、复制 Gitlab 密钥文件">三、复制 Gitlab 密钥文件</a></li><li><a href=#%e5%9b%9b%e7%94%9f%e6%88%90%e5%af%86%e9%92%a5%e6%96%87%e4%bb%b6 aria-label=四、生成密钥文件>四、生成密钥文件</a></li><li><a href=#%e4%ba%94%e5%88%9b%e5%bb%ba%e8%84%9a%e6%9c%ac%e6%96%87%e4%bb%b6 aria-label=五、创建脚本文件>五、创建脚本文件</a></li><li><a href=#%e5%85%ad%e6%8c%82%e8%bd%bd%e9%a2%9d%e5%a4%96%e7%9a%84%e6%96%87%e4%bb%b6%e5%88%b0-gitlab-%e5%ae%b9%e5%99%a8 aria-label="六、挂载额外的文件到 Gitlab 容器">六、挂载额外的文件到 Gitlab 容器</a></li></ul></li><li><a href=#%e7%ae%80%e5%8d%95%e7%9a%84%e5%8e%9f%e7%90%86%e8%af%b4%e6%98%8e aria-label=简单的原理说明>简单的原理说明</a></li></ul></div></details></div><div class=post-content><h2 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h2><p>在使用 Docker 搭建 Gitlab/Gitee 会导致无法与主机端共用 22 端口，这导致 ssh 连接的时候会使用形如 <code>ssh://git@git.xxxx.cn:4022/zs/zsblog.git</code> 的 ssh 链接，而不是像官方 Gitlab 那种非常干净的 <code>git@git.xxxx.cn/zs/zsblog.git</code> 链接。这对于我这种强迫症而言非常的难受啊，但因为主机的 22 端口已经被占用了，无法共用，所以需要考虑两者共享端口的问题。</p><p>虽说是两者共用，但其实还是使用类似于端口转发的特点，简单说就是在主机设置 <code>git</code> 用户，然后通过一个脚本将 <code>git</code> 用户的所有 ssh 流量转发到 Gitlab 容器中，从而完成对应的事情。</p><p>关于 Gitee 的设置，Gitee 官方的 Docker 部署教程<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>已经说的很清楚了，按照该步骤执行完全没问题。</p><p>而关于 Gitlab 貌似没有比较详尽的教程，搜索后发现了一个 Issue<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> 以及一篇博文<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>，后者讲的比较清楚，但是经过实践后发现存在一定问题，因此决定将可行的方案记录下来。</p><h2 id=具体步骤>具体步骤<a hidden class=anchor aria-hidden=true href=#具体步骤>#</a></h2><h3 id=一初始设置>一、初始设置<a hidden class=anchor aria-hidden=true href=#一初始设置>#</a></h3><p>在开始之前，<code>docker-compose.yml</code> 中设置比较关键的几个配置如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>gitlab-web:
</span></span><span class=line><span class=cl>	image: <span class=s1>&#39;gitlab/gitlab-ce:latest&#39;</span>
</span></span><span class=line><span class=cl>	container_name: <span class=s1>&#39;gitlab&#39;</span>
</span></span><span class=line><span class=cl>	restart: always
</span></span><span class=line><span class=cl>	environment:
</span></span><span class=line><span class=cl>		GITLAB_OMNIBUS_CONFIG: <span class=p>|</span>
</span></span><span class=line><span class=cl>			gitlab_rails<span class=o>[</span><span class=s1>&#39;gitlab_shell_ssh_port&#39;</span><span class=o>]</span> <span class=o>=</span> <span class=m>4022</span>
</span></span><span class=line><span class=cl>	ports:
</span></span><span class=line><span class=cl>		- <span class=s1>&#39;3090:80&#39;</span>
</span></span><span class=line><span class=cl>		- <span class=s1>&#39;4022:22&#39;</span>
</span></span><span class=line><span class=cl>		- <span class=s1>&#39;6060:6060&#39;</span>
</span></span><span class=line><span class=cl>	volumes:
</span></span><span class=line><span class=cl>		- <span class=s1>&#39;/srv/gitlab/config:/etc/gitlab&#39;</span>
</span></span><span class=line><span class=cl>		- <span class=s1>&#39;/srv/gitlab/logs:/var/log/gitlab&#39;</span>
</span></span><span class=line><span class=cl>		- <span class=s1>&#39;/srv/gitlab/data:/var/opt/gitlab&#39;</span>
</span></span><span class=line><span class=cl>		- .... <span class=c1>#一些其他的配置</span>
</span></span></code></pre></div><p>如上设置基本可以确保 Gitlab 形如 <code>ssh://git@git.xxxx.cn:4022/zs/zsblog.git</code> 的链接可以使用。</p><h3 id=二在-host-宿主机创建与-gitlab-相同的-git-user>二、在 Host 宿主机创建与 Gitlab 相同的 git user<a hidden class=anchor aria-hidden=true href=#二在-host-宿主机创建与-gitlab-相同的-git-user>#</a></h3><p>为了确保后续一些麻烦的权限问题，我们需要在宿主机也创建一个 <code>git</code> 用户。</p><p>首先我们要检查 Gitlab 容器中 <code>git</code> 用户的 UID 以及 GID，如果不出意外的话，两者都已被<a href=https://gitlab.com/gitlab-org/omnibus-gitlab/blob/d4f3f5d57b16dbf1e1a59f9a5f5cc041ddacf05a/docker/assets/setup>硬编码为 998</a> 。不过为了以防万一，我们可以通过下述指令进一步确认：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>❯ docker <span class=nb>exec</span> -it gitlab cat /etc/passwd <span class=p>|</span> awk -F<span class=s1>&#39;:&#39;</span> <span class=s1>&#39;{if($1==&#34;git&#34;) printf(&#34;uid: %s; gid: %s\n&#34;), $3, $4}&#39;</span>
</span></span><span class=line><span class=cl><span class=c1># 不出意外结果如下，证明 git 账户的 UID 与 GID 都为 998.</span>
</span></span><span class=line><span class=cl>uid: 998<span class=p>;</span> gid: <span class=m>998</span>
</span></span></code></pre></div><p>这条指令会给出我们对应的 UID 以及 GID。</p><p>接下来我们需要在宿主机中也创建 <code>git</code> 用户，确保 UID 及 GID 都与 Gitlab 容器内的一致。大家可以通过如下指令查看是否已有 <code>git</code> 用户，以及其 UID 与 GID。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>❯ cat /etc/passwd <span class=p>|</span> awk -F<span class=s1>&#39;:&#39;</span> <span class=s1>&#39;{if($1==&#34;git&#34;) printf(&#34;uid: %s; gid: %s\n&#34;), $3, $4}&#39;</span>
</span></span></code></pre></div><ul><li>如果没有任何结果，说明没有 <code>git</code> 用户</li><li>如果有结果，并且 UID 与 GID 不为 998，说明需要重新该一下对应的 UID 与 GID，大家可以自行搜索解决方案。</li><li>我们还需要查看 <code>/etc/passwd</code> 与 <code>/etc/group</code> 两个文件确保 998 没有被使用，如果有使用也需要做对应改变。</li></ul><p>如果没有 <code>git</code> 用户，则使用下面指令创建并指定家目录为 <code>/home/git</code> （在 root 用户下）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>❯ groupadd -g <span class=m>998</span> git
</span></span><span class=line><span class=cl>❯ useradd -m -u <span class=m>998</span> -g git -s /bin/sh -d /home/git git
</span></span></code></pre></div><p>如果已有，则确保其 UID 与 GID 和 Gitlab 容器中 <code>git</code> 用户相同，并确保有家目录 <code>/home/git</code>。</p><h3 id=三复制-gitlab-密钥文件>三、复制 Gitlab 密钥文件<a hidden class=anchor aria-hidden=true href=#三复制-gitlab-密钥文件>#</a></h3><p>Gitlab 的密钥文件目前存放在容器的 <code>/var/opt/gitlab/.ssh</code> 中，然后根据你在 <code>docker-compose.yml</code> 配置的映射位置看，好比我配置的映射是 <code>/srv/gitlab/data:/var/opt/gitlab</code>，你就可以直接在 <code>/srv/gitlab/data/.ssh</code> 目录下找到对应的密钥文件。</p><p>然后首先在 <code>root</code> 用户权限下执行</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>❯ cp -r /srv/gitlab/data/.ssh /home/git/.ssh
</span></span></code></pre></div><p>将对应的文件夹复制到 <code>git</code> 用户家目录下，然后执行</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>❯ chown -R git:git /home/git/.ssh
</span></span></code></pre></div><p>将所有的文件的权限及组权限都更改为 <code>git</code> 用户</p><p>现在 <code>git</code> 用户的 <code>.ssh</code> 目录结构应该如下，也要确保 <code>.ssh</code> 文件权限为 <code>700</code>，<code>authorized_keys</code> 权限为 600<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>❯ ls -la
</span></span><span class=line><span class=cl>total <span class=m>72</span>
</span></span><span class=line><span class=cl>drwx------ <span class=m>2</span> git git  <span class=m>4096</span> Apr <span class=m>24</span> 15:40 .
</span></span><span class=line><span class=cl>drwxr-xr-x <span class=m>5</span> git git  <span class=m>4096</span> Apr <span class=m>24</span> 02:00 ..
</span></span><span class=line><span class=cl>-rw------- <span class=m>1</span> git git <span class=m>50122</span> Apr <span class=m>24</span> 02:00 authorized_keys
</span></span><span class=line><span class=cl>-rw-r--r-- <span class=m>1</span> git git     <span class=m>0</span> Apr <span class=m>24</span> 01:57 authorized_keys.lock
</span></span><span class=line><span class=cl>-rw------- <span class=m>1</span> git git  <span class=m>1679</span> Apr <span class=m>24</span> 01:48 id_rsa
</span></span><span class=line><span class=cl>-rw-r--r-- <span class=m>1</span> git git   <span class=m>390</span> Apr <span class=m>24</span> 01:48 id_rsa.pub
</span></span><span class=line><span class=cl>-rw-r--r-- <span class=m>1</span> git git   <span class=m>222</span> Apr <span class=m>24</span> 02:00 known_hosts
</span></span></code></pre></div><h3 id=四生成密钥文件>四、生成密钥文件<a hidden class=anchor aria-hidden=true href=#四生成密钥文件>#</a></h3><p>切换到 <code>git</code> 用户并生成密钥对</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>❯ su - git
</span></span><span class=line><span class=cl>❯ ssh-keygen <span class=c1>#然后一路回车</span>
</span></span></code></pre></div><p>然后将公钥加入 <code>authorized_keys</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>❯ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 
</span></span></code></pre></div><h3 id=五创建脚本文件>五、创建脚本文件<a hidden class=anchor aria-hidden=true href=#五创建脚本文件>#</a></h3><p>我们不妨看一下现在的 <code>authorized_keys</code> 文件，里面应该有形如下面的内容一些行</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>command</span><span class=o>=</span><span class=s2>&#34;/opt/gitlab/embedded/service/gitlab-shell/bin/gitlab-shell key-105&#34;</span>,no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ssh-ed25519 xxxxxxxx
</span></span></code></pre></div><p>这里说明我们提交时会执行一个 <code>/opt/gitlab/embedded/service/gitlab-shell/bin/gitlab-shell</code> 脚本，这里本应该执行的是容器内的脚本，但是我们现在把它放在了容器外，因此我们需要设置一个脚本将请求转发进去，因此选择在本机的 <code>/opt/gitlab/embedded/service/gitlab-shell/bin</code> 目录下创建一个名为 <code>gitlab-shell</code> 的脚本，命令如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 创建文件夹</span>
</span></span><span class=line><span class=cl>❯ sudo mkdir -p /opt/gitlab/embedded/service/gitlab-shell/bin
</span></span><span class=line><span class=cl><span class=c1># 进入文件夹</span>
</span></span><span class=line><span class=cl>❯ <span class=nb>cd</span> /opt/gitlab/embedded/service/gitlab-shell/bin
</span></span><span class=line><span class=cl><span class=c1># 创建文件</span>
</span></span><span class=line><span class=cl>❯ sudo vim gitlab-shell
</span></span></code></pre></div><p>文件内容如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/bin/sh
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>ssh -i /home/git/.ssh/id_rsa -p <span class=m>4022</span> -o <span class=nv>StrictHostKeyChecking</span><span class=o>=</span>no git@127.0.0.1 <span class=s2>&#34;SSH_ORIGINAL_COMMAND=\&#34;</span><span class=nv>$SSH_ORIGINAL_COMMAND</span><span class=s2>\&#34; </span><span class=nv>$0</span><span class=s2> </span><span class=nv>$@</span><span class=s2>&#34;</span>
</span></span></code></pre></div><p>需要注意的是，这里的 <code>4022</code> 是指在 <code>docker-compose.yml</code> 文件映射的 <code>4022:22</code> 端口，如果你是 <code>xxx:22</code> ，则需要在这里填写 <code>xxx</code>，对应起来。内</p><p>然后不要忘记添加执行权限</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>❯ sudo chmod +x /opt/gitlab/embedded/service/gitlab-shell/bin/gitlab-shell
</span></span></code></pre></div><h3 id=六挂载额外的文件到-gitlab-容器>六、挂载额外的文件到 Gitlab 容器<a hidden class=anchor aria-hidden=true href=#六挂载额外的文件到-gitlab-容器>#</a></h3><p>修改我们的 <code>docker-compose.yml</code> ，注释掉 <code>gitlab_rails['gitlab_shell_ssh_port'] = 4022</code> 以及添加 <code>'/home/git/.ssh/:/var/opt/gitlab/.ssh'</code> ，将 <code>git</code> 用户的 <code>.ssh</code> 目录挂载到容器内。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>gitlab-web:
</span></span><span class=line><span class=cl>	image: <span class=s1>&#39;gitlab/gitlab-ce:latest&#39;</span>
</span></span><span class=line><span class=cl>	container_name: <span class=s1>&#39;gitlab&#39;</span>
</span></span><span class=line><span class=cl>	restart: always
</span></span><span class=line><span class=cl>	environment:
</span></span><span class=line><span class=cl>		GITLAB_OMNIBUS_CONFIG: <span class=p>|</span>
</span></span><span class=line><span class=cl>				....
</span></span><span class=line><span class=cl>	ports:
</span></span><span class=line><span class=cl>		- <span class=s1>&#39;3090:80&#39;</span>
</span></span><span class=line><span class=cl>		- <span class=s1>&#39;4022:22&#39;</span>
</span></span><span class=line><span class=cl>		- <span class=s1>&#39;6060:6060&#39;</span>
</span></span><span class=line><span class=cl>	volumes:
</span></span><span class=line><span class=cl>		- <span class=s1>&#39;/srv/gitlab/config:/etc/gitlab&#39;</span>
</span></span><span class=line><span class=cl>		- <span class=s1>&#39;/srv/gitlab/logs:/var/log/gitlab&#39;</span>
</span></span><span class=line><span class=cl>		- <span class=s1>&#39;/srv/gitlab/data:/var/opt/gitlab&#39;</span>
</span></span><span class=line><span class=cl>		- <span class=s1>&#39;/home/git/.ssh/:/var/opt/gitlab/.ssh&#39;</span>
</span></span><span class=line><span class=cl>		- .... <span class=c1>#一些其他的配置</span>
</span></span></code></pre></div><p>最后，重启容器即可生效。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>❯ docker-compose up -d
</span></span></code></pre></div><h2 id=简单的原理说明>简单的原理说明<a hidden class=anchor aria-hidden=true href=#简单的原理说明>#</a></h2><p>使用的原理就是将主机 <code>git</code> 用户的所有 ssh 流量都转发到容器内部。</p><p>转发使用的是宿主机中的<code>/opt/gitlab/embedded/service/gitlab-shell/bin/gitlab-shell</code> 脚本，而因为已经将主机 <code>git</code> 用户 <code>id_rsa.pub</code> 添加到了 <code>authorized_keys</code> 中，因此可以直接免密转发内容到容器内部。</p><p>随后，容器内的 <code>gitlab-shell</code> 脚本对请求进行处理，完成 ssh 请求。</p><p>这里很巧妙的使用了同一个位置的脚本，这也是需要将 <code>git</code> 用户的 <code>.ssh</code> 目录挂载到 Gitlab 内部的原因，但是每个脚本却作用不同，十分的巧妙。</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://docs.gitea.io/zh-cn/install-with-docker/>使用 Docker 安装</a> ↩&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://github.com/sameersbn/docker-gitlab/issues/1517>Sharing SSH port between host and the container</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://blog.xiaket.org/2017/exposing.ssh.port.in.dockerized.gitlab-ce.html>Exposing ssh port in dockerized gitlab-ce</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://blog.csdn.net/kangkanglou/article/details/90760529>公钥添加到authorized_keys到文件中之后仍无法免密登陆</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.zzsqwq.cn/tags/docker/>Docker</a></li><li><a href=https://blog.zzsqwq.cn/tags/gitlab/>Gitlab</a></li><li><a href=https://blog.zzsqwq.cn/tags/ssh/>ssh</a></li></ul><nav class=paginav><a class=prev href=https://blog.zzsqwq.cn/posts/my-hugo-academia-theme/><span class=title>« Prev</span><br><span>一个基于 Hugo 的个人主页主题</span>
</a><a class=next href=https://blog.zzsqwq.cn/posts/224/><span class=title>Next »</span><br><span>关于春节期间的一些碎碎念</span></a></nav></footer><div class=comments><script>let getTheme=window.localStorage&&window.localStorage.getItem("pref-theme");getTheme=getTheme??"preferred_color_scheme";let s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","zzsqwq/hugo-blog-comment"),s.setAttribute("data-repo-id","R_kgDOGgU1qQ"),s.setAttribute("data-category","Announcements"),s.setAttribute("data-category-id","DIC_kwDOGgU1qc4CSX1m"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","top"),s.setAttribute("data-theme",getTheme),s.setAttribute("data-lang",""),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.zzsqwq.cn>Zs's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a> | <a href=http://beian.miit.gov.cn/ target=_blank>鲁ICP备2020034310号</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>function sendMessage(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light"),sendMessage({setConfig:{theme:"light"}})):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"),sendMessage({setConfig:{theme:"dark"}}))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>