<!doctype html><html lang=en><head><title>为什么要使用条件变量？ · Zs's Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="zzsqwq"><meta name=description content="为什么要使用条件变量？ Link to heading 前言 Link to heading 最近看了很多与线程有关的 C++ 新特性，条件变量是见的比较多的一个特性。
看的时候我发现，想要理解一个新的特性，关键的要看它的引入到底解决了哪些问题，没有什么特性我们要实现相同的功能要怎么做？
以我的理解来看，条件变量是一个线程间互相同步与通知的手段，他通过主动唤醒的方式减小了各个线程的开销，取代了简单但是消耗较大的一直被动循环检验与等待。
没有条件变量我们如何实现相同的需求？ Link to heading 这里采用现代C++教程1 中关于条件变量的一个例子作为基础：
不使用条件变量版本 Link to heading #include <queue> #include <chrono> #include <mutex> #include <thread> #include <iostream> #include <condition_variable> int main() { std::queue<int> produced_nums; std::mutex mtx; // 生产者 auto producer = [&]() { for (int i = 0; ; i++) { std::this_thread::sleep_for(std::chrono::milliseconds(900)); std::unique_lock<std::mutex> lock(mtx); std::cout << &#34;producing &#34; << i << std::endl; produced_nums.push(i); } }; // 消费者 auto consumer = [&]() { while (true) { { std::unique_lock<std::mutex> lock(mtx); if(produced_nums."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="为什么要使用条件变量？"><meta name=twitter:description content="为什么要使用条件变量？ Link to heading 前言 Link to heading 最近看了很多与线程有关的 C++ 新特性，条件变量是见的比较多的一个特性。
看的时候我发现，想要理解一个新的特性，关键的要看它的引入到底解决了哪些问题，没有什么特性我们要实现相同的功能要怎么做？
以我的理解来看，条件变量是一个线程间互相同步与通知的手段，他通过主动唤醒的方式减小了各个线程的开销，取代了简单但是消耗较大的一直被动循环检验与等待。
没有条件变量我们如何实现相同的需求？ Link to heading 这里采用现代C++教程1 中关于条件变量的一个例子作为基础：
不使用条件变量版本 Link to heading #include <queue> #include <chrono> #include <mutex> #include <thread> #include <iostream> #include <condition_variable> int main() { std::queue<int> produced_nums; std::mutex mtx; // 生产者 auto producer = [&]() { for (int i = 0; ; i++) { std::this_thread::sleep_for(std::chrono::milliseconds(900)); std::unique_lock<std::mutex> lock(mtx); std::cout << &#34;producing &#34; << i << std::endl; produced_nums.push(i); } }; // 消费者 auto consumer = [&]() { while (true) { { std::unique_lock<std::mutex> lock(mtx); if(produced_nums."><meta property="og:title" content="为什么要使用条件变量？"><meta property="og:description" content="为什么要使用条件变量？ Link to heading 前言 Link to heading 最近看了很多与线程有关的 C++ 新特性，条件变量是见的比较多的一个特性。
看的时候我发现，想要理解一个新的特性，关键的要看它的引入到底解决了哪些问题，没有什么特性我们要实现相同的功能要怎么做？
以我的理解来看，条件变量是一个线程间互相同步与通知的手段，他通过主动唤醒的方式减小了各个线程的开销，取代了简单但是消耗较大的一直被动循环检验与等待。
没有条件变量我们如何实现相同的需求？ Link to heading 这里采用现代C++教程1 中关于条件变量的一个例子作为基础：
不使用条件变量版本 Link to heading #include <queue> #include <chrono> #include <mutex> #include <thread> #include <iostream> #include <condition_variable> int main() { std::queue<int> produced_nums; std::mutex mtx; // 生产者 auto producer = [&]() { for (int i = 0; ; i++) { std::this_thread::sleep_for(std::chrono::milliseconds(900)); std::unique_lock<std::mutex> lock(mtx); std::cout << &#34;producing &#34; << i << std::endl; produced_nums.push(i); } }; // 消费者 auto consumer = [&]() { while (true) { { std::unique_lock<std::mutex> lock(mtx); if(produced_nums."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.zzsqwq.cn/posts/why-use-condition-variable/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-24T23:37:00+00:00"><meta property="article:modified_time" content="2022-08-24T23:37:00+00:00"><link rel=canonical href=https://blog.zzsqwq.cn/posts/why-use-condition-variable/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.f765a0ff3020452ae08fb0d0500e0b84e5baedb574f7c611e8b2b2cea0323eee.css integrity="sha256-92Wg/zAgRSrgj7DQUA4LhOW67bV098YR6LKyzqAyPu4=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Zs's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Posts</a></li><li class=navigation-item><a class=navigation-link href=/friends/>Friends</a></li><li class=navigation-item><a class=navigation-link href=/contact/>Contact Me</a></li><li class=navigation-item><a class=navigation-link href=https://zzsqwq.cn/>Homepage</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://blog.zzsqwq.cn/posts/why-use-condition-variable/>为什么要使用条件变量？</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2022-08-24T23:37:00Z>August 24, 2022</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
7-minute read</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/c++/>C++</a>
<span class=separator>•</span>
<a href=/categories/thread/>Thread</a></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/c++/>C++</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/condition-variable/>Condition variable</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/multithread/>Multithread</a></span></div></div></header><div class=post-content><h1 id=为什么要使用条件变量>为什么要使用条件变量？
<a class=heading-link href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8%e6%9d%a1%e4%bb%b6%e5%8f%98%e9%87%8f><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><h2 id=前言>前言
<a class=heading-link href=#%e5%89%8d%e8%a8%80><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>最近看了很多与线程有关的 C++ 新特性，条件变量是见的比较多的一个特性。</p><p>看的时候我发现，想要理解一个新的特性，关键的要看它的引入到底解决了哪些问题，没有什么特性我们要实现相同的功能要怎么做？</p><p>以我的理解来看，条件变量是一个线程间互相同步与通知的手段，他通过<strong>主动唤醒</strong>的方式减小了各个线程的开销，取代了简单但是消耗较大的一直<strong>被动循环检验与等待</strong>。</p><h2 id=没有条件变量我们如何实现相同的需求>没有条件变量我们如何实现相同的需求？
<a class=heading-link href=#%e6%b2%a1%e6%9c%89%e6%9d%a1%e4%bb%b6%e5%8f%98%e9%87%8f%e6%88%91%e4%bb%ac%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e7%9b%b8%e5%90%8c%e7%9a%84%e9%9c%80%e6%b1%82><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>这里采用现代C++教程<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> 中关于条件变量的一个例子作为基础：</p><h3 id=不使用条件变量版本>不使用条件变量版本
<a class=heading-link href=#%e4%b8%8d%e4%bd%bf%e7%94%a8%e6%9d%a1%e4%bb%b6%e5%8f%98%e9%87%8f%e7%89%88%e6%9c%ac><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;queue&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;chrono&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;mutex&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;thread&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;condition_variable&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> produced_nums;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>mutex mtx;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 生产者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> producer <span style=color:#f92672>=</span> [<span style=color:#f92672>&amp;</span>]() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>this_thread<span style=color:#f92672>::</span>sleep_for(std<span style=color:#f92672>::</span>chrono<span style=color:#f92672>::</span>milliseconds(<span style=color:#ae81ff>900</span>));
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>unique_lock<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>mutex<span style=color:#f92672>&gt;</span> lock(mtx);
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;producing &#34;</span> <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>            produced_nums.push(i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 消费者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> consumer <span style=color:#f92672>=</span> [<span style=color:#f92672>&amp;</span>]() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (true) {
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>              std<span style=color:#f92672>::</span>unique_lock<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>mutex<span style=color:#f92672>&gt;</span> lock(mtx);
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>if</span>(produced_nums.empty()) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>unique_lock<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>mutex<span style=color:#f92672>&gt;</span> lock(mtx);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 短暂取消锁，使得生产者有机会在消费者消费空前继续生产
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            lock.unlock();
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 消费者慢于生产者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            std<span style=color:#f92672>::</span>this_thread<span style=color:#f92672>::</span>sleep_for(std<span style=color:#f92672>::</span>chrono<span style=color:#f92672>::</span>milliseconds(<span style=color:#ae81ff>1000</span>));
</span></span><span style=display:flex><span>            lock.lock();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>produced_nums.empty()) {
</span></span><span style=display:flex><span>                std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;consuming &#34;</span> <span style=color:#f92672>&lt;&lt;</span> produced_nums.front() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>                produced_nums.pop();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 分别在不同的线程中运行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> p(producer);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> cs[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        cs[i] <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span>(consumer);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    p.join();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        cs[i].join();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=使用条件变量版本>使用条件变量版本
<a class=heading-link href=#%e4%bd%bf%e7%94%a8%e6%9d%a1%e4%bb%b6%e5%8f%98%e9%87%8f%e7%89%88%e6%9c%ac><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;queue&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;chrono&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;mutex&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;thread&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;condition_variable&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> produced_nums;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>mutex mtx;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>condition_variable cv;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> notified <span style=color:#f92672>=</span> false;  <span style=color:#75715e>// 通知信号
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 生产者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> producer <span style=color:#f92672>=</span> [<span style=color:#f92672>&amp;</span>]() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>this_thread<span style=color:#f92672>::</span>sleep_for(std<span style=color:#f92672>::</span>chrono<span style=color:#f92672>::</span>milliseconds(<span style=color:#ae81ff>900</span>));
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>unique_lock<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>mutex<span style=color:#f92672>&gt;</span> lock(mtx);
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;producing &#34;</span> <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>            produced_nums.push(i);
</span></span><span style=display:flex><span>            notified <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>            cv.notify_all(); <span style=color:#75715e>// 此处也可以使用 notify_one
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 消费者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> consumer <span style=color:#f92672>=</span> [<span style=color:#f92672>&amp;</span>]() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (true) {
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>unique_lock<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>mutex<span style=color:#f92672>&gt;</span> lock(mtx);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>notified) {  <span style=color:#75715e>// 避免虚假唤醒
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                cv.wait(lock);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 短暂取消锁，使得生产者有机会在消费者消费空前继续生产
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            lock.unlock();
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 消费者慢于生产者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            std<span style=color:#f92672>::</span>this_thread<span style=color:#f92672>::</span>sleep_for(std<span style=color:#f92672>::</span>chrono<span style=color:#f92672>::</span>milliseconds(<span style=color:#ae81ff>1000</span>));
</span></span><span style=display:flex><span>            lock.lock();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>produced_nums.empty()) {
</span></span><span style=display:flex><span>                std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;consuming &#34;</span> <span style=color:#f92672>&lt;&lt;</span> produced_nums.front() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>                produced_nums.pop();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            notified <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 分别在不同的线程中运行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> p(producer);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> cs[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        cs[i] <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span>(consumer);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    p.join();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        cs[i].join();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这两段代码在效果上是等效的，都是一个生产者两个消费者。</p><p>前者使用了 <code>while</code> 循环来一直检查是否可以消费，后者使用了 <code>cv.wait(lock)</code> 条件变量来实现阻塞等待可消费的提醒。</p><p>可以发现在这个例子里，前者是主动的去检查是否可以消费，后者是被动的被提醒可以消费，而主动则代表着需要一直询问查询，主动的 <code>while</code> 循环检查始终在重复如下流程：</p><img src=/images/why-use-condition-variable/why-use-condition-variable-1.png style=zoom:25%><p>而这个上锁、检查、释放锁的过程就是非常冗余、消耗资源、效率低下的，而条件变量解决了这个问题，条件变量做的事：</p><img src=/images/why-use-condition-variable/why-use-condition-variable-2.png style=zoom:25%><p>这里需要注意的一点是，在条件变量调用 <code>wait()</code> 时，做了两件事，一个是阻塞线程等待其他线程唤醒、另一个是释放锁，只有这样才会让别的线程有机会获得锁，而<strong>被唤醒后又会自动上锁。</strong></p><h2 id=为什么要和-mutex-与-lock-一起用>为什么要和 mutex 与 lock 一起用？
<a class=heading-link href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%92%8c-mutex-%e4%b8%8e-lock-%e4%b8%80%e8%b5%b7%e7%94%a8><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>我们常见的搭配就是 condition_variable、mutex、unique_lock 一起使用，那么为什么要这么做呢？</p><p>一个比较常见的说法是，在调用 <code>wait()</code> 函数与线程真正的阻塞等待状态是存在一定时间差的，那么就会存在唤醒丢失的问题，一种情况如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>线程A： ------- 调用 wait<span style=color:#f92672>()</span> 函数 ------- 进入等待状态 ------
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>线程B： -------------------------唤醒A-------------------
</span></span></code></pre></div><p>而我们希望的是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>线程A： ------- 调用 wait<span style=color:#f92672>()</span> 函数 ------- 进入等待状态 ------
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>线程B： -------------------------------------------唤醒A-
</span></span></code></pre></div><p>我们总是要确保，在线程 A 真正进入等待状态后再进行唤醒，因此这里需要一个 lock 来保证我们对于一个线程空闲/等待的改变是原子性的，也就是不应该被其他线程中途干扰。</p><h2 id=为什么使用-unique_lock-而不使用-scoped_lock-或-lock_guard>为什么使用 unique_lock 而不使用 scoped_lock 或 lock_guard
<a class=heading-link href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8-unique_lock-%e8%80%8c%e4%b8%8d%e4%bd%bf%e7%94%a8-scoped_lock-%e6%88%96-lock_guard><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>首先三个函数都是 RAII 的锁管理函数，可以有效解决 lock 后忘记 unlock 的情形，而目前在 C++17 后推荐统一使用 <code>scoped_lock</code> 而不是 <code>lock_guard</code>。</p><p>而使用 <code>unique_lock</code> 是因为我们在使用条件变量时，需要在条件变量 <code>wait</code> 时解除 lock，只有 <code>unique_lock</code> 能够满足这个条件，实现自己更细粒度的锁区间的划分。</p><h2 id=什么是虚假唤醒>什么是虚假唤醒？
<a class=heading-link href=#%e4%bb%80%e4%b9%88%e6%98%af%e8%99%9a%e5%81%87%e5%94%a4%e9%86%92><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>可以注意到在第一部分代码中有这么一段：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>auto</span> consumer <span style=color:#f92672>=</span> [<span style=color:#f92672>&amp;</span>]() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (true) {
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>unique_lock<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>mutex<span style=color:#f92672>&gt;</span> lock(mtx);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>notified) {  <span style=color:#75715e>// 避免虚假唤醒
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                cv.wait(lock);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            notified <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span></code></pre></div><p><strong>避免虚假唤醒</strong>，那么什么是虚假唤醒呢？</p><p>虚假唤醒简而言之就是，<strong>没有满足消费的条件却被唤醒后进行了消费。</strong></p><p>这个发生的可能多是在系统调度层面，具体的可以参考此知乎问题：<a href=https://www.zhihu.com/question/271521213 class=external-link target=_blank rel=noopener>为什么条件锁会产生虚假唤醒现象（spurious wakeup）？</a></p><p>而解决的方案就是在消费之前再检查一下是否满足消费的条件，而这个消费条件多是用一个形如 <code>notified</code> 的 bool 变量来标识是否可以消费。</p><p>如果不检查，带条件变量的执行流程就会像如下这样：</p><img src=/images/why-use-condition-variable/why-use-condition-variable-3.png style=zoom:25% align=center/><p>其中少了一步检查是否可以消费的过程。</p><h2 id=后记>后记
<a class=heading-link href=#%e5%90%8e%e8%ae%b0><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>本文记录了我在学习条件变量过程中的一些疑问，如有错误之处，敬请交流指正。</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://changkun.de/modern-cpp/ class=external-link target=_blank rel=noopener>https://changkun.de/modern-cpp/</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer><div class=comments><script>let getTheme=window.localStorage&&window.localStorage.getItem("colorscheme");getTheme=getTheme??"preferred_color_scheme";let s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","zzsqwq/hugo-blog-comment"),s.setAttribute("data-repo-id","R_kgDOGgU1qQ"),s.setAttribute("data-category","Announcements"),s.setAttribute("data-category-id","DIC_kwDOGgU1qc4CSX1m"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","top"),s.setAttribute("data-theme",getTheme),s.setAttribute("data-lang",""),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div><div class=comments><script>let getTheme=window.localStorage&&window.localStorage.getItem("colorscheme");getTheme=getTheme??"preferred_color_scheme";let s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","zzsqwq/hugo-blog-comment"),s.setAttribute("data-repo-id","R_kgDOGgU1qQ"),s.setAttribute("data-category","Announcements"),s.setAttribute("data-category-id","DIC_kwDOGgU1qc4CSX1m"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-term",""),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","top"),s.setAttribute("data-theme",getTheme),s.setAttribute("data-lang","en"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></footer></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script></section></div><footer class=footer><section class=container><a href=http://beian.miit.gov.cn/ target=_blank>鲁ICP备2020034310号</a></br>©
2019 -
2023
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WF7TH97J9X"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WF7TH97J9X",{anonymize_ip:!1})}</script></body></html>