<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ACM on Zs's Blog</title><link>https://zzsqwq.github.io/categories/acm/</link><description>Recent content in ACM on Zs's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 19 Aug 2020 13:21:00 +0000</lastBuildDate><atom:link href="https://zzsqwq.github.io/categories/acm/index.xml" rel="self" type="application/rss+xml"/><item><title>排位三和四记录</title><link>https://zzsqwq.github.io/posts/68/</link><pubDate>Wed, 19 Aug 2020 13:21:00 +0000</pubDate><guid>https://zzsqwq.github.io/posts/68/</guid><description>&lt;h1 id="day-3">
Day 3
&lt;a class="heading-link" href="#day-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h1>
&lt;h2 id="a-黑妹的游戏httpsacnowcodercomacmcontest6956a">
A. &lt;a href="https://ac.nowcoder.com/acm/contest/6956/A">黑妹的游戏Ⅰ&lt;/a>
&lt;a class="heading-link" href="#a-%e9%bb%91%e5%a6%b9%e7%9a%84%e6%b8%b8%e6%88%8fhttpsacnowcodercomacmcontest6956a">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    给出三个不同的初始数字$a,b,c$，黑妹每次选择两个不同的数字，计算出差的绝对值后如果黑板上没有就写在黑板上。问黑妹最多能添加多少个数字。&lt;/p>
&lt;h3 id="思路">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    考虑到辗转相除法的那种过程（其实我也是突发奇想，严谨证明不会），最后黑板上所有的数字是
$$
ans = \frac{max(a,b,c)}{gcd(a,b,c)}
$$
​    然后就需要减去黑板上原来的三个数就行。&lt;/p>
&lt;h3 id="代码实现">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">int&lt;/span> t;
&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> a,b,c;
&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">gcd&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> a,&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> b)
{
&lt;span style="color:#66d9ef">if&lt;/span>(b &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> a;
&lt;span style="color:#66d9ef">return&lt;/span> gcd(b,a&lt;span style="color:#f92672">%&lt;/span>b);
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%lld%lld%lld&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a,&lt;span style="color:#f92672">&amp;amp;&lt;/span>b,&lt;span style="color:#f92672">&amp;amp;&lt;/span>c);
&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> p &lt;span style="color:#f92672">=&lt;/span> max(max(a,b),c);
&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> gcd(gcd(a,b),c);
printf(&lt;span style="color:#e6db74">&amp;#34;%lld&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,p&lt;span style="color:#f92672">/&lt;/span>k&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="b-御坂美琴httpsacnowcodercomacmcontest6956b">
B. &lt;a href="https://ac.nowcoder.com/acm/contest/6956/B">御坂美琴&lt;/a>
&lt;a class="heading-link" href="#b-%e5%be%a1%e5%9d%82%e7%be%8e%e7%90%b4httpsacnowcodercomacmcontest6956b">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-1">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    有 $n$ 个玩偶堆成一堆。$(1\le n \le 10^{18})$&lt;/p>
&lt;p>​    你可以指定某一有 $x$ 个玩偶的玩偶堆将他分成 $\lfloor \frac{x}{2}\rfloor$ 和 $x-\lfloor \frac{x}{2} \rfloor$ 两堆。&lt;/p>
&lt;p>​    现给定有 $m$ 个数的序列 $a$ ，问能否通过若干次操作使得第 $i$ 堆玩偶数为 $a_i$ 。如果可以输出 &lt;strong>misaka&lt;/strong> 否则输出 &lt;strong>ham&lt;/strong> 。$(1\le m\le 10^5) , (1\le a_i\le 10^{18})$&lt;/p>
&lt;h3 id="思路-1">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    首先我们可以想到，我们输入序列 $a$ 的时候可以将他累加起来成 $sum$ ，然后考虑最后$sum$ 是否和 $n$ 相同，不同的话肯定是不满足条件的，直接输出&lt;strong>ham&lt;/strong>退出即可。&lt;/p>
&lt;p>​    否则我们就用 $dfs(n)$ 分割这个 n个玩偶的玩偶堆。因为 $n$ 比较大，考虑开一个&lt;strong>map&lt;/strong>映射 $p$ 记录是否已经有为 $i$ 个玩偶的玩偶堆，如果有的话 $p[i] = 1$。如果没有 $p[i] = 0$ 。&lt;/p>
&lt;p>​    然后加一个递归结束的条件，就是当 $dfs(k)$ 的时候 $k == 1$ ，那么就不可再分了，直接返回。&lt;/p>
&lt;h3 id="代码实现-1">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;queue&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;map&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#75715e">#define ll long long
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> maxn &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1e18&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxm &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1e5&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>;
ll n,m;
ll a[maxm];
ll sum;
map&lt;span style="color:#f92672">&amp;lt;&lt;/span>ll,&lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> mp;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">cmp&lt;/span>(ll a,ll b)
{
&lt;span style="color:#66d9ef">return&lt;/span> a&lt;span style="color:#f92672">&amp;gt;&lt;/span>b;
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(ll p)
{
&lt;span style="color:#66d9ef">if&lt;/span>(mp[p] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">||&lt;/span> p&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> ;
&lt;span style="color:#66d9ef">else&lt;/span>
{
mp[p] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
dfs(p&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
dfs(p&lt;span style="color:#f92672">-&lt;/span>(p&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>));
}
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%lld%lld&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>m);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>m;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%lld&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i]);
sum &lt;span style="color:#f92672">+=&lt;/span> a[i];
}
&lt;span style="color:#66d9ef">if&lt;/span>(sum &lt;span style="color:#f92672">!=&lt;/span> n)
{
printf(&lt;span style="color:#e6db74">&amp;#34;ham&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;span style="color:#75715e">// sort(a+1,a+1+m,cmp);
&lt;/span>&lt;span style="color:#75715e">&lt;/span> dfs(n);
mp[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>m;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(mp[a[i]] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
{
printf(&lt;span style="color:#e6db74">&amp;#34;ham&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
}
printf(&lt;span style="color:#e6db74">&amp;#34;misaka&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="day-4">
Day 4
&lt;a class="heading-link" href="#day-4">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h1>
&lt;h2 id="a-distancehttpsacnowcodercomacmcontest6957a">
A. &lt;a href="https://ac.nowcoder.com/acm/contest/6957/A">Distance&lt;/a>
&lt;a class="heading-link" href="#a-distancehttpsacnowcodercomacmcontest6957a">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-2">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    给定有 $n$ 个数的序列 $A$ ，第 $i$ 个位置对应的值为 $A_i$ 。$(n\le 10^5 ,A_i \le 10^9)$&lt;/p>
&lt;p>​    定义 $FST$ 距离为 $|i^2 - j^2| + |A_i^2 - A_j^2|$ ，现在 $fst$ 想在序列 $A$ 中找到距离最大的一对元素，他不关心是哪一对，只想要求出最大的距离。&lt;/p>
&lt;h3 id="思路-2">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    我们分情况讨论一下&lt;/p>
&lt;ul>
&lt;li>当 $i &amp;gt; j$ 并且 $A_i &amp;gt; A_j$ ，我们去掉绝对值后 $dis = i^2 + A_i^2 - (j^2 + A_j^2)$&lt;/li>
&lt;li>当 $i &amp;gt; j$ 并且 $A_i &amp;lt; A_j$ ，我们去掉绝对值后 $ dis = i^2 -A_i^2 -(j^2-A_j^2)$&lt;/li>
&lt;/ul>
&lt;p>​    所以我们只需要在输入的时候维护两个数组，分别为 $p[i] = i^2+A_i^2 ,q[i] = i^2-A_i^2$ ，排序一下，然后在上面两个 $dis$ 中取一个最大值即可。&lt;/p>
&lt;h3 id="代码实现-2">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#75715e">#define ll long long
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1e5&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> n;
&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> a[maxn];
&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> f1[maxn];
&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> f2[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">cmp&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> a,&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> b)
{
&lt;span style="color:#66d9ef">return&lt;/span> a&lt;span style="color:#f92672">&amp;gt;&lt;/span>b;
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%lld&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i]);
f1[i] &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>)i&lt;span style="color:#f92672">*&lt;/span>i &lt;span style="color:#f92672">+&lt;/span> (&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>)a[i]&lt;span style="color:#f92672">*&lt;/span>a[i];
f2[i] &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>)i&lt;span style="color:#f92672">*&lt;/span>i &lt;span style="color:#f92672">-&lt;/span> (&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>)a[i]&lt;span style="color:#f92672">*&lt;/span>a[i];
}
sort(f1&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,f1&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>n,cmp);
sort(f2&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,f2&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>n,cmp);
ll p &lt;span style="color:#f92672">=&lt;/span> f1[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">-&lt;/span> f1[n];
ll k &lt;span style="color:#f92672">=&lt;/span> f2[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">-&lt;/span> f2[n];
&lt;span style="color:#66d9ef">if&lt;/span>(p &lt;span style="color:#f92672">&amp;gt;&lt;/span> k)
{
printf(&lt;span style="color:#e6db74">&amp;#34;%lld&amp;#34;&lt;/span>,p);
}
&lt;span style="color:#66d9ef">else&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;%lld&amp;#34;&lt;/span>,k);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="b-字典序最小的中序遍历httpsacnowcodercomacmcontest6957b">
B. &lt;a href="https://ac.nowcoder.com/acm/contest/6957/B">字典序最小的中序遍历&lt;/a>
&lt;a class="heading-link" href="#b-%e5%ad%97%e5%85%b8%e5%ba%8f%e6%9c%80%e5%b0%8f%e7%9a%84%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86httpsacnowcodercomacmcontest6957b">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-3">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    给一个有根二叉树,可以无限次的交换任意节点的左右子树,问最少交换多少次使得该树的中序遍历的字典序最小?&lt;/p>
&lt;h3 id="思路-3">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    首先这题我上来觉得他就是个贪心题。。不然真的无从下手。&lt;/p>
&lt;p>​    那么字典序最小，只能是左边小于右边，如果不是的话就直接交换就完事了，然后 $ans++$ 即可。&lt;/p>
&lt;p>​    然后最后利用 $dfs$ 进行树的中序遍历即可。看代码还是比较好懂的。&lt;/p>
&lt;h3 id="代码实现-3">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">int&lt;/span> n,m;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">500005&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> a[maxn],b[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> ans &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">rev&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> p)
{
&lt;span style="color:#66d9ef">int&lt;/span> l &lt;span style="color:#f92672">=&lt;/span> p ,r &lt;span style="color:#f92672">=&lt;/span> p;
&lt;span style="color:#66d9ef">if&lt;/span>(a[p]) l &lt;span style="color:#f92672">=&lt;/span> rev(a[p]);
&lt;span style="color:#66d9ef">if&lt;/span>(b[p]) r &lt;span style="color:#f92672">=&lt;/span> rev(b[p]);
&lt;span style="color:#66d9ef">if&lt;/span>(l &lt;span style="color:#f92672">&amp;gt;&lt;/span> r)
{
swap(a[p],b[p]);
ans&lt;span style="color:#f92672">++&lt;/span>;
}
&lt;span style="color:#66d9ef">return&lt;/span> l&lt;span style="color:#f92672">&amp;lt;&lt;/span>r&lt;span style="color:#f92672">?&lt;/span>l:r;
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> p)
{
&lt;span style="color:#66d9ef">if&lt;/span>(a[p]&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> b[p] &lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
{
printf(&lt;span style="color:#e6db74">&amp;#34;%d &amp;#34;&lt;/span>,p);
&lt;span style="color:#66d9ef">return&lt;/span> ;
}
&lt;span style="color:#66d9ef">if&lt;/span>(a[p]) dfs(a[p]);
printf(&lt;span style="color:#e6db74">&amp;#34;%d &amp;#34;&lt;/span>,p);
&lt;span style="color:#66d9ef">if&lt;/span>(b[p]) dfs(b[p]);
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>m);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i],&lt;span style="color:#f92672">&amp;amp;&lt;/span>b[i]);
}
&lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> rev(m);
printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,ans);
dfs(m);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>排位一和二记录</title><link>https://zzsqwq.github.io/posts/5/</link><pubDate>Mon, 17 Aug 2020 20:04:00 +0000</pubDate><guid>https://zzsqwq.github.io/posts/5/</guid><description>&lt;h1 id="day-1">
Day 1
&lt;a class="heading-link" href="#day-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h1>
&lt;h2 id="a-兔子的区间密码httpsacnowcodercomacmcontest6954a">
A. &lt;a href="https://ac.nowcoder.com/acm/contest/6954/A">兔子的区间密码&lt;/a>
&lt;a class="heading-link" href="#a-%e5%85%94%e5%ad%90%e7%9a%84%e5%8c%ba%e9%97%b4%e5%af%86%e7%a0%81httpsacnowcodercomacmcontest6954a">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    给定一个区间$[L,R]$ ，求从这个区间任意取两个整数(可以相同)，两者异或后能得到的最大值是多少？&lt;/p>
&lt;h3 id="思路">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    首先我们想一下特例，当 $L==R$ 的时候，那么只能是L和他自己异或，就是0了。&lt;/p>
&lt;p>​    然后可以分两部分来想，设区间端点 $L,R$ 的二进制最高位，从右往左开始数位置分别为 $p_1,p_2$&lt;/p>
&lt;ul>
&lt;li>如果 $p_1 \neq p_2 $ ，那么必然是 $p_1 &amp;lt; p_2$ ，我们很容易发现这时候肯定可以取到 $2^{p_2-1}-1 和 2^{p_2-1}$ ，那么两者异或一下就是最大的，答案为 $2^{p_2}$&lt;/li>
&lt;li>如果 $p_1 == p_2$ ，那么我们可以转化为更小规模的问题，就是区间为 $[L-2^{p_1-1},R-2^{p_1-1}]$ 。&lt;/li>
&lt;/ul>
&lt;h3 id="代码实现">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#75715e">#define ll long long
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
ll l,r;
&lt;span style="color:#66d9ef">int&lt;/span> t;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
ll l,r;
scanf(&lt;span style="color:#e6db74">&amp;#34;%lld%lld&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>l,&lt;span style="color:#f92672">&amp;amp;&lt;/span>r);
&lt;span style="color:#66d9ef">if&lt;/span>(l &lt;span style="color:#f92672">==&lt;/span> r)
{
printf(&lt;span style="color:#e6db74">&amp;#34;0&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
&lt;span style="color:#66d9ef">int&lt;/span> p1 &lt;span style="color:#f92672">=&lt;/span> log2(l),p2 &lt;span style="color:#f92672">=&lt;/span> log2(r);
&lt;span style="color:#66d9ef">while&lt;/span>(p1 &lt;span style="color:#f92672">==&lt;/span> p2 &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> l &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
{
l&lt;span style="color:#f92672">^=&lt;/span>(&lt;span style="color:#ae81ff">1LL&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>p1);
r&lt;span style="color:#f92672">^=&lt;/span>(&lt;span style="color:#ae81ff">1LL&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>p1);
p1 &lt;span style="color:#f92672">=&lt;/span> log2(l),p2&lt;span style="color:#f92672">=&lt;/span>log2(r);
}
printf(&lt;span style="color:#e6db74">&amp;#34;%lld&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,((&lt;span style="color:#ae81ff">1LL&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>(p2&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>))&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>));
}
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="b-猴子排序的期望httpsacnowcodercomacmcontest6954b">
B. &lt;a href="https://ac.nowcoder.com/acm/contest/6954/B">猴子排序的期望&lt;/a>
&lt;a class="heading-link" href="#b-%e7%8c%b4%e5%ad%90%e6%8e%92%e5%ba%8f%e7%9a%84%e6%9c%9f%e6%9c%9bhttpsacnowcodercomacmcontest6954b">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-1">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    有 $N$ 张卡片，每个上面都写着一个大写字母，问随便扔一次这 $N$ 张的卡片就已经按字典序排好的概率，答案用分字为1的形如 $1/x$ 的形式表示。$( 1&amp;lt;N &amp;lt; 100)$&lt;/p>
&lt;h3 id="思路-1">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    这题很显然是道数学排列组合题，我们设每个字母重复出现的次数为 $p[i]$ ，好比字母为$A$的卡片出现了两次，那么就 $p[&amp;lsquo;A&amp;rsquo;]$ 为2。&lt;/p>
&lt;p>​    那么答案就是如下
$$
ans = \frac{N!}{\Pi_{i=&amp;lsquo;A&amp;rsquo;}^{i=&amp;lsquo;Z&amp;rsquo;}(p[i]!)}
$$
​    这题主要难点大概是在高精，因为可能会涉及到 $100!$ 这种丧心病狂的东西，所以就用笨比的方法写了一发python。&lt;del>其实是高级的算法不会用python写，C++乘法的高精忘掉了&lt;/del>。&lt;/p>
&lt;h3 id="代码实现-1">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">n &lt;span style="color:#f92672">=&lt;/span> int(input())
s &lt;span style="color:#f92672">=&lt;/span> input()
s[&lt;span style="color:#ae81ff">0&lt;/span>:n:&lt;span style="color:#ae81ff">1&lt;/span>]
ans &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">1&lt;/span>,n&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>):
ans &lt;span style="color:#f92672">=&lt;/span> ans&lt;span style="color:#f92672">*&lt;/span>i
&lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">0&lt;/span>,n):
count &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> j &lt;span style="color:#f92672">in&lt;/span> range(i,n):
&lt;span style="color:#66d9ef">if&lt;/span> s[i] &lt;span style="color:#f92672">==&lt;/span> s[j]:
count &lt;span style="color:#f92672">=&lt;/span> count &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> count &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>:
ans &lt;span style="color:#f92672">=&lt;/span> ans&lt;span style="color:#f92672">//&lt;/span>count &lt;span style="color:#75715e">#这里本来//写成了/,连WA3发&lt;/span>
print(&lt;span style="color:#e6db74">&amp;#34;1/&amp;#34;&lt;/span>,end&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>)
print(int(ans))
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h1 id="day-2">
Day 2
&lt;a class="heading-link" href="#day-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h1>
&lt;h2 id="a-愤怒的巨巨httpsacnowcodercomacmcontest6955a">
A. &lt;a href="https://ac.nowcoder.com/acm/contest/6955/A">愤怒的巨巨&lt;/a>
&lt;a class="heading-link" href="#a-%e6%84%a4%e6%80%92%e7%9a%84%e5%b7%a8%e5%b7%a8httpsacnowcodercomacmcontest6955a">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-2">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    已知香蕉的次品率为 $p(0\le p\le 1)$ ，如果想要买到好香蕉则买香蕉个数的期望值是多少。如果买不到好香蕉，输出”Sorrry,JuJu!”(忽略双引号)。否则输出期望值的最简分数形式：c/d. $p$ 的最多位数为6。&lt;/p>
&lt;h3 id="思路-2">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    首先理解一下题意，好比次品率 $p$ 为0.5，则期望的个数为2个。如果次品率 $p$ 为 0.25，则可以说平均买四个有一个次品，那么最少需要的买的个数其实是 $3/4$ 。&lt;/p>
&lt;p>​    再者特判一下 $p == 0$ 以及 $p==1$ 的情况，分别输出 &lt;strong>1/1&lt;/strong> 和 &lt;strong>Sorrry,JuJu!&lt;/strong> 。&lt;/p>
&lt;p>​    然后其实可以看一下非次品率 $k = 1-p$ ，然后其实就是一个最大公约数问题了。只需要把 $k$ 转换成分数形式，然后用最大公约数约分一下，再取一个倒数即可。&lt;/p>
&lt;h3 id="代码实现-2">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">char&lt;/span> str[&lt;span style="color:#ae81ff">100&lt;/span>];
&lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> mod &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">bool&lt;/span> flag &lt;span style="color:#f92672">=&lt;/span> false;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">gcd&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a,&lt;span style="color:#66d9ef">int&lt;/span> b)
{
&lt;span style="color:#66d9ef">if&lt;/span>(b&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> a;
&lt;span style="color:#66d9ef">return&lt;/span> gcd(b,a&lt;span style="color:#f92672">%&lt;/span>b);
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%s&amp;#34;&lt;/span>,str);
&lt;span style="color:#66d9ef">int&lt;/span> len &lt;span style="color:#f92672">=&lt;/span> strlen(str);
&lt;span style="color:#66d9ef">if&lt;/span>(str[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>)
{
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;&lt;/span>len;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(str[i] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>) flag &lt;span style="color:#f92672">=&lt;/span> true;
}
&lt;span style="color:#66d9ef">if&lt;/span>(flag &lt;span style="color:#f92672">==&lt;/span> false)
{
printf(&lt;span style="color:#e6db74">&amp;#34;1/1&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
}
&lt;span style="color:#66d9ef">if&lt;/span>(str[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;1&amp;#39;&lt;/span>)
{
printf(&lt;span style="color:#e6db74">&amp;#34;Sorrry,JuJu!&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;&lt;/span>len;i&lt;span style="color:#f92672">++&lt;/span>)
{
k &lt;span style="color:#f92672">=&lt;/span> k&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#f92672">+&lt;/span>str[i]&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>;
mod &lt;span style="color:#f92672">*=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
}
&lt;span style="color:#66d9ef">int&lt;/span> m &lt;span style="color:#f92672">=&lt;/span> mod &lt;span style="color:#f92672">-&lt;/span> k;
&lt;span style="color:#66d9ef">int&lt;/span> p &lt;span style="color:#f92672">=&lt;/span> gcd(m,mod);
printf(&lt;span style="color:#e6db74">&amp;#34;%d/%d&amp;#34;&lt;/span>,mod&lt;span style="color:#f92672">/&lt;/span>p,m&lt;span style="color:#f92672">/&lt;/span>p);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="b-兔子的逆序对httpsacnowcodercomacmcontest6955c">
B. &lt;a href="https://ac.nowcoder.com/acm/contest/6955/C">兔子的逆序对&lt;/a>
&lt;a class="heading-link" href="#b-%e5%85%94%e5%ad%90%e7%9a%84%e9%80%86%e5%ba%8f%e5%af%b9httpsacnowcodercomacmcontest6955c">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-3">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    给定一个区间 $[L,R]$ ，然后给出 $m$ 次翻转操作，通过给出子区间左右端点，反转该区间。每翻转一次，要求给出区间 $[L,R]$ 逆序对的奇偶性，如果是奇数，输出 &lt;strong>dislike&lt;/strong> ，如果是偶数，输出 &lt;strong>like&lt;/strong> 。&lt;/p>
&lt;h3 id="思路-3">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    首先用归并 / 树状数组的方法，求出来区间 $[L,R]$ 的逆序对 $ans$。&lt;/p>
&lt;p>​    然后我们考虑每一次翻转带来的影响。我们考虑一个子区间 $[l,r]$ ，设该区间逆序对为 $x$ ，那么反转后该区间的逆序对为 $C_n^2 -x$ 。翻转区间 $[l,r]$ 导致答案 $ans = ans + C_n^2 -x - x = ans + C_n^2-2x$&lt;/p>
&lt;p>​    因为只需要奇偶性，那么 $2x$ 需要考虑，那么就每次看看 $C_n^2$ 的奇偶性即可。&lt;/p>
&lt;h3 id="代码实现-3">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#75715e">#define lowbit(x) (x)&amp;amp;(-x)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Node&lt;/span>
{
&lt;span style="color:#66d9ef">int&lt;/span> val; &lt;span style="color:#75715e">// value
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> pos; &lt;span style="color:#75715e">//postion
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}node;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">cmp&lt;/span>(node a,node b)
{
&lt;span style="color:#66d9ef">return&lt;/span> a.val&lt;span style="color:#f92672">&amp;lt;&lt;/span>b.val;
}
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1e5&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxm &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2e6&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>;
node num[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> tree[maxm];
&lt;span style="color:#66d9ef">int&lt;/span> n,m;
&lt;span style="color:#66d9ef">int&lt;/span> l,r;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x)
{
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>x;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">+=&lt;/span>lowbit(i))
{
tree[i]&lt;span style="color:#f92672">++&lt;/span>;
}
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">find&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x)
{
&lt;span style="color:#66d9ef">int&lt;/span> sum&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>x;i&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;i&lt;span style="color:#f92672">-=&lt;/span>lowbit(i))
{
sum&lt;span style="color:#f92672">+=&lt;/span>tree[i];
}
&lt;span style="color:#66d9ef">return&lt;/span> sum;
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>num[i].val);
num[i].pos&lt;span style="color:#f92672">=&lt;/span>i;
}
sort(num&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,num&lt;span style="color:#f92672">+&lt;/span>n&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,cmp);
&lt;span style="color:#66d9ef">int&lt;/span> ans &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
ans&lt;span style="color:#f92672">+=&lt;/span>find(num[i].pos);
add(num[i].pos);
}
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>m);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>m;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>l,&lt;span style="color:#f92672">&amp;amp;&lt;/span>r);
&lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> ((r&lt;span style="color:#f92672">-&lt;/span>l&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">*&lt;/span>(r&lt;span style="color:#f92672">-&lt;/span>l))&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span>(k&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(ans&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
{
printf(&lt;span style="color:#e6db74">&amp;#34;dislike&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
ans&lt;span style="color:#f92672">++&lt;/span>;
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
printf(&lt;span style="color:#e6db74">&amp;#34;like&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
ans&lt;span style="color:#f92672">++&lt;/span>;
}
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
&lt;span style="color:#66d9ef">if&lt;/span>(ans&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
{
printf(&lt;span style="color:#e6db74">&amp;#34;like&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
printf(&lt;span style="color:#e6db74">&amp;#34;dislike&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="c-butterflyhttpsacnowcodercomacmcontest6955f">
C. &lt;a href="https://ac.nowcoder.com/acm/contest/6955/F">Butterfly&lt;/a>
&lt;a class="heading-link" href="#c-butterflyhttpsacnowcodercomacmcontest6955f">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-4">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-4">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    这题描述起来有点难，还是直接点链接去看比较好。&lt;/p>
&lt;p>​    大概就是给定一个 由 &lt;strong>X&lt;/strong> 和 &lt;strong>O&lt;/strong> 构成的$n\times m$ 的矩阵，让你找出里面由 &lt;strong>X&lt;/strong> 构成的蝴蝶的最大对角线长度。&lt;/p>
&lt;h3 id="思路-4">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-4">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    这题第一时间让我想到了我 &lt;strong>2020/2/12&lt;/strong> 写的dp练习中的&lt;strong>创意吃鱼法&lt;/strong>。&lt;/p>
&lt;p>​    一开始想要考虑从中心开始考虑，但是需要维护的东西有点多，而且周围的判别不好判。因此可以考虑从&lt;strong>右上/右下/左上/左下&lt;/strong> 这四个位置考虑，我这里是从左下考虑的。设我们要求的答案为 $ans$ 。&lt;/p>
&lt;p>​    考虑维护三个数组，看 &lt;strong>X&lt;/strong> 向上延伸，左上延伸，右上延伸的长度。所以我们依次遍历矩阵中的每一个元素，判定他是否可以作为蝴蝶的左下角，首先取一个向上延伸和右上延伸的最小值 $p$，然后从 $p$ 到 $ans$ 遍历，每次判定一下该答案是否合法，判定的话无非是从右下角判定一下就行，比较简单。如果答案合法，那么更新 $ans$。&lt;/p>
&lt;h3 id="代码实现-4">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-4">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2005&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> lr[maxn][maxn],rr[maxn][maxn],str[maxn][maxn]; &lt;span style="color:#75715e">//分别为按左上、右上，向上延伸
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">char&lt;/span> x;
&lt;span style="color:#66d9ef">int&lt;/span> n,m;
&lt;span style="color:#66d9ef">int&lt;/span> ans;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>m);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>m;j&lt;span style="color:#f92672">++&lt;/span>)
{
cin&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>x;
&lt;span style="color:#66d9ef">if&lt;/span>(x &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;X&amp;#39;&lt;/span>)
{
lr[i][j] &lt;span style="color:#f92672">=&lt;/span> lr[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][j&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
rr[i][j] &lt;span style="color:#f92672">=&lt;/span> rr[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][j&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
str[i][j] &lt;span style="color:#f92672">=&lt;/span> str[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][j] &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
ans &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
}
}
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>m;j&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">int&lt;/span> p &lt;span style="color:#f92672">=&lt;/span> min(str[i][j],rr[i][j]);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> p;k&lt;span style="color:#f92672">&amp;gt;&lt;/span>ans;k&lt;span style="color:#f92672">--&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(k&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(str[i][j&lt;span style="color:#f92672">+&lt;/span>k&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">&amp;gt;=&lt;/span>k &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> lr[i][j&lt;span style="color:#f92672">+&lt;/span>k&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">&amp;gt;=&lt;/span>k) ans &lt;span style="color:#f92672">=&lt;/span> max(ans,k);
}
}
}
}
printf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,ans);
}
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Codeforces#620 (Div.2)</title><link>https://zzsqwq.github.io/posts/30/</link><pubDate>Wed, 19 Feb 2020 01:02:00 +0000</pubDate><guid>https://zzsqwq.github.io/posts/30/</guid><description>&lt;h2 id="a-two-rabbitshttpscodeforcescomcontest1304problema">
A. &lt;a href="https://codeforces.com/contest/1304/problem/A">Two Rabbits&lt;/a>
&lt;a class="heading-link" href="#a-two-rabbitshttpscodeforcescomcontest1304problema">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    两个兔子分别位于 $(x,0)$ 和 $(y,0)$ ，两个人对头蹦，前者往前蹦 $a$ ，后者往前蹦 $b$ ，问两人是否能恰好相遇。&lt;/p>
&lt;h3 id="思路">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    算一下两个人直接得距离 $s$ ，每次两者距离减少 $a+b$ ，看 $s$ 是否能被 $a+b$ 整除，如果可以就能够相遇。&lt;/p>
&lt;h3 id="代码实现">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">int&lt;/span> t;
&lt;span style="color:#66d9ef">int&lt;/span> x,y,a,b;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>x,&lt;span style="color:#f92672">&amp;amp;&lt;/span>y,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a,&lt;span style="color:#f92672">&amp;amp;&lt;/span>b);
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>a&lt;span style="color:#f92672">+&lt;/span>b;
&lt;span style="color:#66d9ef">int&lt;/span> f&lt;span style="color:#f92672">=&lt;/span>y&lt;span style="color:#f92672">-&lt;/span>x;
&lt;span style="color:#66d9ef">if&lt;/span>(f&lt;span style="color:#f92672">%&lt;/span>p&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
{
printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,f&lt;span style="color:#f92672">/&lt;/span>p);
}
&lt;span style="color:#66d9ef">else&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;-1&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;h2 id="b-longest-palindromehttpscodeforcescomcontest1304problemb">
B. &lt;a href="https://codeforces.com/contest/1304/problem/B">Longest Palindrome&lt;/a>
&lt;a class="heading-link" href="#b-longest-palindromehttpscodeforcescomcontest1304problemb">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-1">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    给出 $n$ 段长度为 $m$ 的字符串，从中挑选出一些组成最长的回文字串，输出这个回文子串的长度和内容，如果有多种情况输出一种即可。如果没有符合的，就输出0 。$(1\le n\le 100,1\le m\le 50)$&lt;/p>
&lt;h3 id="思路-1">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    因为这个数据规模非常小，所以 $O(n^2m)$ 也是可以接受的（说实话我不是很会算，大概是个差不多的式子），那么我们可以选择暴力匹配，用每个字符串去匹配后面的，如果是两个互为回文串，那么就把其中任何一个计入到sub字符串中，然后用一个 vis 数组来标记他们两个已经被使用过了，最终一个字符串匹配完后面所有的发现没有合适的，那么就考虑他自己是不是一个回文串，如果是一个回文串，单独标记它是放在中间。最后我们的sub是存放了一半回文串。
​    统计答案的时候，先将sub加到答案ans中，检查一下是否中间有合适的回文串，如果有的话也加到ans里面，最后讲sub逆序一下，加到ans里面。最终输出答案的时候，看一下ans是不是空串，如果是空串，就输出0，否则输出长度和ans。（string是真的好用！！！）&lt;/p>
&lt;h3 id="代码实现-1">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">105&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> n,m;
string ans,sub,mid;
&lt;span style="color:#66d9ef">bool&lt;/span> ifmid;
string str[maxn];
&lt;span style="color:#66d9ef">bool&lt;/span> vis[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>m);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>) cin&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>str[i];
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;j&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(vis[j]) &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;span style="color:#66d9ef">bool&lt;/span> flag&lt;span style="color:#f92672">=&lt;/span>true;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> k&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;k&lt;span style="color:#f92672">&amp;lt;&lt;/span>m;k&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(str[i][k]&lt;span style="color:#f92672">==&lt;/span>str[j][m&lt;span style="color:#f92672">-&lt;/span>k&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>])
{
&lt;span style="color:#66d9ef">continue&lt;/span>;
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
flag&lt;span style="color:#f92672">=&lt;/span>false;
&lt;span style="color:#66d9ef">break&lt;/span>;
}
}
&lt;span style="color:#66d9ef">if&lt;/span>(flag)
{
vis[i]&lt;span style="color:#f92672">=&lt;/span>vis[j]&lt;span style="color:#f92672">=&lt;/span>true;
sub&lt;span style="color:#f92672">+=&lt;/span>str[i];
}
}
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>vis[i])
{
&lt;span style="color:#66d9ef">bool&lt;/span> flag&lt;span style="color:#f92672">=&lt;/span>true;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;&lt;/span>m;j&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(str[i][j]&lt;span style="color:#f92672">!=&lt;/span>str[i][m&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">-&lt;/span>j])
{
flag&lt;span style="color:#f92672">=&lt;/span>false;
&lt;span style="color:#66d9ef">break&lt;/span>;
}
}
&lt;span style="color:#66d9ef">if&lt;/span>(flag)
{
mid&lt;span style="color:#f92672">=&lt;/span>str[i];
ifmid&lt;span style="color:#f92672">=&lt;/span>true;
}
}
}
ans&lt;span style="color:#f92672">+=&lt;/span>sub;
reverse(sub.begin(),sub.end());
&lt;span style="color:#66d9ef">if&lt;/span>(ifmid) ans&lt;span style="color:#f92672">+=&lt;/span>mid;
ans&lt;span style="color:#f92672">+=&lt;/span>sub;
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>ans.empty())
{
cout&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>ans.length()&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>endl&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>ans;
}
&lt;span style="color:#66d9ef">else&lt;/span> cout&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;h2 id="c-air-conditionerhttpscodeforcescomcontest1304problemc">
C. &lt;a href="https://codeforces.com/contest/1304/problem/C">Air Conditioner&lt;/a>
&lt;a class="heading-link" href="#c-air-conditionerhttpscodeforcescomcontest1304problemc">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-2">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    餐厅老板有一个空调，餐厅初始温度为 $m$ ，会陆续来 $n$ 个顾客。餐厅老板每分钟可以控制空调的温度+1，-1，或者是不变。这 $n$ 个顾客会按来的时间顺序给出，每个人有一个感到舒适的温度范围，如果空调的温度在这个范围里面，那么顾客就会满意。问餐厅老板是否可以达到让每个人都满意。&lt;/p>
&lt;h3 id="思路-2">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    首先我们先思考从餐厅开始到第一个客人来临的时候，假设第一个人来临的时间是 $t$ ，舒适区间为 $[l,r]$，那么我们可以很容易发现只要 $[l,r]$ 与 $[m-t,m+t]$ 有交集，那么就是可以满足第一个客人条件。如果第二个和第一人的时间差为 $\Delta t$ ，那么这个时候要计算可达到的舒适区间就是在上次交集的区间上左右变化 $\Delta t$ ，为什么是交集呢。我一开始想错了。。一直写成并集，然后一直调不出来。但实际上不是这样的，我们可以理解为只有交集那部分才是符合上个顾客要求的，如果超出那个范围，就不能够满足上个顾客要求。所以挨个顾客扫一遍就行了。&lt;/p>
&lt;h3 id="代码实现-2">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">int&lt;/span> q,n,m;
&lt;span style="color:#66d9ef">int&lt;/span> last,l,h,t;
&lt;span style="color:#66d9ef">int&lt;/span> nowl,nowr,delt;
&lt;span style="color:#66d9ef">int&lt;/span> lef,righ;
&lt;span style="color:#66d9ef">bool&lt;/span> flag;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>q);
&lt;span style="color:#66d9ef">while&lt;/span>(q&lt;span style="color:#f92672">--&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>m);
lef&lt;span style="color:#f92672">=&lt;/span>righ&lt;span style="color:#f92672">=&lt;/span>m;
last&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
flag&lt;span style="color:#f92672">=&lt;/span>true;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t,&lt;span style="color:#f92672">&amp;amp;&lt;/span>l,&lt;span style="color:#f92672">&amp;amp;&lt;/span>h);
delt&lt;span style="color:#f92672">=&lt;/span>t&lt;span style="color:#f92672">-&lt;/span>last;
nowl&lt;span style="color:#f92672">=&lt;/span>lef&lt;span style="color:#f92672">-&lt;/span>delt;
nowr&lt;span style="color:#f92672">=&lt;/span>righ&lt;span style="color:#f92672">+&lt;/span>delt;
last&lt;span style="color:#f92672">=&lt;/span>t;
&lt;span style="color:#66d9ef">if&lt;/span>(nowl&lt;span style="color:#f92672">&amp;gt;&lt;/span>h&lt;span style="color:#f92672">||&lt;/span>nowr&lt;span style="color:#f92672">&amp;lt;&lt;/span>l) flag&lt;span style="color:#f92672">=&lt;/span>false;
&lt;span style="color:#66d9ef">else&lt;/span>
{
lef&lt;span style="color:#f92672">=&lt;/span>max(nowl,l);
righ&lt;span style="color:#f92672">=&lt;/span>min(nowr,h);
}
}
&lt;span style="color:#66d9ef">if&lt;/span>(flag)
{
printf(&lt;span style="color:#e6db74">&amp;#34;YES&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">else&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;NO&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
}
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>杂题训练</title><link>https://zzsqwq.github.io/posts/27/</link><pubDate>Sat, 15 Feb 2020 00:52:00 +0000</pubDate><guid>https://zzsqwq.github.io/posts/27/</guid><description>&lt;h2 id="a-配对httpsacnowcodercomacmcontest3007a">
A. &lt;a href="https://ac.nowcoder.com/acm/contest/3007/A">配对&lt;/a>
&lt;a class="heading-link" href="#a-%e9%85%8d%e5%af%b9httpsacnowcodercomacmcontest3007a">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    给定含有 $n$ 个正整数的集合 $A$ 和 $B$ ，你需要建立他们之间的一一映射。将配对的两个数相加可以得到 $n$ 个和，问第 $k$ 大的和最大为多少。&lt;/p>
&lt;h3 id="思路">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    首先我们可以确定，组成前 $k$ 个最大的和一定用的是两个序列里面前 $k$ 大的数字。那么我们只需要知道如何配对能使第 $k$ 大的和最大。我们把问题简化一下如果 $A_1 &amp;lt; A_2$ ，$B_1 &amp;lt; B_2$ ，那么如果想要第二个和最大，肯定是需要 $A_1$ 和 $B_2$ 匹配，$A_2$ 和 $B_1$ 匹配，然后两个选一个最小的。所以这个问题我们类推一下，就是将 $A$ 和 $B$ 序列进行排序，然后取两个里面前 $k$ 个数，$A$ 中大的依次匹配 $B$ 中小的。然后在这 $k$ 个和中取一个最小值即可。&lt;/p>
&lt;h3 id="代码实现">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1e5&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> a[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> b[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> n,k,ans&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1e9&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">7&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">cmp&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a,&lt;span style="color:#66d9ef">int&lt;/span> b)
{
&lt;span style="color:#66d9ef">return&lt;/span> a&lt;span style="color:#f92672">&amp;gt;&lt;/span>b;
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>k);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i]);
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>b[i]);
}
sort(a&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,a&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>n,cmp);
sort(b&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,b&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>n,cmp);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>k;i&lt;span style="color:#f92672">++&lt;/span>)
{
ans&lt;span style="color:#f92672">=&lt;/span>min(ans,a[i]&lt;span style="color:#f92672">+&lt;/span>b[k&lt;span style="color:#f92672">-&lt;/span>i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]);
}
printf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,ans);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;h2 id="b-十字阵列httpsacnowcodercomacmcontest3007f">
B. &lt;a href="https://ac.nowcoder.com/acm/contest/3007/F">十字阵列&lt;/a>
&lt;a class="heading-link" href="#b-%e5%8d%81%e5%ad%97%e9%98%b5%e5%88%97httpsacnowcodercomacmcontest3007f">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-1">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    给定一个 $n\times m$ 的网格，每一个交点都一个敌人。你可以使用共 $h$ 次魔法，第 $i$ 次魔法能对第 $x_i$ 行和第 $y_i$ 列的所有敌人造成 $w_i$ 点伤害，交界点的伤害只计算一次。。如果施放完所有所有魔法后，如果一个点 $(i,j)$ 共受到 $z_i$ 点伤害，问 $\sum{z_i(i+j)}$ 为多少。&lt;/p>
&lt;h3 id="思路-1">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    无脑的计数题QAQ..真的是水题啊，我们只需要给每次魔法施放的 $w_i$ 乘上一个 $(i,j)$ 即可，但是因为是一行一列都会变化，那么其实我们可以优化一下，先把一行一列的 $\sum(i+j)$ 给求出来，然后施法的时候直接乘上这个常数就可以了。（这个题还有个很神奇的地方就是，我明明算的不会爆int然后开的int，然后就错了，后来一直找问题没找出来，后来全改成long long就AC了，太奇怪了。。）&lt;/p>
&lt;h3 id="代码实现-1">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2005&lt;/span>;
&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> ll;
&lt;span style="color:#66d9ef">int&lt;/span> mod &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1e9&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">7&lt;/span>;
ll row[maxn];
ll col[maxn];
ll x,y,z;
ll n,m,h;
ll ans,now;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%lld%lld%lld&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>m,&lt;span style="color:#f92672">&amp;amp;&lt;/span>h);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
row[i]&lt;span style="color:#f92672">=&lt;/span>(m&lt;span style="color:#f92672">*&lt;/span>i)&lt;span style="color:#f92672">%&lt;/span>mod&lt;span style="color:#f92672">+&lt;/span>(m)&lt;span style="color:#f92672">*&lt;/span>(m&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
row[i]&lt;span style="color:#f92672">%=&lt;/span>mod;
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>m;j&lt;span style="color:#f92672">++&lt;/span>)
{
col[j]&lt;span style="color:#f92672">=&lt;/span>(n&lt;span style="color:#f92672">*&lt;/span>j)&lt;span style="color:#f92672">%&lt;/span>mod&lt;span style="color:#f92672">+&lt;/span>(n)&lt;span style="color:#f92672">*&lt;/span>(n&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
col[j]&lt;span style="color:#f92672">%=&lt;/span>mod;
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>h;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%lld%lld%lld&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>x,&lt;span style="color:#f92672">&amp;amp;&lt;/span>y,&lt;span style="color:#f92672">&amp;amp;&lt;/span>z);
now&lt;span style="color:#f92672">=&lt;/span>((row[x]&lt;span style="color:#f92672">+&lt;/span>col[y]&lt;span style="color:#f92672">-&lt;/span>(x&lt;span style="color:#f92672">+&lt;/span>y))&lt;span style="color:#f92672">%&lt;/span>mod)&lt;span style="color:#f92672">*&lt;/span>(z&lt;span style="color:#f92672">%&lt;/span>mod);
now&lt;span style="color:#f92672">%=&lt;/span>mod;
ans&lt;span style="color:#f92672">+=&lt;/span>now;
ans&lt;span style="color:#f92672">%=&lt;/span>mod;
}
printf(&lt;span style="color:#e6db74">&amp;#34;%lld&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,ans);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;h2 id="c-垃圾陷阱httpswwwluogucomcnproblemp1156">
C. &lt;a href="https://www.luogu.com.cn/problem/P1156">垃圾陷阱&lt;/a>
&lt;a class="heading-link" href="#c-%e5%9e%83%e5%9c%be%e9%99%b7%e9%98%b1httpswwwluogucomcnproblemp1156">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-2">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    奶牛卡门想要从垃圾井底上到地面，对于一个垃圾它可以吃掉，或者是堆起来。初始卡门有10个小时的能量，吃掉一个垃圾会给他提供 $f_i$ 个小时的能量，叠起来一个垃圾会获得 $h_i$ 点高度，当垃圾总高度超过井的深度 $D$ 的时候，卡门就能上到地面。一个垃圾当 $t_i$ 小时时会到达井底。给出所有垃圾的状态，问奶牛能否到达地面。&lt;/p>
&lt;h3 id="思路-2">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​ &lt;del>   这个题面被我翻译的屎一样，QAQ，如果看不懂还是去看原题叭。。&lt;/del>
​    这是一个类似于背包的题，对于一个垃圾，我们有两种选择，一个是吃掉它，一个是把他堆起来。。这个状态其实我没找好，看了题解发现可以设 $f[i][j]$ 来表示当用了前 $i$ 个垃圾时，当高度为 $j$ 的时候的最大的体力值（体力值就是还能继续活动多长时间）。我们用结构体数组 $a$ 来表示垃圾，写出如下转移方程。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果选择把这个垃圾吃掉，那么 $f[i][j]=max(f[i-1][j]+a[i].f,f[i][j])$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果选择把这个垃圾搭起来，那么$f[i][j+a[i].h]=max(f[i-1][j+a[i].h],f[i-1][j])$&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>​    我们发现边界就是 $f[0][0]=10$ ，也就是用了0个垃圾，高度为0的时候体力值为10。&lt;/p>
&lt;p>​    注意一个地方我们如果到达了地面，就直接输出时间，然后退出程序即可，如果没有的话，我们可以选择遍历每一个垃圾下的 $0$ 高度，也就是说所有垃圾都不叠是最长的寿命，所以输出一个其中的最大值即可。&lt;/p>
&lt;h3 id="代码实现-2">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">105&lt;/span>;
&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">node&lt;/span>
{
&lt;span style="color:#66d9ef">int&lt;/span> t,f,h;
}a[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">cmp&lt;/span>(node a,node b)
{
&lt;span style="color:#66d9ef">return&lt;/span> a.t&lt;span style="color:#f92672">&amp;lt;&lt;/span>b.t;
}
&lt;span style="color:#66d9ef">int&lt;/span> d,g;
&lt;span style="color:#66d9ef">int&lt;/span> dp[maxn][maxn]; &lt;span style="color:#75715e">//dp[i][j] 用i个垃圾，当高度为j时所具备的最高生命值
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
freopen(&lt;span style="color:#e6db74">&amp;#34;test.in&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;r&amp;#34;&lt;/span>,stdin);
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>d,&lt;span style="color:#f92672">&amp;amp;&lt;/span>g);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>g;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i].t,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i].f,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i].h);
}
sort(a&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,a&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>g,cmp);
memset(dp,&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#66d9ef">sizeof&lt;/span>(dp));
dp[&lt;span style="color:#ae81ff">0&lt;/span>][&lt;span style="color:#ae81ff">0&lt;/span>]&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>g;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>d;j&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(dp[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][j]&lt;span style="color:#f92672">&amp;gt;=&lt;/span>a[i].t)
{
&lt;span style="color:#66d9ef">if&lt;/span>(j&lt;span style="color:#f92672">+&lt;/span>a[i].h&lt;span style="color:#f92672">&amp;gt;=&lt;/span>d)
{
printf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,a[i].t);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
dp[i][j]&lt;span style="color:#f92672">=&lt;/span>max(dp[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][j]&lt;span style="color:#f92672">+&lt;/span>a[i].f,dp[i][j]);
dp[i][j&lt;span style="color:#f92672">+&lt;/span>a[i].h]&lt;span style="color:#f92672">=&lt;/span>max(dp[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][j&lt;span style="color:#f92672">+&lt;/span>a[i].h],dp[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][j]);
}
}
}
&lt;span style="color:#66d9ef">int&lt;/span> ans&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>g;i&lt;span style="color:#f92672">++&lt;/span>) ans&lt;span style="color:#f92672">=&lt;/span>max(ans,dp[i][&lt;span style="color:#ae81ff">0&lt;/span>]);
printf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,ans);
}
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Codeforces#619 (Div.2)</title><link>https://zzsqwq.github.io/posts/26/</link><pubDate>Fri, 14 Feb 2020 00:51:00 +0000</pubDate><guid>https://zzsqwq.github.io/posts/26/</guid><description>&lt;h2 id="a-three-stringshttpscodeforcescomcontest1301problema">
A. &lt;a href="https://codeforces.com/contest/1301/problem/A">Three Strings&lt;/a>
&lt;a class="heading-link" href="#a-three-stringshttpscodeforcescomcontest1301problema">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    给定三个长度为 $n$ 的字符串 $a$ , $b$ , $c$ ，遍历每个 $c$ 中每个字符 $c_i$，可以将其替换成 $a_i$ 或者 $b_i$ ，必须操作其中一个，问能否通过此操作使得字符串 $a$ , $b$ 相同。&lt;/p>
&lt;h3 id="思路">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    仔细思考一下，如果要使得最终两个字符串相同的话，必须字符串 $c$ 中出现的字符，在 $a$ 或者 $b$ 字符串出现过，如果每个位置都出现过，那么就是可以的，否则不行。&lt;/p>
&lt;h3 id="代码实现">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">105&lt;/span>;
&lt;span style="color:#66d9ef">char&lt;/span> a[maxn],b[maxn],c[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> t;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%s&amp;#34;&lt;/span>,a);
scanf(&lt;span style="color:#e6db74">&amp;#34;%s&amp;#34;&lt;/span>,b);
scanf(&lt;span style="color:#e6db74">&amp;#34;%s&amp;#34;&lt;/span>,c);
&lt;span style="color:#66d9ef">int&lt;/span> len&lt;span style="color:#f92672">=&lt;/span>strlen(c);
&lt;span style="color:#66d9ef">bool&lt;/span> flag&lt;span style="color:#f92672">=&lt;/span>true;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;&lt;/span>len;i&lt;span style="color:#f92672">++&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span>(c[i]&lt;span style="color:#f92672">!=&lt;/span>a[i]&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>c[i]&lt;span style="color:#f92672">!=&lt;/span>b[i])
{
flag&lt;span style="color:#f92672">=&lt;/span>false;
}
&lt;span style="color:#66d9ef">if&lt;/span>(flag)
{
printf(&lt;span style="color:#e6db74">&amp;#34;YES&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">else&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;NO&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;h2 id="b-motaracks-birthdayhttpscodeforcescomcontest1301problemb">
B. &lt;a href="https://codeforces.com/contest/1301/problem/B">Motarack&amp;rsquo;s Birthday&lt;/a>
&lt;a class="heading-link" href="#b-motaracks-birthdayhttpscodeforcescomcontest1301problemb">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-1">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    给定一个含有 $n$ 个整数的序列 $a$ ，其中有一些数丢失，问将丢失的数赋值为多少才能使得相邻两数之差的绝对值的最大值的最小。&lt;/p>
&lt;h3 id="思路-1">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    我们想一下首先不缺失的数相邻两数之差是一定，无论赋值前后都不影响。而如果两个相邻的数都缺失的话，那么他们之间差的绝对值一定是0，也不用去看。这样的话我们就看一下，不缺失和缺失两数之间差的绝对值如何能够最小。因为最终所有的缺失的数都是赋值为同一个数，所以我们考虑一下发现需要考虑一下 缺失和不缺失的数相邻的时候，不缺失的那个数的最大值和最小值，我们只需要取他们的和的平均，那么绝对值就可以最小了。所以最终我们就把缺失的值赋为两数均值，然后求一遍相邻数之差绝对值的最大值就好了。（好像这道题难点不是思路，而是实现起来有很多边界等乱七八糟的要自习考虑一下。）&lt;/p>
&lt;h3 id="代码实现-1">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">100005&lt;/span>;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> inf&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1000000000&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> n,t;
&lt;span style="color:#66d9ef">int&lt;/span> a[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> minn,maxx,ans,anss;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
minn&lt;span style="color:#f92672">=&lt;/span>inf,maxx&lt;span style="color:#f92672">=-&lt;/span>inf,anss&lt;span style="color:#f92672">=-&lt;/span>inf;
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i]);
&lt;span style="color:#66d9ef">if&lt;/span>(i&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>a[i]&lt;span style="color:#f92672">==-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>a[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">!=-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
{
minn&lt;span style="color:#f92672">=&lt;/span>min(minn,a[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]);
maxx&lt;span style="color:#f92672">=&lt;/span>max(maxx,a[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]);
}
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(i&lt;span style="color:#f92672">&amp;lt;&lt;/span>n&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>a[i]&lt;span style="color:#f92672">==-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>a[i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">!=-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
{
minn&lt;span style="color:#f92672">=&lt;/span>min(minn,a[i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]);
maxx&lt;span style="color:#f92672">=&lt;/span>max(maxx,a[i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]);
}
}
ans&lt;span style="color:#f92672">=&lt;/span>(minn&lt;span style="color:#f92672">+&lt;/span>maxx)&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(a[i]&lt;span style="color:#f92672">==-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) a[i]&lt;span style="color:#f92672">=&lt;/span>ans;
&lt;span style="color:#66d9ef">if&lt;/span>(i&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) anss&lt;span style="color:#f92672">=&lt;/span>max(anss,abs(a[i]&lt;span style="color:#f92672">-&lt;/span>a[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]));
}
printf(&lt;span style="color:#e6db74">&amp;#34;%d %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,anss,ans);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;h2 id="c-ayoubs-functionhttpscodeforcescomcontest1301problemc">
C. &lt;a href="https://codeforces.com/contest/1301/problem/C">Ayoub&amp;rsquo;s function&lt;/a>
&lt;a class="heading-link" href="#c-ayoubs-functionhttpscodeforcescomcontest1301problemc">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-2">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    给定一个01字符串 $s$ ，其中含有 $m$ 个1，用 $f(s)$ 来表示字符串 $s$ 的有多少个字串其中含有1，求出符合条件的字符串 $s$ 中， $f(s)$ 的最大值是多少。&lt;/p>
&lt;h3 id="思路-2">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    这题正着想不太好想，含有1的子串可以有很多种情况，但是正难则反，我们可以求出不含1的字串有多少情况，也就是全0的字串有多少种情况，然后用所有情况减去这个就行。
​    首先可以发现字符串 $s$ 一共有 $\binom{n}{2}+n$ 种连续子串，那么如果一些0是连续的，那么好比有连续 $l$ 个0的话，我们可以发现他是有 $\binom{l}{2}+l$ 种情况的。这个字符串一共是含有 $n-m$ 个0的，现在我们思考一下如何摆放这 $(n-m)$ 个0，才能使得 $f(s)$ 最大。那么如果 $f(s)$ 要尽量大，也就是说全0对应的情况就要尽可能的少，所以我们需要将这 $n-m$ 尽可能的均分成 $m+1$ 份，类似于排列组合的插空法，将他们插到其中，但是我们发现有很大的可能是不能均分的，也就是说可能会有余数，那么我们就把余数均匀的分给前面余数个空，这样其实每个多贡献了 $(n-m)/(m+1) +1 $ 个。所以答案也就不难写出来了。不过不要忘了开long long。&lt;/p>
&lt;h3 id="代码实现-2">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> ll;
ll n,m;
ll t;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%lld&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%lld%lld&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>m);
ll sum&lt;span style="color:#f92672">=&lt;/span>n&lt;span style="color:#f92672">*&lt;/span>(n&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
ll p&lt;span style="color:#f92672">=&lt;/span>n&lt;span style="color:#f92672">-&lt;/span>m;
ll mod&lt;span style="color:#f92672">=&lt;/span>p&lt;span style="color:#f92672">%&lt;/span>(m&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
ll k&lt;span style="color:#f92672">=&lt;/span>p&lt;span style="color:#f92672">/&lt;/span>(m&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
printf(&lt;span style="color:#e6db74">&amp;#34;%lld&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,sum&lt;span style="color:#f92672">-&lt;/span>(m&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">*&lt;/span>k&lt;span style="color:#f92672">*&lt;/span>(k&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">-&lt;/span>(k&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">*&lt;/span>mod);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>日常水题</title><link>https://zzsqwq.github.io/posts/25/</link><pubDate>Thu, 13 Feb 2020 00:47:00 +0000</pubDate><guid>https://zzsqwq.github.io/posts/25/</guid><description>&lt;h2 id="前言">
前言
&lt;a class="heading-link" href="#%e5%89%8d%e8%a8%80">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;p>​    今天又是颓废的一天，被大佬拉去跟他一起做牛客网的题，QAQ&amp;hellip;那我会点啥嘛，就只能替大佬写两道水题了···&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="a-牛牛战队的比赛地httpsacnowcodercomacmcontest3006">
A. &lt;a href="https://ac.nowcoder.com/acm/contest/3006">牛牛战队的比赛地&lt;/a>
&lt;a class="heading-link" href="#a-%e7%89%9b%e7%89%9b%e6%88%98%e9%98%9f%e7%9a%84%e6%af%94%e8%b5%9b%e5%9c%b0httpsacnowcodercomacmcontest3006">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    由于牛牛战队经常要外出比赛，因此在全国各地建立了很多训练基地，每一个基地都有一个坐标 $(x,y)$ 。
​    这周末，牛牛队又要出去比赛了，各个比赛的赛点都在 $x$ 轴上。牛牛战队为了方便比赛，想找一个到达训练基地最大距离最小的地方作为比赛地。请你求出选择的比赛地距离各训练基地最大距离的最小值。&lt;/p>
&lt;h3 id="思路">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    这个题首先一看到这种什么最大的最小，第一直觉就是二分。首先我们想一下应该二分什么，肯定先想的是枚举 $x$ 轴上的点，但是这样就会有个问题，二分要用的话必须是单调的，那么我们不能够确定越往右或者越往左，他们的这个值是单调的。因此我们可以用三分，一直向单峰逼近，最终寻找到那个极值点。（说实话这是我第一次接触到三分法，我太菜了。）&lt;/p>
&lt;h3 id="代码实现">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">100005&lt;/span>;
&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">node&lt;/span>
{
&lt;span style="color:#66d9ef">int&lt;/span> x,y;
}p[maxn]; &lt;span style="color:#75715e">//point
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> n;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> eps&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1e-6&lt;/span>;
&lt;span style="color:#66d9ef">double&lt;/span> lmid,rmid,lans,rans;
&lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">check&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span> x)
{
&lt;span style="color:#66d9ef">double&lt;/span> ans&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">double&lt;/span> dis&lt;span style="color:#f92672">=&lt;/span>(p[i].x&lt;span style="color:#f92672">-&lt;/span>x)&lt;span style="color:#f92672">*&lt;/span>(p[i].x&lt;span style="color:#f92672">-&lt;/span>x)&lt;span style="color:#f92672">+&lt;/span>p[i].y&lt;span style="color:#f92672">*&lt;/span>p[i].y;
ans&lt;span style="color:#f92672">=&lt;/span>max(ans,dis);
}
&lt;span style="color:#66d9ef">return&lt;/span> ans;
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>p[i].x,&lt;span style="color:#f92672">&amp;amp;&lt;/span>p[i].y);
}
&lt;span style="color:#66d9ef">double&lt;/span> l&lt;span style="color:#f92672">=-&lt;/span>&lt;span style="color:#ae81ff">10000&lt;/span>,r&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">10000&lt;/span>;
&lt;span style="color:#66d9ef">double&lt;/span> ans&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">9999999999&lt;/span>;
&lt;span style="color:#66d9ef">while&lt;/span>(r&lt;span style="color:#f92672">-&lt;/span>l&lt;span style="color:#f92672">&amp;gt;=&lt;/span>eps)
{
lmid&lt;span style="color:#f92672">=&lt;/span>(r&lt;span style="color:#f92672">+&lt;/span>l)&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
rmid&lt;span style="color:#f92672">=&lt;/span>(r&lt;span style="color:#f92672">+&lt;/span>lmid)&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
lans&lt;span style="color:#f92672">=&lt;/span>check(lmid);
rans&lt;span style="color:#f92672">=&lt;/span>check(rmid);
&lt;span style="color:#66d9ef">if&lt;/span>(lans&lt;span style="color:#f92672">&amp;lt;&lt;/span>rans)
{
ans&lt;span style="color:#f92672">=&lt;/span>min(ans,lans);
r&lt;span style="color:#f92672">=&lt;/span>rmid;
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
ans&lt;span style="color:#f92672">=&lt;/span>min(ans,rans);
l&lt;span style="color:#f92672">=&lt;/span>lmid;
}
}
printf(&lt;span style="color:#e6db74">&amp;#34;%lf&amp;#34;&lt;/span>,sqrt(ans));
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;h2 id="b-牛牛与牛妹的约会httpsacnowcodercomacmcontest3006d">
B. &lt;a href="https://ac.nowcoder.com/acm/contest/3006/D">牛牛与牛妹的约会&lt;/a>
&lt;a class="heading-link" href="#b-%e7%89%9b%e7%89%9b%e4%b8%8e%e7%89%9b%e5%a6%b9%e7%9a%84%e7%ba%a6%e4%bc%9ahttpsacnowcodercomacmcontest3006d">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-1">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    你想从 $(a,0)$ 点到 $(b,0)$ 点，你可以除了可以以 $1m/s$ 的速度奔跑，还可以用1秒的时间来引导闪现，这将使你从 $(x,0)$ 点闪现到 $(\sqrt[3]{x},0)$ 点，问最少需要多长时间到达 $(b,0)$ 点。$(Ps:a,b \in[-10^6,10^6])$&lt;/p>
&lt;h3 id="思路-1">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    一道贪心的题目，当闪现所能贡献的距离大于 $1m$ ，那么我就选择用闪现，不然就直接奔跑。那么我们可以用距离的变化来体现闪现贡献的距离，一直用闪现到不能用之后，就直接加上最后剩下的距离即可。注意pow这个函数有点坑？如果底数是负数并且指数不是整数的话好像会返回很奇怪的值···（跟大佬调了好长时间都卡在这了）&lt;/p>
&lt;h3 id="代码实现-1">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">int&lt;/span> t,x,y;
&lt;span style="color:#66d9ef">double&lt;/span> ans,a,b;
&lt;span style="color:#66d9ef">double&lt;/span> dis,cdis;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>x,&lt;span style="color:#f92672">&amp;amp;&lt;/span>y);
a &lt;span style="color:#f92672">=&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span>)x;
b&lt;span style="color:#f92672">=&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span>)y;
dis &lt;span style="color:#f92672">=&lt;/span> abs(a&lt;span style="color:#f92672">-&lt;/span>b);
&lt;span style="color:#66d9ef">if&lt;/span>(a&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
{
cdis&lt;span style="color:#f92672">=&lt;/span>abs(&lt;span style="color:#f92672">-&lt;/span>pow(&lt;span style="color:#f92672">-&lt;/span>a,&lt;span style="color:#ae81ff">1.0&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">3.0&lt;/span>)&lt;span style="color:#f92672">-&lt;/span>b);
}
&lt;span style="color:#66d9ef">else&lt;/span> cdis &lt;span style="color:#f92672">=&lt;/span> abs(pow(a,&lt;span style="color:#ae81ff">1.0&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">3.0&lt;/span>)&lt;span style="color:#f92672">-&lt;/span>b);
ans &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">while&lt;/span>(dis&lt;span style="color:#f92672">-&lt;/span>cdis&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#ae81ff">1.0&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(a&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
{
a&lt;span style="color:#f92672">=-&lt;/span>pow(&lt;span style="color:#f92672">-&lt;/span>a,&lt;span style="color:#ae81ff">1.0&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">3.0&lt;/span>);
}
&lt;span style="color:#66d9ef">else&lt;/span> a&lt;span style="color:#f92672">=&lt;/span>pow(a,&lt;span style="color:#ae81ff">1.0&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">3.0&lt;/span>);
ans&lt;span style="color:#f92672">+=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
dis &lt;span style="color:#f92672">=&lt;/span> cdis;
&lt;span style="color:#66d9ef">if&lt;/span>(a&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
{
cdis &lt;span style="color:#f92672">=&lt;/span> abs(&lt;span style="color:#f92672">-&lt;/span>pow(&lt;span style="color:#f92672">-&lt;/span>a,&lt;span style="color:#ae81ff">1.0&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">3.0&lt;/span>)&lt;span style="color:#f92672">-&lt;/span>b);
}
&lt;span style="color:#66d9ef">else&lt;/span> cdis &lt;span style="color:#f92672">=&lt;/span> abs(pow(a,&lt;span style="color:#ae81ff">1.0&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">3.0&lt;/span>)&lt;span style="color:#f92672">-&lt;/span>b);
}
ans&lt;span style="color:#f92672">+=&lt;/span>dis;
printf(&lt;span style="color:#e6db74">&amp;#34;%.9lf&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,ans);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;h2 id="c-碎碎念httpsacnowcodercomacmcontest3006f">
C. &lt;a href="https://ac.nowcoder.com/acm/contest/3006/F">碎碎念&lt;/a>
&lt;a class="heading-link" href="#c-%e7%a2%8e%e7%a2%8e%e5%bf%b5httpsacnowcodercomacmcontest3006f">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-2">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    大佬豪和弱鸡战合作做题，如果大佬豪AC掉题目，那么弱鸡战会说 “宁好强啊！”，如果大佬豪WA掉了题目，那么弱鸡战会嘲讽大佬豪 $k$ 句 “宁好弱啊！” 。我们规定大佬豪提交只有AC和WA两种状态。因为大佬豪非常的强，如果一道题他WA掉了一发，那么他的下一发一定会AC。如果已知最终弱鸡战嘲讽了 $x$ 句，那么很明显可以对应很多的提交序列。现在想问你如果弱鸡战嘲讽数在 $[l,r]$ 这个区间，一共会有多少种提交序列。答案对 $1e9+7$ 取模。&lt;/p>
&lt;h3 id="思路-2">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    首先原始题面不是这样，我把名字改了一下，QAQ&amp;hellip;
​    QAQ刷了这么多天的dp好像终于有点作用了，我终于看出来这是一道dp题了，还找对了他们的状态，不过转移方程却写错了。那么首先我们可以用 $f[i]$ 来表示，如果说了 $i$ 句话，那么一共有多少种可能的序列，但是这样的话我们发现没法确保上文上的如果WA掉了，下一发一定是AC。
​    所以我们可以考虑加一维状态来表示是通过哪种提交状态到达第 $i$ 句话的，也就是写成 $dp[0/1][i]$ 这个状态，$dp[0][i]$ 代表是从 $i-1$ 句话直接AC转移过来的，$dp[1][i]$ 是从 $i-k$ 句话通过WA转移过来的。所以这样的话转移方程就可以写出来了。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>$dp[0][i] = dp[0][i-1]+dp[1][i-1]$ （可以从WA和AC转移过来）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$dp[1][i]=dp[0][i-k]$ （只能从第 $i-k$ 状态是AC的时候转移，不能连续两次WA）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>​    因为最终是一个区间查询，那么我们可以用前缀和来优化。&lt;/p>
&lt;h3 id="代码实现-2">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">100005&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> k,q;
&lt;span style="color:#66d9ef">int&lt;/span> l,r;
&lt;span style="color:#66d9ef">int&lt;/span> mod &lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1e9&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">7&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> dp[&lt;span style="color:#ae81ff">2&lt;/span>][maxn];
&lt;span style="color:#66d9ef">int&lt;/span> sum[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> ans[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>k,&lt;span style="color:#f92672">&amp;amp;&lt;/span>q);
dp[&lt;span style="color:#ae81ff">0&lt;/span>][&lt;span style="color:#ae81ff">0&lt;/span>]&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>&lt;span style="color:#ae81ff">100000&lt;/span>;i&lt;span style="color:#f92672">++&lt;/span>)
{
dp[&lt;span style="color:#ae81ff">0&lt;/span>][i]&lt;span style="color:#f92672">=&lt;/span>dp[&lt;span style="color:#ae81ff">0&lt;/span>][i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">+&lt;/span>dp[&lt;span style="color:#ae81ff">1&lt;/span>][i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>];
dp[&lt;span style="color:#ae81ff">0&lt;/span>][i]&lt;span style="color:#f92672">%=&lt;/span>mod;
&lt;span style="color:#66d9ef">if&lt;/span>(i&lt;span style="color:#f92672">&amp;gt;=&lt;/span>k)
{
dp[&lt;span style="color:#ae81ff">1&lt;/span>][i]&lt;span style="color:#f92672">=&lt;/span>dp[&lt;span style="color:#ae81ff">0&lt;/span>][i&lt;span style="color:#f92672">-&lt;/span>k];
dp[&lt;span style="color:#ae81ff">1&lt;/span>][i]&lt;span style="color:#f92672">%=&lt;/span>mod;
}
ans[i]&lt;span style="color:#f92672">=&lt;/span>dp[&lt;span style="color:#ae81ff">0&lt;/span>][i]&lt;span style="color:#f92672">+&lt;/span>dp[&lt;span style="color:#ae81ff">1&lt;/span>][i];
ans[i]&lt;span style="color:#f92672">%=&lt;/span>mod;
sum[i]&lt;span style="color:#f92672">=&lt;/span>sum[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">+&lt;/span>ans[i];
sum[i]&lt;span style="color:#f92672">%=&lt;/span>mod;
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>q;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>l,&lt;span style="color:#f92672">&amp;amp;&lt;/span>r);
printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,(sum[r]&lt;span style="color:#f92672">-&lt;/span>sum[l&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">+&lt;/span>mod)&lt;span style="color:#f92672">%&lt;/span>mod);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;h2 id="d-牛牛战队的秀场httpsacnowcodercomacmcontest3006j">
D. &lt;a href="https://ac.nowcoder.com/acm/contest/3006/J">牛牛战队的秀场&lt;/a>
&lt;a class="heading-link" href="#d-%e7%89%9b%e7%89%9b%e6%88%98%e9%98%9f%e7%9a%84%e7%a7%80%e5%9c%bahttpsacnowcodercomacmcontest3006j">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-3">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    在半径为 $r$ 的圆内有一个正接 $n$ 边形，随便选取一个顶点编号为 $1$ ，顺时针编号为 $2\sim n$ ，规定只能沿多边形边走，问从顶点 $i$ 到顶点 $j$ 最短路径为多少。&lt;/p>
&lt;h3 id="思路-3">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    很显然只有两条路可以走，我们只需要算出正多边形的每条边的边长，然后比较两条路径的大小，哪一个短就走哪一个就行，不过如果用了&lt;code>cos()&lt;/code> 函数记得特判一下 $n=4$ 的情况，不然会发生错误。&lt;/p>
&lt;h3 id="代码实现-3">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">int&lt;/span> n,ri;
&lt;span style="color:#66d9ef">double&lt;/span> r;
&lt;span style="color:#66d9ef">int&lt;/span> i,j;
&lt;span style="color:#66d9ef">double&lt;/span> pi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3.1415926535898&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>ri);
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>i,&lt;span style="color:#f92672">&amp;amp;&lt;/span>j);
&lt;span style="color:#66d9ef">double&lt;/span> k&lt;span style="color:#f92672">=&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span>)&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">*&lt;/span>pi&lt;span style="color:#f92672">/&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span>)n;
&lt;span style="color:#66d9ef">double&lt;/span> s;
r&lt;span style="color:#f92672">=&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span>)ri;
&lt;span style="color:#66d9ef">if&lt;/span>(n&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>)
{
s&lt;span style="color:#f92672">=&lt;/span>sqrt(&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">*&lt;/span>r&lt;span style="color:#f92672">*&lt;/span>r);
}
&lt;span style="color:#66d9ef">else&lt;/span> s&lt;span style="color:#f92672">=&lt;/span>sqrt((&lt;span style="color:#66d9ef">double&lt;/span>)&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">*&lt;/span>r&lt;span style="color:#f92672">*&lt;/span>r&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2.0&lt;/span>&lt;span style="color:#f92672">*&lt;/span>r&lt;span style="color:#f92672">*&lt;/span>r&lt;span style="color:#f92672">*&lt;/span>cos(k));
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>abs(i&lt;span style="color:#f92672">-&lt;/span>j);
&lt;span style="color:#66d9ef">if&lt;/span>(p&lt;span style="color:#f92672">&amp;gt;&lt;/span>n&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>)
{
printf(&lt;span style="color:#e6db74">&amp;#34;%lf&amp;#34;&lt;/span>,s&lt;span style="color:#f92672">*&lt;/span>(n&lt;span style="color:#f92672">-&lt;/span>p));
}
&lt;span style="color:#66d9ef">else&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;%lf&amp;#34;&lt;/span>,s&lt;span style="color:#f92672">*&lt;/span>p);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Codeforces #618 (Div.2)</title><link>https://zzsqwq.github.io/posts/22/</link><pubDate>Mon, 10 Feb 2020 00:39:00 +0000</pubDate><guid>https://zzsqwq.github.io/posts/22/</guid><description>&lt;h2 id="a-non-zerohttpscodeforcescomcontest1300problema">
A. &lt;a href="https://codeforces.com/contest/1300/problem/A">Non-zero&lt;/a>
&lt;a class="heading-link" href="#a-non-zerohttpscodeforcescomcontest1300problema">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​       给出一段含有 $n$ 个数的序列 $a$ ，可以对其中任何数加一，问最少操作多少次让每一个数和序列和都不为0。&lt;/p>
&lt;hr>
&lt;h3 id="思路">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​       输入的时候如果输入的是 $0$ 就将答案加一，最后如果序列和为 $0$ 的话答案加一。&lt;/p>
&lt;hr>
&lt;h3 id="代码实现">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">int&lt;/span> t,n,sum,p,ans;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
sum&lt;span style="color:#f92672">=&lt;/span>ans&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>p);
&lt;span style="color:#66d9ef">if&lt;/span>(p&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
{
ans&lt;span style="color:#f92672">++&lt;/span>;
sum&lt;span style="color:#f92672">+=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;span style="color:#66d9ef">else&lt;/span> sum&lt;span style="color:#f92672">+=&lt;/span>p;
}
&lt;span style="color:#66d9ef">if&lt;/span>(sum&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>) printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,ans&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;span style="color:#66d9ef">else&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,ans);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="b-assigning-to-classeshttpscodeforcescomcontest1300problemb">
B. &lt;a href="https://codeforces.com/contest/1300/problem/B">Assigning to Classes&lt;/a>
&lt;a class="heading-link" href="#b-assigning-to-classeshttpscodeforcescomcontest1300problemb">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-1">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​       将 $2n$ 个数分成个奇数序列，问两个奇数序列的中位数之差最小为多少。&lt;/p>
&lt;hr>
&lt;h3 id="思路-1">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​       直接就将序列排序然后输出中间两个数之差即可。&lt;/p>
&lt;hr>
&lt;h3 id="代码实现-1">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100005&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> t,n,a[maxn&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>];
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>n&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>p;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i]);
}
sort(a&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,a&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>p);
printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,abs(a[n]&lt;span style="color:#f92672">-&lt;/span>a[n&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]));
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="c-anu-has-a-functionhttpscodeforcescomcontest1300problemc">
C. &lt;a href="https://codeforces.com/contest/1300/problem/C">Anu Has a Function&lt;/a>
&lt;a class="heading-link" href="#c-anu-has-a-functionhttpscodeforcescomcontest1300problemc">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-2">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​       给出函数 $f: f(x,y)=(x|y)-y $ ，给出序列 $a$，序列 $a$ 中含有 $n$ 个数，可以表示为$[a_1,a_2\cdots,a_n ]$ ，定义 $x=f(f(&amp;hellip;f(f(a_1,a_2),a_3),&amp;hellip;a_{n-1}),a_n)$ ，你可以对序列 $a$ 中元素进行重排，求使得 $x$ 最大的序列 $a$ 。如果有多种情况，输出一种即可。&lt;/p>
&lt;h3 id="思路-2">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>第一种思路是因为 $f(x,y)=(x|y)-y$ ，我们可以发现对于经过这样的运算之后，如果 $x$ 的某一位是1，如果 $y$ 的相应位是0，那么运算出来的 $f(x,y)$ 对应位就是1，如果 $y$ 对应位是1，那么运算出来就是0。那么对于 $x$ 的计算过程中的每一位这个规律都是适应的。因此我们只需要将位数从高到低依次扫一遍，如果这个位数为1的情况在序列所有元素中只出现了一次，那么就将唯一出现1的那个数放到第一位即可。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第二种思路
$$
\because f(x,y)=(x|y) - y {\Longleftrightarrow} f(x,y) = x&amp;amp;({\sim} y)
\therefore x=(a_1)&amp;amp;({\sim}a_2)&amp;amp;({\sim} a_3){\cdots}({\sim}a_n)
$$
我们发现后面其实都是可交换的，所以第一个只有第一个是起决定作用的，那么我们就可以处理一个前缀和后缀的 and 数组，这样我们就可以 $O(1)$ 的计算出后面那部分，然后遍历序列 $a$ 找到最合适的 $a_1$。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="代码实现-2">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;h4 id="第一种思路">
第一种思路
&lt;a class="heading-link" href="#%e7%ac%ac%e4%b8%80%e7%a7%8d%e6%80%9d%e8%b7%af">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">100005&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> n,a[maxn],maxk;
&lt;span style="color:#66d9ef">int&lt;/span> cnt;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i]);
maxk&lt;span style="color:#f92672">=&lt;/span>max(maxk,a[i]);
}
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,k&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">while&lt;/span>(p&lt;span style="color:#f92672">&amp;lt;=&lt;/span>maxk)
{
k&lt;span style="color:#f92672">++&lt;/span>;
p&lt;span style="color:#f92672">&amp;lt;&amp;lt;=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>k;i&lt;span style="color:#f92672">&amp;gt;=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;i&lt;span style="color:#f92672">--&lt;/span>)
{
cnt&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;j&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(a[j]&lt;span style="color:#f92672">&amp;amp;&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>i))
{
cnt&lt;span style="color:#f92672">++&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span>(cnt&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) swap(a[j],a[&lt;span style="color:#ae81ff">1&lt;/span>]);
}
}
&lt;span style="color:#75715e">// printf(&amp;#34;%d %d\n&amp;#34;,i,cnt);
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(cnt&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
{
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;j&lt;span style="color:#f92672">++&lt;/span>)
{
printf(&lt;span style="color:#e6db74">&amp;#34;%d &amp;#34;&lt;/span>,a[j]);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
printf(&lt;span style="color:#e6db74">&amp;#34;%d &amp;#34;&lt;/span>,a[i]);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="第二种思路">
第二种思路
&lt;a class="heading-link" href="#%e7%ac%ac%e4%ba%8c%e7%a7%8d%e6%80%9d%e8%b7%af">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">100005&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> n,a[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> ans;
&lt;span style="color:#66d9ef">int&lt;/span> pre[maxn],suf[maxn]; &lt;span style="color:#75715e">//pre is prefix,suf is suffix
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i]);
a[i]&lt;span style="color:#f92672">=~&lt;/span>a[i];
&lt;span style="color:#66d9ef">if&lt;/span>(i&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) pre[i]&lt;span style="color:#f92672">=&lt;/span>a[i];
&lt;span style="color:#66d9ef">else&lt;/span> pre[i]&lt;span style="color:#f92672">=&lt;/span>pre[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i];
}
suf[n]&lt;span style="color:#f92672">=&lt;/span>a[n];
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;gt;=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">--&lt;/span>)
{
suf[i]&lt;span style="color:#f92672">=&lt;/span>suf[i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i];
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>a[i];
p&lt;span style="color:#f92672">=~&lt;/span>a[i];
&lt;span style="color:#66d9ef">if&lt;/span>(i&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
{
&lt;span style="color:#66d9ef">int&lt;/span> now&lt;span style="color:#f92672">=&lt;/span>suf[i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">&amp;amp;&lt;/span>p;
ans&lt;span style="color:#f92672">=&lt;/span>max(ans,now);
}
&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(i&lt;span style="color:#f92672">==&lt;/span>n)
{
&lt;span style="color:#66d9ef">int&lt;/span> now&lt;span style="color:#f92672">=&lt;/span>pre[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">&amp;amp;&lt;/span>p;
&lt;span style="color:#66d9ef">if&lt;/span>(now&lt;span style="color:#f92672">&amp;gt;&lt;/span>ans)
{
swap(a[i],a[&lt;span style="color:#ae81ff">1&lt;/span>]);
ans&lt;span style="color:#f92672">=&lt;/span>now;
}
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
&lt;span style="color:#66d9ef">int&lt;/span> now&lt;span style="color:#f92672">=&lt;/span>pre[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">&amp;amp;&lt;/span>suf[i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">&amp;amp;&lt;/span>p;
&lt;span style="color:#66d9ef">if&lt;/span>(now&lt;span style="color:#f92672">&amp;gt;&lt;/span>ans)
{
swap(a[i],a[&lt;span style="color:#ae81ff">1&lt;/span>]);
ans&lt;span style="color:#f92672">=&lt;/span>now;
}
}
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
printf(&lt;span style="color:#e6db74">&amp;#34;%d &amp;#34;&lt;/span>,&lt;span style="color:#f92672">~&lt;/span>a[i]);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="d-aerodynamichttpscodeforcescomcontest1299problemb">
D. &lt;a href="https://codeforces.com/contest/1299/problem/B">Aerodynamic&lt;/a>
&lt;a class="heading-link" href="#d-aerodynamichttpscodeforcescomcontest1299problemb">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-3">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​       给定一个凸多边形 $P$ 的所有顶点，可以将凸多边形沿向量 $(x,y)$ 平移，我们定义多边形 $T$ 是所有 $P$ 平移到与原点有交点后所构成的点集所形成的图形（我知道这句话有点绕，我实在是解释不明白，实在不行康康原题吧）。那么问这个 $T$ 是否是和 $P$ 相似的，如果是输出YES，不是输出NO。&lt;/p>
&lt;hr>
&lt;h3 id="思路-3">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​       就是判断这个图形是不是中心对称图形就行了，证明还不会，暂且放一下，会了再写QAQ..&lt;/p>
&lt;hr>
&lt;h3 id="代码实现-3">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">100005&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> n;
&lt;span style="color:#66d9ef">int&lt;/span> x[maxn],y[maxn];
&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">check&lt;/span>()
{
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>n&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
&lt;span style="color:#75715e">// printf(&amp;#34;%d&amp;#34;,p);
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> x1&lt;span style="color:#f92672">=&lt;/span>x[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">+&lt;/span>x[&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>p];
&lt;span style="color:#66d9ef">int&lt;/span> y1&lt;span style="color:#f92672">=&lt;/span>y[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">+&lt;/span>y[&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>p];
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>p;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(x1&lt;span style="color:#f92672">!=&lt;/span>x[i]&lt;span style="color:#f92672">+&lt;/span>x[i&lt;span style="color:#f92672">+&lt;/span>p]&lt;span style="color:#f92672">||&lt;/span>y1&lt;span style="color:#f92672">!=&lt;/span>y[i]&lt;span style="color:#f92672">+&lt;/span>y[i&lt;span style="color:#f92672">+&lt;/span>p])
{
&lt;span style="color:#66d9ef">return&lt;/span> false;
}
}
&lt;span style="color:#66d9ef">return&lt;/span> true;
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>x[i],&lt;span style="color:#f92672">&amp;amp;&lt;/span>y[i]);
}
&lt;span style="color:#66d9ef">if&lt;/span>(n&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
{
printf(&lt;span style="color:#e6db74">&amp;#34;NO&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
&lt;span style="color:#66d9ef">if&lt;/span>(check())
{
printf(&lt;span style="color:#e6db74">&amp;#34;YES&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">else&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;NO&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr></description></item><item><title>Codeforces#617(Div.3)</title><link>https://zzsqwq.github.io/posts/17/</link><pubDate>Wed, 05 Feb 2020 23:18:00 +0000</pubDate><guid>https://zzsqwq.github.io/posts/17/</guid><description>&lt;h3 id="a-array-with-odd-sumhttpscodeforcescomcontest1296problema">
A. &lt;a href="https://codeforces.com/contest/1296/problem/A">Array with Odd Sum&lt;/a>
&lt;a class="heading-link" href="#a-array-with-odd-sumhttpscodeforcescomcontest1296problema">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;hr>
&lt;h4 id="题意">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       给出包含 &lt;strong>n&lt;/strong> 个正整数的序列 &lt;strong>a&lt;/strong> ，你可以把任何一个元素 $a_i$ ，赋值给另一个元素 $a_j$ ($i\neq j$) ，问通过任意此操作能否将序列 &lt;strong>a&lt;/strong> 的和变为奇数。可以输出 &lt;strong>YES&lt;/strong> ,不可以输入 &lt;strong>NO&lt;/strong>.&lt;/p>
&lt;hr>
&lt;h4 id="思路">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       首先当起始和为奇数的时候，就直接可输出 &lt;strong>YES&lt;/strong> 了，如果是偶数的话，我们可以发现，如果序列元素中同时包含奇数和偶数，那么就是可以的，否则不可以。&lt;/p>
&lt;hr>
&lt;h4 id="代码实现">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">int&lt;/span> t,n,flag,sum,p,flag1,flag2;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
flag&lt;span style="color:#f92672">=&lt;/span>false;
flag2&lt;span style="color:#f92672">=&lt;/span>flag1&lt;span style="color:#f92672">=&lt;/span>false;
sum&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>p);
sum&lt;span style="color:#f92672">+=&lt;/span>p;
&lt;span style="color:#66d9ef">if&lt;/span>(p&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) flag1&lt;span style="color:#f92672">=&lt;/span>true;
&lt;span style="color:#66d9ef">if&lt;/span>(p&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>) flag2&lt;span style="color:#f92672">=&lt;/span>true;
}
&lt;span style="color:#66d9ef">if&lt;/span>(flag1&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>flag2) flag&lt;span style="color:#f92672">=&lt;/span>true;
&lt;span style="color:#66d9ef">if&lt;/span>(sum&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) printf(&lt;span style="color:#e6db74">&amp;#34;YES&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">else&lt;/span>
{
&lt;span style="color:#66d9ef">if&lt;/span>(flag) printf(&lt;span style="color:#e6db74">&amp;#34;YES&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">else&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;NO&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="b-food-buyinghttpscodeforcescomcontest1296problemb">
B. &lt;a href="https://codeforces.com/contest/1296/problem/B">Food Buying&lt;/a>
&lt;a class="heading-link" href="#b-food-buyinghttpscodeforcescomcontest1296problemb">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;hr>
&lt;h4 id="题意-1">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       初始有 &lt;strong>s&lt;/strong> 个货币，每次花费 &lt;strong>x&lt;/strong> 个货币会返还 $\lfloor{\frac{x}{10}}\rfloor$ 个货币，问最多共能花费多少货币。&lt;/p>
&lt;hr>
&lt;h4 id="思路-1">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       贪心即可。剩余的货币一直除10累加，注意最终剩余不足10的处理。&lt;/p>
&lt;hr>
&lt;h4 id="代码实现-1">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">int&lt;/span> t,s;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>s);
{
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>s;
&lt;span style="color:#66d9ef">int&lt;/span> now&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">while&lt;/span>(p)
{
&lt;span style="color:#66d9ef">if&lt;/span>(p&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>) &lt;span style="color:#66d9ef">break&lt;/span>;
now&lt;span style="color:#f92672">=&lt;/span>p&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>;
s&lt;span style="color:#f92672">+=&lt;/span>now;
p&lt;span style="color:#f92672">%=&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>;
p&lt;span style="color:#f92672">+=&lt;/span>now;
}
}
printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,s);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="c-yet-another-walking-robothttpscodeforcescomcontest1296problemc">
C. &lt;a href="https://codeforces.com/contest/1296/problem/C">Yet Another Walking Robot&lt;/a>
&lt;a class="heading-link" href="#c-yet-another-walking-robothttpscodeforcescomcontest1296problemc">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;hr>
&lt;h4 id="题意-2">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       一个机器人初始在 $(0,0)$ 点，规定 &lt;strong>&amp;lsquo;L&amp;rsquo;&lt;/strong> ，&lt;strong>&amp;lsquo;R&amp;rsquo;&lt;/strong> ，&lt;strong>&amp;lsquo;U&amp;rsquo;&lt;/strong> ，&lt;strong>&amp;lsquo;D&amp;rsquo;&lt;/strong> 分别对应向左，向右，向上和向下。给定一段包含上述字母的序列 &lt;strong>s&lt;/strong> ，机器人遵循指引序列移动。如果删除一段连续序列可使得机器人最终到达终点不变，问删除的最短序列的起始和终点为多少。&lt;/p>
&lt;hr>
&lt;h4 id="思路-2">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       想了半天想了错误的解法。。一直在考虑 &lt;strong>L&lt;/strong> 和 &lt;strong>R&lt;/strong> 数相等，&lt;strong>U&lt;/strong> 和 &lt;strong>D&lt;/strong> 相等，通过这个方法来找序列。看了题解才发现是通过坐标来看。我们可以开一个map记录坐标和步数的关系，从左到右扫序列，如果没有到达过这个坐标，就记录当前是第几次移动到达这个坐标的，如果到达过的话，就看上一次到达这个坐标时的步数，计算他们的序列长度，如果小于计算的就更新答案。因为是需要找最小的，因此只需要记录上一次到达的步数即可。&lt;/p>
&lt;hr>
&lt;h4 id="代码实现-2">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;hr>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;map&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">200005&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> t,n;
&lt;span style="color:#66d9ef">char&lt;/span> s[maxn];
&lt;span style="color:#66d9ef">bool&lt;/span> flag;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">int&lt;/span> l&lt;span style="color:#f92672">=-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,r&lt;span style="color:#f92672">=&lt;/span>n;
scanf(&lt;span style="color:#e6db74">&amp;#34;%s&amp;#34;&lt;/span>,s&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> pos; &lt;span style="color:#75715e">//first为x second为y
&lt;/span>&lt;span style="color:#75715e">&lt;/span> map&lt;span style="color:#f92672">&amp;lt;&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> last;
pos.first&lt;span style="color:#f92672">=&lt;/span>pos.second&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
last[pos]&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(s[i]&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#e6db74">&amp;#39;L&amp;#39;&lt;/span>) pos.first&lt;span style="color:#f92672">--&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span>(s[i]&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#e6db74">&amp;#39;R&amp;#39;&lt;/span>) pos.first&lt;span style="color:#f92672">++&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span>(s[i]&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#e6db74">&amp;#39;U&amp;#39;&lt;/span>) pos.second&lt;span style="color:#f92672">++&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span>(s[i]&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#e6db74">&amp;#39;D&amp;#39;&lt;/span>) pos.second&lt;span style="color:#f92672">--&lt;/span>;
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> if(i==2)
&lt;/span>&lt;span style="color:#75715e"> {
&lt;/span>&lt;span style="color:#75715e"> printf(&amp;#34;%d %d\n&amp;#34;,pos.first,pos.second);
&lt;/span>&lt;span style="color:#75715e"> }
&lt;/span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span>(last.count(pos)&lt;span style="color:#f92672">!=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
{
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>i&lt;span style="color:#f92672">-&lt;/span>last[pos];
&lt;span style="color:#75715e">// if(i==2) printf(&amp;#34;%d %d\n&amp;#34;,i,last[pos]);
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(p&lt;span style="color:#f92672">&amp;lt;&lt;/span>r&lt;span style="color:#f92672">-&lt;/span>l)
{
l&lt;span style="color:#f92672">=&lt;/span>last[pos];
r&lt;span style="color:#f92672">=&lt;/span>i;
}
&lt;span style="color:#75715e">// if(i==2 )printf(&amp;#34;%d %d\n&amp;#34;,l,r);
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
last[pos]&lt;span style="color:#f92672">=&lt;/span>i;
}
&lt;span style="color:#66d9ef">if&lt;/span>(l&lt;span style="color:#f92672">==-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
{
printf(&lt;span style="color:#e6db74">&amp;#34;-1&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
printf(&lt;span style="color:#e6db74">&amp;#34;%d %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,l&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,r);
}
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="d-fight-with-monstershttpscodeforcescomcontest1296problemd">
D. &lt;a href="https://codeforces.com/contest/1296/problem/D">Fight with Monsters&lt;/a>
&lt;a class="heading-link" href="#d-fight-with-monstershttpscodeforcescomcontest1296problemd">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;hr>
&lt;h4 id="题意-3">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       由你先手和对手轮流击打 $n$ 个血量为 $h_i$ 的小怪兽，你可以对怪物造成 $a$ 点伤害，对手可以造成 $b$ 点伤害。你有 $k$ 次机会使对手跳过他的回合。当小怪兽血量 $h\le0$ 时视为被击杀，当你击杀怪兽，你获得一分，当对手击杀，你不得分。求你最多能获得多少分数。&lt;/p>
&lt;hr>
&lt;h4 id="思路-3">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       先看一下对于每个怪兽我们要击杀需要花费多少机会，你和对手一个回合会击杀怪兽 $a+b$ 点血量，因此你可以一直将回合进行到怪兽血量小于$a+b$，接下来我们可以分两种情况讨论。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>怪兽血量为0，那么我们就需要回溯对手最后一个回合，然后需要使用的机会就是 $\lceil\frac{h_i}{a}\rceil$ 次&lt;/p>
&lt;/li>
&lt;li>
&lt;p>怪兽血量不为0，我们需要使用的机会就是 $\lceil\frac{h_i}{a}\rceil-1$ 次，注意这里不能直接写 $\lfloor\frac{h_i}{a}\rfloor$ 次，因为如果 $h_i$ 刚好能被 $a$ 整除，后面这个写法就错了。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>​       计算出了每个怪兽需要花费的机会那么就好做了，就变成了一个贪心问题，我们去尽可能得击杀需要的机会少的，当机会消耗完毕，得到的就是答案了。&lt;/p>
&lt;hr>
&lt;h4 id="代码实现-3">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">200005&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> n,a,b,k;
&lt;span style="color:#66d9ef">int&lt;/span> f[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">cmp&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a,&lt;span style="color:#66d9ef">int&lt;/span> b)
{
&lt;span style="color:#66d9ef">return&lt;/span> a&lt;span style="color:#f92672">&amp;lt;&lt;/span>b;
}
&lt;span style="color:#66d9ef">int&lt;/span> h[maxn],ans;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a,&lt;span style="color:#f92672">&amp;amp;&lt;/span>b,&lt;span style="color:#f92672">&amp;amp;&lt;/span>k);
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>a&lt;span style="color:#f92672">+&lt;/span>b;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>h[i]);
h[i]&lt;span style="color:#f92672">%=&lt;/span>p;
&lt;span style="color:#66d9ef">if&lt;/span>(h[i]&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
{
h[i]&lt;span style="color:#f92672">+=&lt;/span>b;
f[i]&lt;span style="color:#f92672">=&lt;/span>ceil((&lt;span style="color:#66d9ef">double&lt;/span>)h[i]&lt;span style="color:#f92672">/&lt;/span>a);
}
&lt;span style="color:#66d9ef">else&lt;/span> f[i]&lt;span style="color:#f92672">=&lt;/span>ceil((&lt;span style="color:#66d9ef">double&lt;/span>)h[i]&lt;span style="color:#f92672">/&lt;/span>a)&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
}
sort(f&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,f&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>n,cmp);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(k&lt;span style="color:#f92672">-&lt;/span>f[i]&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">break&lt;/span>;
ans&lt;span style="color:#f92672">++&lt;/span>;
k&lt;span style="color:#f92672">-=&lt;/span>f[i];
}
printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,ans);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr></description></item><item><title>CodeforcesER #81</title><link>https://zzsqwq.github.io/posts/8/</link><pubDate>Sun, 02 Feb 2020 21:53:00 +0000</pubDate><guid>https://zzsqwq.github.io/posts/8/</guid><description>&lt;h3 id="a--display-the-numberhttpscodeforcescomcontest1295problema">
A : &lt;a href="https://codeforces.com/contest/1295/problem/A">Display The Number&lt;/a>
&lt;a class="heading-link" href="#a--display-the-numberhttpscodeforcescomcontest1295problema">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;h4 id="题意">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       用一定数目的灯管，显示尽可能大的数&lt;/p>
&lt;p>&lt;img src="https://s2.ax1x.com/2020/02/02/1te6Re.md.png" alt="A">&lt;/p>
&lt;h4 id="思路">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       因为位数多的肯定更大，所以肯定用尽量少的灯管搭建单个数字更好，最少的两个分别是两个灯管显示的1，以及三个灯管显示的7，所以就是尽可能的用1，如果最后剩余正好三个就显示7。这就转化成了判断奇数还是偶数的题，奇数就显示7111····，偶数就是1111···。注意要把7放在前面（我就踩坑了）。&lt;/p>
&lt;h4 id="代码实现">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">int&lt;/span> t,n;
&lt;span style="color:#66d9ef">int&lt;/span> cnt&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">if&lt;/span>(n&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
{
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>n&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>p;i&lt;span style="color:#f92672">++&lt;/span>) printf(&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
printf(&lt;span style="color:#e6db74">&amp;#34;7&amp;#34;&lt;/span>);
n&lt;span style="color:#f92672">-=&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>n&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>p;i&lt;span style="color:#f92672">++&lt;/span>) printf(&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>);
}
printf(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="b--infinite-prefixeshttpscodeforcescomcontest1295problemb">
B : &lt;a href="https://codeforces.com/contest/1295/problem/B">Infinite Prefixes&lt;/a>
&lt;a class="heading-link" href="#b--infinite-prefixeshttpscodeforcescomcontest1295problemb">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;h4 id="题意-1">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       给定一段01字符串 &lt;strong>s&lt;/strong> 为循环节，得到无限循环的01字符串 &lt;strong>t&lt;/strong>，求 &lt;strong>t&lt;/strong> 中有多少前缀满足0个数-1个数等于期望值&lt;strong>x&lt;/strong> （空前缀也算是一个前缀）&lt;/p>
&lt;blockquote>
&lt;p>前缀：例如&amp;quot;abcd&amp;quot;的前缀包括 &amp;quot; &amp;ldquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;ab&amp;rdquo;,&amp;ldquo;abc&amp;rdquo;,&amp;ldquo;abcd&amp;rdquo;.&lt;/p>
&lt;/blockquote>
&lt;h4 id="思路-1">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>首先我们先记录循环节 &lt;strong>s&lt;/strong> 中每个位置对应的01个数差，记为$num_i，i\in[1,n]$ （ &lt;strong>s&lt;/strong> 长度记为n）&lt;/p>
&lt;ul>
&lt;li>
&lt;p>首先我们可以发现当 &lt;strong>x=0&lt;/strong> 的时候，空前缀也会有贡献，因此不能忽略空前缀。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果循环节 &lt;strong>s&lt;/strong> 的01数相等，那么我们可以发现最后循环节一位$num_n$总为0，那么可以分两种情况来讨论&lt;/p>
&lt;ul>
&lt;li>如果循环节中存在大于等于1个前缀满足期望值x，那么就有无限个满足，因此输出-1&lt;/li>
&lt;li>如果循环节 &lt;strong>s&lt;/strong> 中不存在满足期望值的前缀，那么 &lt;strong>t&lt;/strong> 中也一定不存在&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>再来看一般情况，如果一个前缀中包含多个循环节 &lt;strong>s&lt;/strong> ,那么前面每个循环节对于最终01个数差的贡献总为$num_n$，因此我们可以用所期望的值 &lt;strong>x&lt;/strong>，利用1~n 循环减去每一位的 $num_i$，如果所得是$num_n$的非负倍数，那么就是符合期望的，否则不是。(本来一直这里不太明白，后来发现对于循环节中的每一个位置，在后续循环的过程中，如果$num_n$不为0，那么这个位置每次对应的值总是唯一的)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="代码实现-1">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">int&lt;/span> num[&lt;span style="color:#ae81ff">100005&lt;/span>];
&lt;span style="color:#66d9ef">int&lt;/span> t,cnt,n,x;
&lt;span style="color:#66d9ef">bool&lt;/span> flag&lt;span style="color:#f92672">=&lt;/span>false;
&lt;span style="color:#66d9ef">char&lt;/span> s[&lt;span style="color:#ae81ff">100005&lt;/span>];
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
cnt&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
flag&lt;span style="color:#f92672">=&lt;/span>false;
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>x);
scanf(&lt;span style="color:#e6db74">&amp;#34;%s&amp;#34;&lt;/span>,s&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(s[i]&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>)
{
num[i]&lt;span style="color:#f92672">=&lt;/span>num[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;span style="color:#66d9ef">else&lt;/span> num[i]&lt;span style="color:#f92672">=&lt;/span>num[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span>(num[i]&lt;span style="color:#f92672">==&lt;/span>x) flag&lt;span style="color:#f92672">=&lt;/span>true;
}
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>num[n];
&lt;span style="color:#66d9ef">if&lt;/span>(p&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(flag&lt;span style="color:#f92672">==&lt;/span>true)
{
printf(&lt;span style="color:#e6db74">&amp;#34;-1&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">continue&lt;/span>;
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
printf(&lt;span style="color:#e6db74">&amp;#34;0&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">continue&lt;/span>;
}
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">int&lt;/span> m&lt;span style="color:#f92672">=&lt;/span>x&lt;span style="color:#f92672">-&lt;/span>num[i];
&lt;span style="color:#66d9ef">if&lt;/span>(m&lt;span style="color:#f92672">%&lt;/span>p&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>m&lt;span style="color:#f92672">/&lt;/span>p&lt;span style="color:#f92672">&amp;gt;=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
{
cnt&lt;span style="color:#f92672">++&lt;/span>;
}
}
}
&lt;span style="color:#66d9ef">if&lt;/span>(x&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>) cnt&lt;span style="color:#f92672">++&lt;/span>;
printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,cnt);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="c--obtain-the-stringhttpscodeforcescomcontest1295problemc">
C : &lt;a href="https://codeforces.com/contest/1295/problem/C">Obtain The String&lt;/a>
&lt;a class="heading-link" href="#c--obtain-the-stringhttpscodeforcescomcontest1295problemc">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;h4 id="题意-2">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       给定字符串 &lt;strong>s&lt;/strong> 和 &lt;strong>t&lt;/strong> ，每次从 &lt;strong>s&lt;/strong> 中选取子序列放入起始为空串的 &lt;strong>z&lt;/strong> 后，问最少需要多少次操作使得 &lt;strong>z=t&lt;/strong>&lt;/p>
&lt;h4 id="思路-2">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       看了小姜老师的博客解法说是贪心，想了好一会，好像确实是可以贪心的···? 设置两个指针从 &lt;strong>s&lt;/strong> 和 &lt;strong>t&lt;/strong> 串的头部开始扫，对于 &lt;strong>t&lt;/strong> 串中的每个字母，循环扫 &lt;strong>s&lt;/strong> 串在其中找与它相同的，最终的答案就是扫 &lt;strong>s&lt;/strong> 串的次数。(小姜老师说这个实质上就是每次尽可能找尽可能多的后缀，仔细想想确实是这样。)不过这么一直暴力扫下去肯定不是最优的方法，想办法去优化。还是借鉴大佬的想法用一个lens*26的跳表，然后O(lent)扫一遍 &lt;strong>t&lt;/strong> 即可.&lt;/p>
&lt;blockquote>
&lt;p>跳表nxt的作用，用于寻找下一个所寻找字符在s中的位置。&lt;/p>
&lt;p>nxt[x][y]用于指向从x位置开始下一个y的位置+1 （next在C++属于保留字，注意不要踩坑）&lt;/p>
&lt;/blockquote>
&lt;h4 id="代码实现-2">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">100005&lt;/span>;
&lt;span style="color:#66d9ef">char&lt;/span> s[maxn],t[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> nxt[maxn][&lt;span style="color:#ae81ff">30&lt;/span>];
&lt;span style="color:#66d9ef">int&lt;/span> p,lens,lent;
&lt;span style="color:#66d9ef">int&lt;/span> pos,ans;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>p);
&lt;span style="color:#66d9ef">while&lt;/span>(p&lt;span style="color:#f92672">--&lt;/span>)
{
ans&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
scanf(&lt;span style="color:#e6db74">&amp;#34;%s&amp;#34;&lt;/span>,s&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
scanf(&lt;span style="color:#e6db74">&amp;#34;%s&amp;#34;&lt;/span>,t);
lent&lt;span style="color:#f92672">=&lt;/span>strlen(t),lens&lt;span style="color:#f92672">=&lt;/span>strlen(s&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;span style="color:#75715e">// printf(&amp;#34;%d&amp;#34;,lens);
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> c&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;c&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">26&lt;/span>;c&lt;span style="color:#f92672">++&lt;/span>)
{
nxt[lens&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][c]&lt;span style="color:#f92672">=-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>lens;i&lt;span style="color:#f92672">&amp;gt;=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">--&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(s[i]&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>&lt;span style="color:#f92672">==&lt;/span>c)
{
nxt[i][c]&lt;span style="color:#f92672">=&lt;/span>i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;span style="color:#66d9ef">else&lt;/span> nxt[i][c]&lt;span style="color:#f92672">=&lt;/span>nxt[i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][c];
}
}
pos&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;&lt;/span>lent;i&lt;span style="color:#f92672">++&lt;/span>)
{
pos&lt;span style="color:#f92672">=&lt;/span>nxt[pos][(&lt;span style="color:#66d9ef">int&lt;/span>)t[i]&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>];
&lt;span style="color:#66d9ef">if&lt;/span>(pos&lt;span style="color:#f92672">==-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
{
ans&lt;span style="color:#f92672">++&lt;/span>;
pos&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
pos&lt;span style="color:#f92672">=&lt;/span>nxt[pos][(&lt;span style="color:#66d9ef">int&lt;/span>)t[i]&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>];
&lt;span style="color:#66d9ef">if&lt;/span>(pos&lt;span style="color:#f92672">==-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
{
ans&lt;span style="color:#f92672">=-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">break&lt;/span>;
}
}
}
printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,ans);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr></description></item></channel></rss>