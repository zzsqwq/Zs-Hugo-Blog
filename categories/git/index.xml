<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Git on Zs's Blog</title><link>https://zzsqwq.github.io/categories/git/</link><description>Recent content in Git on Zs's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 23 Jul 2021 14:17:00 +0000</lastBuildDate><atom:link href="https://zzsqwq.github.io/categories/git/index.xml" rel="self" type="application/rss+xml"/><item><title>关于Git的一些理解</title><link>https://zzsqwq.github.io/posts/201/</link><pubDate>Fri, 23 Jul 2021 14:17:00 +0000</pubDate><guid>https://zzsqwq.github.io/posts/201/</guid><description>&lt;h1 id="前言">
前言
&lt;a class="heading-link" href="#%e5%89%8d%e8%a8%80">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h1>
&lt;p>前段时间在 Github 学完了关于 git 的小游戏 &lt;a href="https://github.com/pcottle/learnGitBranching">learnGitBranching&lt;/a> ，受益匪浅。&lt;/p>
&lt;p>它通过可视化的方式将分支的关系，每条命令的作用等都明明白白的体现出来，可以很直观的感受到你每条命令对整个分支树，每一个 ref 的作用。&lt;/p>
&lt;p>通过这种学习感觉自己对 Git 的理解更加深入一步，能够理解其中的原理，而不是浅尝辄止，照猫画虎。&lt;/p>
&lt;p>学习中记了一些零零散散的思路，想要写一篇笔记记录出来，之前已经写过一个简单的 Git 教程，这篇教程将会更加深入，希望可以帮助大家更好的掌握 Git。&lt;/p>
&lt;p>窃认为，想要学好 Git ，必须要理解清楚其中的分区以及引用，学会了这两个，各种基本操作就很容易理解了。接下来的笔记也基本以此思路展开。&lt;/p>
&lt;h1 id="git中的分区">
Git中的分区
&lt;a class="heading-link" href="#git%e4%b8%ad%e7%9a%84%e5%88%86%e5%8c%ba">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h1>
&lt;p>&lt;img src="https://www.zzsqwq.cn/usr/uploads/2021/07/612956951.jpg" alt="Git中的三大分区，图片来源自掘金GabrielPanda">&lt;/p>
&lt;p>首先，Git中存在三大分区，分别是&lt;strong>工作区、暂存区、版本库&lt;/strong>。其中，&lt;/p>
&lt;p>&lt;strong>工作区&lt;/strong>即我们工作的目录，&lt;strong>暂存区&lt;/strong>是我们执行 &lt;code>git add&lt;/code> 后文件存在的区域。&lt;/p>
&lt;p>我们可以通过 &lt;code>git status&lt;/code> 对两种状态进行查看，例如：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-sheel" data-lang="sheel">~/test master*
base ❯ git status
On branch master
Changes to be committed:
(use &amp;quot;git restore --staged &amp;lt;file&amp;gt;...&amp;quot; to unstage)
modified: test
Changes not staged for commit:
(use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
(use &amp;quot;git restore &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)
modified: test
&lt;/code>&lt;/pre>&lt;p>上图中存在两部分， 分别为 &lt;code>Changes to be committed&lt;/code> 这里是表示的版本库与暂存区的区别，还有&lt;code>Changes not staged for commit&lt;/code> ，它表示的是工作区与暂存区的区别。&lt;/p>
&lt;p>&lt;strong>版本库&lt;/strong>是我们执行 &lt;code>git commit -m &amp;quot;xxx&amp;quot;&lt;/code> 后，文件存在的区域。在上述过程中，Git 记录暂存区与版本库的差异，生成版本号，记录下来。我们可以通过 &lt;code>git log&lt;/code> 来查看我们产生的更改，内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">commit 9da52a0e4800547ca46bd6bb919d1105cea43f1e &lt;span style="color:#f92672">(&lt;/span>HEAD -&amp;gt; master&lt;span style="color:#f92672">)&lt;/span>
Author: zs &amp;lt;2459958352@qq.com&amp;gt;
Date: Thu Jul &lt;span style="color:#ae81ff">22&lt;/span> 22:09:45 &lt;span style="color:#ae81ff">2021&lt;/span> +0800
test commit
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中包含了版本号、当前节点上的 ref 记录、作者、邮箱、日期以及此次提交的注释。&lt;/p>
&lt;h1 id="git中的引用">
Git中的引用
&lt;a class="heading-link" href="#git%e4%b8%ad%e7%9a%84%e5%bc%95%e7%94%a8">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h1>
&lt;p>在 Git 中，引用到处可见，引用类似于给某一个 &lt;code>commit-id&lt;/code> 即某一次提交的 &lt;code>SHA-1&lt;/code> 值起一个简单的名字，如 &lt;code>branch&lt;/code> ，&lt;code>tag&lt;/code> 这些都是引用。&lt;/p>
&lt;p>Git 中存在一个命令， &lt;code>git update-ref&lt;/code> ，你可能几乎没见过，但可能天天在用。&lt;/p>
&lt;p>当运行类似于 &lt;code>git branch &amp;lt;branch&amp;gt;&lt;/code> 这样的命令时，Git 实际上会运行 &lt;code>git update-ref&lt;/code> 命令，例如，运行 &lt;code>git branch zs&lt;/code>，就等效于&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ git update-ref refs/heads/zs &amp;lt;commit-id&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的 &lt;code>commit-id&lt;/code> 就是当前提交的 &lt;code>commit-id&lt;/code> ，那他是如何获得的呢？&lt;/p>
&lt;p>使用过 Git 的人一定知道，Git 中存在一个名叫 &lt;code>HEAD&lt;/code> 的引用，它可能是引用，也可能是引用的引用。即它很多时候是指向某一个引用，如指向分支 &lt;code>master&lt;/code> 这个引用。不过，它也可以与引用分离，称为&lt;code>游离的HEAD&lt;/code>，即不指向某个引用，而指向单独的一个 &lt;code>commit&lt;/code> 。&lt;/p>
&lt;p>可以通过 &lt;code>git commit commit-id&lt;/code> 来实现，不过，我们一般&lt;strong>不推荐这种操作&lt;/strong>。下面的讨论，我们都是基于 &lt;code>HEAD&lt;/code> 是指向某一分支的。&lt;/p>
&lt;p>下面是关于一个引用的小例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">~/test master*
base ❯ git branch zs
~/test master*
base ❯ cat .git/refs/heads/zs
9da52a0e4800547ca46bd6bb919d1105cea43f1e
~/test master*
base ❯ git update-ref refs/heads/test 9da52a
~/test master*
base ❯ cat .git/HEAD
ref: refs/heads/master
~/test master*
base ❯ cat .git/refs/heads/master
9da52a0e4800547ca46bd6bb919d1105cea43f1e
~/test master*
base ❯ cat .git/refs/heads/test
9da52a0e4800547ca46bd6bb919d1105cea43f1e
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以发现，例子中 HEAD 指向 master ，master,zs,test 同时都指向 id 为 &lt;code>9da52a&lt;/code> 的提交。&lt;/p>
&lt;h1 id="撤销更改">
撤销更改
&lt;a class="heading-link" href="#%e6%92%a4%e9%94%80%e6%9b%b4%e6%94%b9">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h1>
&lt;h2 id="撤销本地更改">
撤销本地更改
&lt;a class="heading-link" href="#%e6%92%a4%e9%94%80%e6%9c%ac%e5%9c%b0%e6%9b%b4%e6%94%b9">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>通过&lt;strong>版本库&lt;/strong>撤销&lt;strong>暂存区&lt;/strong>更改，&lt;strong>工作区&lt;/strong>不改&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ git reset HEAD^ &lt;span style="color:#75715e">#撤销一次更改&lt;/span>
$ git reset HEAD~nums &lt;span style="color:#75715e">#撤销HEAD往前nums次更改&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>直接通过&lt;strong>版本库&lt;/strong>撤销&lt;strong>工作区&lt;/strong>的更改&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ git reset HEAD^ --hard &lt;span style="color:#75715e">#撤销一次更改&lt;/span>
$ git reset HEAD~nums --hard &lt;span style="color:#75715e">#撤销HEAD往前nums次更改&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以发现只要加了 &lt;code>--hard&lt;/code> ，就可以直接也把工作区改掉，不过建议三思而后行！&lt;/p>
&lt;h2 id="撤销远程更改">
撤销远程更改
&lt;a class="heading-link" href="#%e6%92%a4%e9%94%80%e8%bf%9c%e7%a8%8b%e6%9b%b4%e6%94%b9">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;p>上面说的是你本地的&lt;strong>工作区&lt;/strong> or &lt;strong>暂存区&lt;/strong>的撤销&lt;/p>
&lt;p>如果你已经把更改推送到了远端仓库，那么你想要去掉那次改动怎么办？&lt;/p>
&lt;p>可能你会想，直接通过 &lt;code>git reset&lt;/code> 切换到上面的某个需要的节点，然后再改？But，很容易想到这样会产生严重的冲突。&lt;strong>一旦commit已经被push到远程仓库，那么是坚决不允许去reset它的。&lt;/strong>&lt;/p>
&lt;p>还好，Git 给我们提供了一个更好的选择，你可以通过 &lt;code>git revert&lt;/code> 产生一个类似于补丁的东西来消除掉更改，很容易理解，这样没有改变树的结构，相对于 &lt;code>git reset&lt;/code> 他会往前走而不是回溯，这不会对之前的历史产生重要的影响。&lt;/p>
&lt;p>需要注意的是， &lt;code>git revert &lt;/code> 的用法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ git revert HEAD &lt;span style="color:#75715e">#撤销掉HEAD这次更改，回到HEAD的上次版本&lt;/span>
$ git revert &amp;lt;commit_id&amp;gt; &lt;span style="color:#75715e">#撤销掉这次cmmit的修改&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="两种合并方式">
两种合并方式
&lt;a class="heading-link" href="#%e4%b8%a4%e7%a7%8d%e5%90%88%e5%b9%b6%e6%96%b9%e5%bc%8f">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h1>
&lt;p>我们知道，Git 中存在两种合并分支的方式，分别为 &lt;code>git merge&lt;/code> 和 &lt;code>git rebase&lt;/code> 。&lt;/p>
&lt;p>两种方式各有优劣，简单说，&lt;code>rabase&lt;/code> 是把两条分支的提交记录整理到某一主分支上，它有着历史的完整记录。而 &lt;code>merge&lt;/code> 虽然也是整理了提交，但是某一分支的中间提交更改的过程合并后并不会体现在主分支上，中间过程可以说是在主分支上不可见的。&lt;/p>
&lt;p>很容易发现，&lt;code>rebase&lt;/code> 产生的主分支提交记录会更加的详细，它记录了每一步小的改动。而 &lt;code>merge&lt;/code> 产生的更简洁，有点类似于封装的意味，只是告诉你我这个提交完成了这个任务的开发，内部的实现细节却不会告诉你。&lt;/p>
&lt;p>而 &lt;code>rebase&lt;/code> 相比与 &lt;code>merge&lt;/code> 也会更加繁琐一些，你也可以通过 &lt;code>git rebase -i&lt;/code> 来通过可视化界面（可视化文本列表）的方式，来对记录做取舍与改动，不过还是没有 &lt;code>merge&lt;/code> 方便，远程仓库的合并操作一般都是使用 &lt;code>merge&lt;/code> 。&lt;/p>
&lt;p>需要注意的是，两种方法的使用习惯很不一样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ git merge &amp;lt;branch&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>代表的是将 &lt;code>&amp;lt;branch&amp;gt;&lt;/code> 分支合并到当前 &lt;code>HEAD&lt;/code> 所在的分支。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ git rebase &amp;lt;branch1&amp;gt; &amp;lt;branch2&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>代表的是将 &lt;code>branch2&lt;/code> 合并到 &lt;code>&amp;lt;branch1&amp;gt;&lt;/code> 的位置。如果省略 &lt;code>&amp;lt;branch2&amp;gt;&lt;/code> ，那么就是合并 &lt;code>HEAD&lt;/code> 所在分支到 &lt;code>&amp;lt;branch1&amp;gt;&lt;/code> 分支。&lt;/p>
&lt;p>可以发现 &lt;code>merge&lt;/code> 体现的是一种， &lt;code>merge xx&lt;/code> 到当前位置。而 &lt;code>rebase&lt;/code> 体现的是将自己合并到 &lt;code>xx&lt;/code> 那里去。一个是别人过来，一个是自己过去。建议两个命令改成 &lt;code>merge from&lt;/code> ，&lt;code>rebase into&lt;/code>，哈哈。&lt;/p>
&lt;p>顺便提一下， &lt;code>merge&lt;/code> 会导致一个节点有多个父节点，通过上文我们知道可以通过 &lt;code>~&lt;/code> 在一条线上移动，在这里，我们可以通过 &lt;code>^&lt;/code> 来指定第几个父节点，如 &lt;code>HEAD^3&lt;/code> 就是指 &lt;code>HEAD&lt;/code> 所在节点的第三个父节点。&lt;/p>
&lt;h1 id="整理提交记录">
整理提交记录
&lt;a class="heading-link" href="#%e6%95%b4%e7%90%86%e6%8f%90%e4%ba%a4%e8%ae%b0%e5%bd%95">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h1>
&lt;p>我们有时会需要把另一个分支的部分更改放到主分支上来，即整理我们所有的提交记录，拿到我们所需要的来组成一个完整功能。&lt;/p>
&lt;p>为了完成这件事，我们想到，这有点像合并分支，不过可能不需要某一个分支上的全部更改，只需要其中的一部分就可以了。&lt;/p>
&lt;p>上面提到，通过 &lt;code>git rebase -i&lt;/code> 可以进行交互式的 &lt;code>rebase&lt;/code> ，可以对提交记录进行取舍，因此这样就可以满足我们的需求，只不过可能合并的时候需要想明白是从哪里变到哪里，有一些烧脑。&lt;/p>
&lt;p>幸运的是，Git 还给我们提供了另一个更加简洁的方式——&lt;code>git cherry-pick&lt;/code> ，语法如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ git cherry-pick &amp;lt;commid-id&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>你可以通过这种方式，将树上的任意一个节点的提交添加到当前 &lt;code>HEAD&lt;/code> 所在分支的下方，这真是功能强大的命令！你也可以通过空格间隔，来顺序摘取多个提交。&lt;/p>
&lt;h1 id="两条万能指令">
两条万能指令
&lt;a class="heading-link" href="#%e4%b8%a4%e6%9d%a1%e4%b8%87%e8%83%bd%e6%8c%87%e4%bb%a4">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h1>
&lt;p>除了上面我觉得值得说道的问题，我还想推荐两条我认为非常有用的指令，掌握了他们，你就可以在分支树上随心所欲的移动！&lt;/p>
&lt;ul>
&lt;li>移动分支&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ git branch -f &amp;lt;branch&amp;gt; &amp;lt;commit-id&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过这条指令，你可以将 &lt;code>&amp;lt;branch&amp;gt;&lt;/code> 的引用指向 &lt;code>commit-id&lt;/code> ，如果你读懂了上面的内容，你会发现它只是通过 &lt;code>update-ref&lt;/code> 更新了对应的引用。&lt;/p>
&lt;ul>
&lt;li>移动 HEAD&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ git checkout &amp;lt;branch&amp;gt;
$ git checkout &amp;lt;commit-id&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过这条指令，你可以自由的移动 &lt;code>HEAD&lt;/code> 引用，前者让他指向了 &lt;code>&amp;lt;branch&amp;gt;&lt;/code> 分支，后者让他指向了SHA-1为 &lt;code>&amp;lt;commit-id&amp;gt;&lt;/code> 的提交。&lt;/p>
&lt;h1 id="推荐的资料">
推荐的资料
&lt;a class="heading-link" href="#%e6%8e%a8%e8%8d%90%e7%9a%84%e8%b5%84%e6%96%99">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h1>
&lt;p>在学习的过程中，看了很多资料，一并推荐给大家！&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/pcottle/learnGitBranching">learnGitBranching&lt;/a>：有趣的闯关游戏，但也干货满满。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://events.jianshu.io/p/9b3d7b6fe738">Git三大分区概念&lt;/a>：讲解了关于分区的概念，还有直观清晰的图片！&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%BC%95%E7%94%A8">Git的引用&lt;/a>：来自 Git 官方的讲解，十分硬核。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Git的简易教程</title><link>https://zzsqwq.github.io/posts/157/</link><pubDate>Sat, 05 Dec 2020 20:26:00 +0000</pubDate><guid>https://zzsqwq.github.io/posts/157/</guid><description>&lt;h3 id="前言">
前言
&lt;a class="heading-link" href="#%e5%89%8d%e8%a8%80">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​          最近在复习Git，因此顺手做个笔记分享出来，方便大家学习和查阅。相信无论是以后的课程作业还是工作，我们都会或多或少的接触/用到Git。&lt;/p>
&lt;h3 id="什么是git">
什么是Git？
&lt;a class="heading-link" href="#%e4%bb%80%e4%b9%88%e6%98%afgit">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​          Git你可能没听说过，但是我相信你应该听说过Github，&lt;del>毕竟是全球最大的同性交友网站&lt;/del>。他和Git有着密不可分的联系，我们后续再详细介绍。&lt;/p>
&lt;p>​          Git的中文全称叫 &lt;strong>分布式版本控制系统&lt;/strong> ，版本控制系统是什么意思呢？我们举一个简单的例子，你在做一个大作业，很可能要写上千行的代码，但是你可能写完一个功能以后，对他不够满意，但是又害怕改了以后后悔了，又找不回来了，所以你可能就有很多版本，版本1，版本2，版本3等等等。Git就是解决这个问题的，让你文件能够保持最新，但是又能恢复到之前的版本。&lt;/p>
&lt;p>​          那么既然有分布式版本控制系统，就有 &lt;strong>集中式版本控制系统&lt;/strong>，前者的代表是 &lt;strong>Git&lt;/strong> ，后者的代表有 &lt;strong>SVN、CVS&lt;/strong> 等。&lt;/p>
&lt;p>​          关于两者的区别，对于集中式版本控制系统，如果你想要对做一个项目的内容做修改，那么你要先从中央服务器把最近的版本拉取(Pull)下来，然后修改完以后，把修改后的版本推送(Push)上去，你本地只有最新的版本，而没有完整的版本库，分布式版本控制系统所作的工作与集中式的相差不大，只是它的本地会有一个完整的版本库，因此它十分的安全。&lt;/p>
&lt;p>​          这里贴一个他人总结的区别，供大家参考。&lt;/p>
&lt;p>&lt;img src="https://www.zzsqwq.cn/usr/uploads/2020/12/2911747011.png" alt="集中式与分布式版本控制系统的区别">&lt;/p>
&lt;h3 id="git的安装">
Git的安装
&lt;a class="heading-link" href="#git%e7%9a%84%e5%ae%89%e8%a3%85">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Linux系统&lt;/p>
&lt;p>         因为我只用过Ubuntu，所以我只会Ubuntu的QAQ..&lt;/p>
&lt;p>         Ubuntu中安装Git只需要在终端中输入 &lt;code>sudo apt-get install git&lt;/code> 即可。&lt;/p>
&lt;p>         如果是其他的linux系统，我猜你在终端中输入git即可获得安装提示，不然的话借助搜索引擎也可以。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Windows系统&lt;/p>
&lt;p>         直接去 &lt;a href="https://git-scm.com/downloads">Git官网&lt;/a> 下载安装程序然后安装即可。关于安装时候的选项，我都是用的默认的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Mac OS&lt;/p>
&lt;p>         太穷了，没用过Mac，但是参考链接中给出了方法，大家有需求可以参考。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="git的基本使用">
Git的基本使用
&lt;a class="heading-link" href="#git%e7%9a%84%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​          Git可以做许多事情，好比版本更新，版本修改，提交到远程仓库等等，这里我们只写一写大概以后用的会比较多的。&lt;/p>
&lt;p>​          需要注意的是，我们安装以后大概会有一个 &lt;strong>Git GUI&lt;/strong> 还有一个 &lt;strong>Git Bash&lt;/strong> ，开发中多用 &lt;strong>Git Bash&lt;/strong>，下面的教程也是基于&lt;strong>Git Bash&lt;/strong>的。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>表明身份&lt;/p>
&lt;p>         在Git所有仓库中我们都要有一个所有者的身份，用于标识是谁的仓库，用如下方式标识&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git config --global user.name &lt;span style="color:#e6db74">&amp;#34;Your Name&amp;#34;&lt;/span>
git config --global user.email &lt;span style="color:#e6db74">&amp;#34;Your email&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>创建版本库&lt;/p>
&lt;p>         我们想要把一个文件夹的内容用git来管理，只需要在文件夹目录运行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git init
&lt;/code>&lt;/pre>&lt;/div>&lt;p>         顾名思义这就是一个初始化的过程，运行以后在当前目录生成一个 &lt;code>.git&lt;/code> 文件夹，里面是我们版本控制的数据，一般不要修改。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>把文件添加到Git的暂存区&lt;/p>
&lt;p>         这里出现了 &lt;strong>暂存区&lt;/strong> 这个名词，Git内部的逻辑大概把我们工作的过程分为了三部分&lt;/p>
&lt;ol>
&lt;li>一个是 &lt;strong>工作区&lt;/strong> ，这个就是我们本地的文件夹。&lt;/li>
&lt;li>一个是 &lt;strong>暂存区&lt;/strong> ，这是我们把文件暂时放到暂存区里，没有决定更新我们的版本。&lt;/li>
&lt;li>一个是 &lt;strong>最终分支&lt;/strong>，这就是我们最终的版本存放的位置。&lt;/li>
&lt;/ol>
&lt;p>         贴一张廖雪峰老师教程中的一张图，我觉得还挺形象的。&lt;/p>
&lt;p>&lt;img src="https://static.liaoxuefeng.com/files/attachments/919020037470528/0" alt="git-repo">&lt;/p>
&lt;p>         我们清楚了上面的三个分区，那么考虑一下如何把文件夹中的文件从工作区推到暂存区，通过如下命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git add filepath
&lt;/code>&lt;/pre>&lt;/div>&lt;p>         我们就可以把文件推到暂存区，最后的filepath就是我们需要推送的文件的路径，一般都用相对路径。&lt;/p>
&lt;p>         上面是添加单个文件的方法，我们也可以把目录中所有做过更改的文件都加到暂存区中，就用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git add .
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>从暂存区推送到最后分支&lt;/p>
&lt;p>         我们可以把暂存区推送到最终分支，以完成我们的版本更新，通过&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git commit -m &lt;span style="color:#e6db74">&amp;#34;description&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>         其中description的内容是我们对该次版本更新的一次描述，好比增加什么功能。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>版本回退&lt;/p>
&lt;p>         那么既然我们每次有更新版本，我们如何从最新的版本回退到之前的某个版本呢？&lt;/p>
&lt;p>         这里我们需要了解到，我们有一个指针 &lt;code>HEAD&lt;/code> 来指向我们当前的版本，因此我们只需要指定HEAD指针指向的版本，就可以做到更改版本。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git reset --hard 版本号
git reset --hard HEAD^
git reset --hard HEAD~cnt
&lt;/code>&lt;/pre>&lt;/div>&lt;p>         这里三个命令都可以回退版本，每一个版本有一个版本号，可以指定版本号直接回到对应的版本。此外，通过 &lt;code>git reflog&lt;/code> 可以查看每个版本的版本号。&lt;/p>
&lt;p>         第二个和第三个有点像，都是往前回退几个版本，有几个&lt;code>^&lt;/code>就是回退几个，后面&lt;code>cnt&lt;/code>是几就回退几个。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>分支结构&lt;/p>
&lt;p>         Git支持分支结构，可以使我们的版本管理变得十分有序，以不至于逻辑混乱。&lt;/p>
&lt;p>         Git有一个初始主分支master，我们可以&lt;/p>
&lt;p>         创建分支&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git branch 分支名称
&lt;/code>&lt;/pre>&lt;/div>&lt;p>         切换分支(两个命令都可以)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git switch 分支名称
git checkout 分支名称
&lt;/code>&lt;/pre>&lt;/div>&lt;p>         创建并切换分支&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git checkout -b 分支名称
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>​          好了，学了这些，其实就已经够让我们在日常生活中管理文件了，下面说一些用于团队合作的。&lt;/p>
&lt;h3 id="github的作用">
Github的作用
&lt;a class="heading-link" href="#github%e7%9a%84%e4%bd%9c%e7%94%a8">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​          众所周知，一个大项目，想要一个人完成是很难的，大多数优秀的项目都是集思广益，大家一起出力建造出来的。&lt;/p>
&lt;p>​          我们上面提到的Github就是这样的一个平台，他是一个代码托管仓库，我们可以把新建一个仓库，然后把代码存储到上面，用的时候从上面Pull下来，而且只要经过你的同意，大家都可以为你的仓库贡献代码。由于这种开源的性质，Github有着许许多多优秀的项目，大家闲的没事可以去知乎搜搜Github上好玩的项目去玩一玩，好比 &lt;del>狗屁不通文章生成器&lt;/del> 。&lt;/p>
&lt;h3 id="git与github的协同">
Git与Github的协同
&lt;a class="heading-link" href="#git%e4%b8%8egithub%e7%9a%84%e5%8d%8f%e5%90%8c">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​          Git和Github密不可分，我们可以使用Git往Github上推送代码，从上面拉取代码等。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>从Github克隆代码&lt;/p>
&lt;p>         我们如果想要从一个公有仓库中，把它的代码克隆到自己的本地，然后对他做一些应用。我们可以使用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git clone 仓库地址
&lt;/code>&lt;/pre>&lt;/div>&lt;p>         这样就可以克隆仓库到本地，这里的仓库地址支持 &lt;code>https&lt;/code> 或者 &lt;code>ssh&lt;/code> 协议。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>推送本地仓库到Github&lt;/p>
&lt;p>         首先我们要在Github上有一个自己的仓库，才能将自己的代码推送上去，因此需要在Github上创建自己的公有/私有仓库。&lt;/p>
&lt;p>         然后我们在本地仓库做完修改，&lt;code>commit&lt;/code> 以后，输入如下命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git remote add origin 仓库地址
git push -u origin master
&lt;/code>&lt;/pre>&lt;/div>&lt;p>         这两步一个是与远程仓库建立关联，一个是将代码push上去。&lt;/p>
&lt;p>         通过这两步就可以把我们当地仓库推送到Github。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="github的pull-request">
Github的Pull Request
&lt;a class="heading-link" href="#github%e7%9a%84pull-request">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​          项目需要团队合作，&lt;strong>Pull Request&lt;/strong>就是为了团队协作而生的。&lt;/p>
&lt;p>​          你可以把他人的代码clone下来做完修改以后，向仓库所有者提交Pull Request，请求将自己的代码与他的代码合并，如果所有者同意，即可把你的代码合并到他的仓库中，以完成版本的更新，而你，就对这个项目做了一份贡献。&lt;/p>
&lt;p>​          那么如何提交Pull Request呢？&lt;/p>
&lt;p>​          对于对仓库有所有权的人来说，只需要把代码clone下来，然后创建并切换到自己的分支，对当前分支进行修改后，push到仓库中，然后创建合并请求即可。&lt;/p>
&lt;p>​          对于非仓库所有者而言，你需要先把代码 &lt;code>fork&lt;/code> 下来，然后clone你 &lt;code>fork&lt;/code> 的仓库，关联对方的远程仓库，修改后推上去，然后创建合并请求。&lt;/p>
&lt;p>​          大家对开源项目的贡献多是用第二种，自己团队内的协作多是第一种。&lt;/p>
&lt;h3 id="一个总结">
一个总结
&lt;a class="heading-link" href="#%e4%b8%80%e4%b8%aa%e6%80%bb%e7%bb%93">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​          这篇文章讲的内容不多，QAQ只讲了部分我们可能用的比较多的。&lt;/p>
&lt;p>​          关于Git的基本使用，还有很多内容，好比 &lt;code>git merge&lt;/code> ，&lt;code>git diff &lt;/code> 啥的，我们用的可能比较少，我就没提。大家如果有需求可以翻下面的参考链接进行学习。&lt;/p>
&lt;p>​          之后的内容多是团队协作会用到的，大家可以有需要的时候再看。学会使用Git可以有效地帮助我们管理文件，进行团队协作，提高工作效率。&lt;/p>
&lt;p>​          关于后续的学习，大家可以选择 &lt;strong>廖雪峰老师的Git教程&lt;/strong> ，实例丰富、简单易懂，此外还有 &lt;strong>Pro Git&lt;/strong> ，内容丰富，涵盖了基本所有的命令，以及Github上的一个开源项目 &lt;strong>learnGitBranching&lt;/strong> ，有着可视化的界面与闯关机制，趣味十足。&lt;/p>
&lt;h3 id="参考文档">
参考文档
&lt;a class="heading-link" href="#%e5%8f%82%e8%80%83%e6%96%87%e6%a1%a3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的Git教程&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://git-scm.com/book/zh/v2">Pro Git&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.cnblogs.com/wx1993/p/7680877.html">集中式(SVN)和分布式(Git)版本控制系统的简单比较&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.csdn.net/qq_33429968/article/details/62219783">git学习-Github上如何进行PR(Pull Request)&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/pcottle/learnGitBranching">pcottle/learnGitBranching: An interactive git visualization to challenge and educate! (github.com)&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></description></item></channel></rss>