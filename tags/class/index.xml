<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Class on Zs's Blog</title><link>https://blog.zzsqwq.cn/tags/class/</link><description>Recent content in Class on Zs's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 09 Nov 2022 22:40:41 +0800</lastBuildDate><atom:link href="https://blog.zzsqwq.cn/tags/class/index.xml" rel="self" type="application/rss+xml"/><item><title>C++ 类使用注意事项</title><link>https://blog.zzsqwq.cn/posts/cxx-class-skills/</link><pubDate>Wed, 09 Nov 2022 22:40:41 +0800</pubDate><guid>https://blog.zzsqwq.cn/posts/cxx-class-skills/</guid><description>前言 本文包含一些在使用 C++ 类时的注意事项，可避免一些常见问题，并能让你在写代码时更加自信。
因为目前我使用的是 C++ 17，所以仅保证以下内容在 C++ 17 中正确。
构造函数 对于单个参数的构造函数，推荐添加 explicit 关键字，防止隐式转换错误调用构造函数。 class DemoClass { explicit DemoClass(int test) { this-&amp;gt;test_ = test; } } 显式声明有参构造函数后，编译器不会自动生成无参构造函数，若需要，请添加 DemoClass() = default; class DemoClass { explicit DemoClass(int test) { this-&amp;gt;test_ = test; } DemoClass() = default; } 若子类中没有显式调用父类的构造函数，子类会默认调用父类的无参构造函数，如果父类没有无参构造函数，会报错。 析构函数 基类析构函数应该声明为 virtual，这样可以防止子类无法正确的析构。 由于基类析构函数为 virtual，派生类的析构函数应该显式的 override。 class DemoClass { virtual ~DemoClass() = default; } class ChildClass: public DemoClass { ~ChildClass() override { xxx; } } 成员变量默认值 对于类或局部作用域中未明确指定默认值的成员变量，其值遵循以下规则：</description></item></channel></rss>