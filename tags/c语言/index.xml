<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C语言 on Zs's Blog</title><link>https://zzsqwq.github.io/tags/c%E8%AF%AD%E8%A8%80/</link><description>Recent content in C语言 on Zs's Blog</description><generator>Hugo -- gohugo.io</generator><language>cn</language><lastBuildDate>Thu, 12 Nov 2020 23:13:00 +0000</lastBuildDate><atom:link href="https://zzsqwq.github.io/tags/c%E8%AF%AD%E8%A8%80/index.xml" rel="self" type="application/rss+xml"/><item><title>“程序星编程之路”第二次作业题解</title><link>https://zzsqwq.github.io/posts/136/</link><pubDate>Thu, 12 Nov 2020 23:13:00 +0000</pubDate><guid>https://zzsqwq.github.io/posts/136/</guid><description>&lt;h2 id="程序星编程之路第二次作业httpswwwluogucomcncontest36509题解">
&lt;a href="https://www.luogu.com.cn/contest/36509">“程序星编程之路”第二次作业&lt;/a>题解
&lt;a class="heading-link" href="#%e7%a8%8b%e5%ba%8f%e6%98%9f%e7%bc%96%e7%a8%8b%e4%b9%8b%e8%b7%af%e7%ac%ac%e4%ba%8c%e6%ac%a1%e4%bd%9c%e4%b8%9ahttpswwwluogucomcncontest36509%e9%a2%98%e8%a7%a3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="a-zs的回文质数httpswwwluogucomcnproblemu138527contestid36509">
A. &lt;a href="https://www.luogu.com.cn/problem/U138527?contestId=36509">Zs的回文质数&lt;/a>
&lt;a class="heading-link" href="#a-zs%e7%9a%84%e5%9b%9e%e6%96%87%e8%b4%a8%e6%95%b0httpswwwluogucomcnproblemu138527contestid36509">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;h4 id="题目描述">
题目描述
&lt;a class="heading-link" href="#%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​    读入一个整数 $n$ ，输出 $[1,n]$ 的所有回文质数，我们规定 $1\sim9$ 也是回文数。&lt;/p>
&lt;h4 id="思路">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​    首先我们需要了解什么是&lt;a href="https://baike.baidu.com/item/%E5%9B%9E%E6%96%87%E6%95%B0">回文数&lt;/a>，以及什么是&lt;a href="https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0">质数&lt;/a>。&lt;/p>
&lt;p>​    简单点说，回文数就是正着读反着读都是一样的，也就是对称的，形如 $abcba $ 或者 $123321$ 这样的。&lt;/p>
&lt;p>​    质数的话，对于一个数 $n$ ，如果他是质数，那它除了 $1$ 和 $n$ 没有其他因子。例如 $2,3,5,7,11$ 这样的。&lt;/p>
&lt;p>​    那么接下来我们考虑一下解决这个问题应该怎么做，首先我们看一下数据范围，$[1,100000]$ ，还是挺小的，我们可以考虑直接枚举每一个数来判断它是不是回文数，然后再判断一下是不是质数，如果两个都满足，我们就输出它。&lt;/p>
&lt;p>​    判断回文数，我们可以考虑到 NOJ05 幸运数 一题的解题思路，也就是说我们把一个数倒置过来，好比一个数 $xyz$ 倒置成 $zyx$ ，然后判断是否 $xyz == zyx$ ，如果相等的话就是回文数，如果不相等就不是。&lt;/p>
&lt;p>​    判断质数，我们可以在 $[2,\lfloor\sqrt{n}\rfloor]$ 枚举它的因子，这个的完备性我上课的时候证明过，不再赘述。这里需要注意 $1,2$ 需要特判一下。&lt;/p>
&lt;h4 id="代码">
代码
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;math.h&amp;gt; //我们需要用到sqrt函数，因此需要引入数学库&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
&lt;span style="color:#66d9ef">int&lt;/span> n;
&lt;span style="color:#66d9ef">bool&lt;/span> flag &lt;span style="color:#f92672">=&lt;/span> false; &lt;span style="color:#75715e">// 标记 i 是否满足条件
&lt;/span>&lt;span style="color:#75715e">&lt;/span> scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
flag &lt;span style="color:#f92672">=&lt;/span> true;
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>i,j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">while&lt;/span>(p) &lt;span style="color:#75715e">// 将 p 反转为 j
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
j&lt;span style="color:#f92672">=&lt;/span>j&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#f92672">+&lt;/span>p&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>;
p&lt;span style="color:#f92672">/=&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>;
}
&lt;span style="color:#66d9ef">if&lt;/span>(j&lt;span style="color:#f92672">==&lt;/span>i)
{
&lt;span style="color:#66d9ef">if&lt;/span>(j&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#66d9ef">continue&lt;/span>; &lt;span style="color:#75715e">// 特判 1
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(j&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#75715e">// 特判 2
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
printf(&lt;span style="color:#e6db74">&amp;#34;2&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">continue&lt;/span>;
}
&lt;span style="color:#66d9ef">int&lt;/span> sqrtj &lt;span style="color:#f92672">=&lt;/span> sqrt(j);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> k&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;k&lt;span style="color:#f92672">&amp;lt;=&lt;/span>sqrtj;k&lt;span style="color:#f92672">++&lt;/span>) &lt;span style="color:#75715e">// 枚举 [2,sqrt(n)]
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
&lt;span style="color:#66d9ef">if&lt;/span>(j&lt;span style="color:#f92672">%&lt;/span>k&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e">// 如果能够整除(余数为0),那么是 j 的因子
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
flag &lt;span style="color:#f92672">=&lt;/span> false;
&lt;span style="color:#66d9ef">break&lt;/span>;
}
}
&lt;span style="color:#66d9ef">if&lt;/span>(flag)
{
printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,j);
}
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="其他">
其他
&lt;a class="heading-link" href="#%e5%85%b6%e4%bb%96">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​    因为我们讲到这里的时候，我们没讲函数，但是这道题如果我们把判断是否为回文数，判断是否为质数，都另成一个函数模块，将使得程序变得更加简洁。我在这里也将函数版本的贴出来，有兴趣的可以看一下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;math.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">isprime&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> k) &lt;span style="color:#75715e">//判断是否为质数，如果是质数返回true，如果不是返回false
&lt;/span>&lt;span style="color:#75715e">&lt;/span>{
&lt;span style="color:#66d9ef">if&lt;/span>(k&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;span style="color:#66d9ef">if&lt;/span>(k&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>sqrt(k);i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(k&lt;span style="color:#f92672">%&lt;/span>i&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> false;
}
&lt;span style="color:#66d9ef">return&lt;/span> true;
}
&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">ishw&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> k) &lt;span style="color:#75715e">//判断是否为回文数，如果是返回true，如果不是返回false
&lt;/span>&lt;span style="color:#75715e">&lt;/span>{
&lt;span style="color:#66d9ef">int&lt;/span> ans&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> k; &lt;span style="color:#75715e">//temp作为一个k的复制版，因为后续需要用到k，新定义一个作为备份
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span>(k)
{
ans &lt;span style="color:#f92672">=&lt;/span> ans&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#f92672">+&lt;/span> k&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>;
k&lt;span style="color:#f92672">/=&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>;
}
&lt;span style="color:#66d9ef">if&lt;/span>(temp &lt;span style="color:#f92672">==&lt;/span> ans)
{
&lt;span style="color:#66d9ef">return&lt;/span> true;
}
&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> false;
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
&lt;span style="color:#66d9ef">int&lt;/span> n;
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(isprime(i) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ishw(i)) &lt;span style="color:#75715e">//如果既是质数也是回文数
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,i);
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="b-wcx的杨辉三角httpswwwluogucomcnproblemu138528contestid36509">
B. &lt;a href="https://www.luogu.com.cn/problem/U138528?contestId=36509">Wcx的杨辉三角&lt;/a>
&lt;a class="heading-link" href="#b-wcx%e7%9a%84%e6%9d%a8%e8%be%89%e4%b8%89%e8%a7%92httpswwwluogucomcnproblemu138528contestid36509">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;h4 id="题目描述-1">
题目描述
&lt;a class="heading-link" href="#%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​    读入一个整数 $n$ ，输出杨辉三角的前 $n$ 行。&lt;/p>
&lt;h4 id="思路-1">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​    首先这道题我们需要了解一下&lt;a href="https://baike.baidu.com/item/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92">杨辉三角&lt;/a> ，大家小学到高中应该都了解过。&lt;/p>
&lt;p>​    那么如何计算杨辉三角，首先我们可以知道的是杨辉三角的第 $i$ 行就是$C_i^0\sim C_i^i$ ，但是我们考虑一下如何计算组合数，是用阶乘对吧，但是阶乘就涉及到一个连乘，对于这个题，我数据范围写的是 $1\le n \le 40$ ，很明显，阶乘不可行。而且写起来挺麻烦的。&lt;/p>
&lt;p>​    那么我们考虑一个组合数的性质
$$
C_n^i = C_{n-1}^i + C_{n-1}^{i-1}
$$&lt;/p>
&lt;p>​    看起来很高大上对吧，简单点说就是杨辉三角里面一个数的值等于两肩之和，那么基于这个性质，我们很容易想到，我们可以用一个二维数组，定义 $f[i][j]$ 为第 $i$ 行的第 $j$ 个数，那么可以得到&lt;/p>
&lt;ul>
&lt;li>
&lt;p>当 $j==1$ 或 $j==i$ ，则 $f[i][j] = 1$ ，也就是，当它为这一行的第一个或者最后一个，那么它就是 $1$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果不是上述条件，则 $f[i][j] = f[i-1][j] + f[i-1][j-1]$ ，也就是等于两肩之和。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>​    &lt;strong>还有一个需要注意的问题就是，这个题的 $n$ 最大值是 40，这个时候已经超出了 $int$ 的范围，因此我们需要将二维数组定义为 $long: :long$ 。&lt;/strong>&lt;/p>
&lt;h4 id="代码-1">
代码
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> a[&lt;span style="color:#ae81ff">105&lt;/span>][&lt;span style="color:#ae81ff">105&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#ae81ff">0&lt;/span>}; &lt;span style="color:#75715e">//全都初始化为 0
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>) &lt;span style="color:#75715e">//这里我用的是 1~n 而不是 0~n-1
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>i;j&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(j&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">||&lt;/span> j&lt;span style="color:#f92672">==&lt;/span>i)
{
printf(&lt;span style="color:#e6db74">&amp;#34;%lld &amp;#34;&lt;/span>,a[i][j]&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
printf(&lt;span style="color:#e6db74">&amp;#34;%lld &amp;#34;&lt;/span>,a[i][j]&lt;span style="color:#f92672">=&lt;/span>a[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][j&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">+&lt;/span>a[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][j]);
}
}
printf(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="其他-1">
其他
&lt;a class="heading-link" href="#%e5%85%b6%e4%bb%96-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​    这道题主要是对二维数组的考察。&lt;/p>
&lt;p>​    注意我们遇到第五个点过不去的时候，应该试一下最大的值 $40$ ，会发现有负数，显然是溢出问题，我们就能知道问题的解决办法了。&lt;/p>
&lt;h3 id="c-zh的约瑟夫环问题httpswwwluogucomcnproblemu138529contestid36509">
C. &lt;a href="https://www.luogu.com.cn/problem/U138529?contestId=36509">Zh的约瑟夫环问题&lt;/a>
&lt;a class="heading-link" href="#c-zh%e7%9a%84%e7%ba%a6%e7%91%9f%e5%a4%ab%e7%8e%af%e9%97%ae%e9%a2%98httpswwwluogucomcnproblemu138529contestid36509">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;h4 id="题目描述-2">
题目描述
&lt;a class="heading-link" href="#%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​    有 $n$ 个人围成一圈，顺序排号，从第一个开始报数(从 $1$ 到 $m$ 报数)，凡报到 $m$ 的人退出圈子，问最后留下的是几号.&lt;/p>
&lt;h4 id="思路-2">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​    约瑟夫问题是个很经典的问题，可能又叫什么猴子选大王什么的，特多变体。&lt;/p>
&lt;p>​    这个题其实就是一个纯模拟题，主要是对数组的考察。我们可以考虑开一个布尔数组 &lt;strong>vis&lt;/strong> 用来标记某个人是否出圈，如果出圈了我们给他设置为 &lt;strong>true&lt;/strong> ，如果没有出圈就是 &lt;strong>false&lt;/strong> 。&lt;/p>
&lt;p>​    然后开一个报数到多少的变量&lt;strong>cnt&lt;/strong>，开一个当前谁报数的变量&lt;strong>pot&lt;/strong>，然后来模拟这个过程。如果 &lt;strong>cnt&lt;/strong> 增长到了 &lt;strong>m&lt;/strong> ，我们将 &lt;strong>pot&lt;/strong> 出圈，也就是 &lt;strong>vis[pot] = true&lt;/strong> ，然后在场的人数减一，当只剩下一人的时候，我们遍历 &lt;strong>vis&lt;/strong> 数组中的每个元素，如果它的 vis 值为 &lt;strong>false&lt;/strong> ，即没有出队，则将他输出。&lt;/p>
&lt;p>​    还有一个要注意的问题就是这是一个环，那么我们只需要判断一下当 &lt;strong>pot&lt;/strong> 为 $n+1$ 的时候将他置为 $1$ 即可，这就模拟了一个环的性质。&lt;/p>
&lt;h4 id="代码-2">
代码
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
using namespace std;
&lt;span style="color:#66d9ef">int&lt;/span> n,m;
&lt;span style="color:#66d9ef">int&lt;/span> vis[&lt;span style="color:#ae81ff">1005&lt;/span>]; &lt;span style="color:#75715e">//vis[i] = true 已经淘汰 vis[i] = false 未被淘汰
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>m);
&lt;span style="color:#66d9ef">int&lt;/span> cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">//报数到多少
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> pot &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">//当前是谁报数
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> exist &lt;span style="color:#f92672">=&lt;/span> n; &lt;span style="color:#75715e">//在场的人数
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span>(exist &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)
{
cnt&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>vis[pot]) &lt;span style="color:#75715e">//如果没有出圈
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
cnt&lt;span style="color:#f92672">++&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span>(cnt&lt;span style="color:#f92672">==&lt;/span>m)
{
vis[pot] &lt;span style="color:#f92672">=&lt;/span> true;
exist&lt;span style="color:#f92672">--&lt;/span>;
&lt;span style="color:#66d9ef">break&lt;/span>;
}
}
pot&lt;span style="color:#f92672">++&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span>(pot&lt;span style="color:#f92672">==&lt;/span>n&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) pot&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">//模拟环
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(vis[i] &lt;span style="color:#f92672">==&lt;/span> false) printf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,i);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="其他-2">
其他
&lt;a class="heading-link" href="#%e5%85%b6%e4%bb%96-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​    上面的想法是比较好理解的形式。&lt;/p>
&lt;p>​    我们考虑一下模拟环，也就是使得 &lt;strong>pot&lt;/strong> 指针处在一定的范围内，如果超出了将他重新置到头部，那么我们可以联想到取模，在模拟环时使用取模来实现，大家可以下去自己尝试，这有点像魏辰旭第一节课讲的那个字符串的问题。&lt;/p>
&lt;p>​    因为这道题只关心谁活了下来，所以还有一个比较简单的解法，我看在作业中也有几位同学给出了这个较简单的解法，如果理解了上述思想，看这个代码应该不难理解，大家可以对照代码自行思考。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n,m;
&lt;span style="color:#66d9ef">int&lt;/span> pot &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>m);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
pot &lt;span style="color:#f92672">=&lt;/span> (pot&lt;span style="color:#f92672">+&lt;/span>m)&lt;span style="color:#f92672">%&lt;/span>i;
}
printf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,pot&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>​    &lt;strong>提示：n个人的约瑟夫环杀掉一个人后组成一个新的人数为 n-1 的约瑟夫环&lt;/strong>&lt;/p></description></item></channel></rss>