<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>搜索 on Zs's Blog</title><link>https://zzsqwq.github.io/tags/%E6%90%9C%E7%B4%A2/</link><description>Recent content in 搜索 on Zs's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 04 Feb 2020 23:02:00 +0000</lastBuildDate><atom:link href="https://zzsqwq.github.io/tags/%E6%90%9C%E7%B4%A2/index.xml" rel="self" type="application/rss+xml"/><item><title>洛谷的一些搜索题</title><link>https://zzsqwq.github.io/posts/16/</link><pubDate>Tue, 04 Feb 2020 23:02:00 +0000</pubDate><guid>https://zzsqwq.github.io/posts/16/</guid><description>&lt;h3 id="1-p1378-油滴扩展httpswwwluogucomcnproblemp1378">
1. &lt;a href="https://www.luogu.com.cn/problem/P1378">P1378 油滴扩展&lt;/a>
&lt;a class="heading-link" href="#1-p1378-%e6%b2%b9%e6%bb%b4%e6%89%a9%e5%b1%95httpswwwluogucomcnproblemp1378">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;hr>
&lt;h4 id="题意">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       在长方形框中，最多有 n ($0\le{n}\le6$)个相异点，在框中点上依次放置可扩展的油滴，当碰到其他油滴边界或者长方形边框时会停止，扩展呈圆形展开。放置下一个时会确保上一个已经扩展完成。问通过变换放置顺序可使得最终框中剩下的面积最小为多少。&lt;/p>
&lt;hr>
&lt;h4 id="思路">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       这是个裸的dfs，情况最多也就 $6! = 720$ 种，所以我们可以只需要设置一个vis数组来记录是否已经放置过这个油滴，计算已扩展油滴和将要放的油滴之间的距离可以用 &lt;strong>两点距离-扩展油滴的半径&lt;/strong>来实现 ，但是有个坑需要注意，就是当一个油滴已经放在已经有扩展油滴覆盖的区域，那么他俩的距离是0，而不是负数，因此在计算半径的时候需要优化一下。&lt;/p>
&lt;hr>
&lt;h4 id="代码实现">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">#define pi 3.1415926
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> n,x,y,xx,yy;
&lt;span style="color:#66d9ef">double&lt;/span> rx[maxn];
&lt;span style="color:#66d9ef">double&lt;/span> maxans;
&lt;span style="color:#66d9ef">bool&lt;/span> vis[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> dx[maxn],dy[maxn];
&lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">diss&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x1,&lt;span style="color:#66d9ef">int&lt;/span> y1,&lt;span style="color:#66d9ef">int&lt;/span> x2,&lt;span style="color:#66d9ef">int&lt;/span> y2) &lt;span style="color:#75715e">//计算两点距离
&lt;/span>&lt;span style="color:#75715e">&lt;/span>{
&lt;span style="color:#66d9ef">return&lt;/span> sqrt((x1&lt;span style="color:#f92672">-&lt;/span>x2)&lt;span style="color:#f92672">*&lt;/span>(x1&lt;span style="color:#f92672">-&lt;/span>x2)&lt;span style="color:#f92672">+&lt;/span>(y1&lt;span style="color:#f92672">-&lt;/span>y2)&lt;span style="color:#f92672">*&lt;/span>(y1&lt;span style="color:#f92672">-&lt;/span>y2));
}
&lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">radius&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> p) &lt;span style="color:#75715e">//计算半径
&lt;/span>&lt;span style="color:#75715e">&lt;/span>{
&lt;span style="color:#66d9ef">double&lt;/span> ans&lt;span style="color:#f92672">=&lt;/span>min(abs(dx[p]&lt;span style="color:#f92672">-&lt;/span>x),min(abs(dy[p]&lt;span style="color:#f92672">-&lt;/span>y),min(abs(dx[p]&lt;span style="color:#f92672">-&lt;/span>xx),abs(dy[p]&lt;span style="color:#f92672">-&lt;/span>yy))));
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(vis[i]&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>i&lt;span style="color:#f92672">!=&lt;/span>p)
{
&lt;span style="color:#66d9ef">double&lt;/span> dis&lt;span style="color:#f92672">=&lt;/span>diss(dx[i],dy[i],dx[p],dy[p]);
ans&lt;span style="color:#f92672">=&lt;/span>min(ans,max(dis&lt;span style="color:#f92672">-&lt;/span>rx[i],&lt;span style="color:#ae81ff">0.0&lt;/span>));
}
}
&lt;span style="color:#66d9ef">return&lt;/span> ans;
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> nowcnt,&lt;span style="color:#66d9ef">double&lt;/span> area) &lt;span style="color:#75715e">//area为拓展总面积 nowcnt为现在已经放置了几个
&lt;/span>&lt;span style="color:#75715e">&lt;/span>{
&lt;span style="color:#66d9ef">if&lt;/span>(nowcnt&lt;span style="color:#f92672">==&lt;/span>n)
{
maxans&lt;span style="color:#f92672">=&lt;/span>max(maxans,area);
&lt;span style="color:#66d9ef">return&lt;/span> ;
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>vis[i])
{
vis[i]&lt;span style="color:#f92672">=&lt;/span>true;
rx[i]&lt;span style="color:#f92672">=&lt;/span>radius(i);
dfs(nowcnt&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,area&lt;span style="color:#f92672">+&lt;/span>pi&lt;span style="color:#f92672">*&lt;/span>rx[i]&lt;span style="color:#f92672">*&lt;/span>rx[i]);
rx[i]&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
vis[i]&lt;span style="color:#f92672">=&lt;/span>false;
}
}
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>x,&lt;span style="color:#f92672">&amp;amp;&lt;/span>y,&lt;span style="color:#f92672">&amp;amp;&lt;/span>xx,&lt;span style="color:#f92672">&amp;amp;&lt;/span>yy);
&lt;span style="color:#66d9ef">double&lt;/span> sum&lt;span style="color:#f92672">=&lt;/span>abs(x&lt;span style="color:#f92672">-&lt;/span>xx)&lt;span style="color:#f92672">*&lt;/span>abs(y&lt;span style="color:#f92672">-&lt;/span>yy); &lt;span style="color:#75715e">//矩形总面积
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>dx[i],&lt;span style="color:#f92672">&amp;amp;&lt;/span>dy[i]);
}
dfs(&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">0.0&lt;/span>);
printf(&lt;span style="color:#e6db74">&amp;#34;%0.0lf&amp;#34;&lt;/span>,sum&lt;span style="color:#f92672">-&lt;/span>maxans);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="2-p1120-小木棍httpswwwluogucomcnproblemp1120">
2. &lt;a href="https://www.luogu.com.cn/problem/P1120">P1120 小木棍&lt;/a>
&lt;a class="heading-link" href="#2-p1120-%e5%b0%8f%e6%9c%a8%e6%a3%8dhttpswwwluogucomcnproblemp1120">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;hr>
&lt;h4 id="题意-1">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       将一些长度为 &lt;strong>x&lt;/strong> 的等长木棍全部切成 &lt;strong>n&lt;/strong> 段不超过50的小木棍，求长木棍长度 &lt;strong>x&lt;/strong> 的最小长度。&lt;/p>
&lt;hr>
&lt;h4 id="思路-1">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       首先这个题是有个坑的，题目给出来了，输入的小木棍长度可能会有大于50的，因此我们需要筛掉它。&lt;/p>
&lt;p>​       那么很显然这个题是一道搜索题，我们可以写搜索函数&lt;code>dfs(int nowcnt,int nxt,int lenlast,int len)&lt;/code>.上述参数分别表示: 现在在寻找第几根小木棍，我们寻找下一个拼接段应该从哪里开始找，当前这根拼接还需要多长，以及我们要拼成多长的木棍。搜索的复杂度这么高，对于 $n\le65$ 的数据肯定不能直接无脑搜，因此需要想想怎么优化。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>首先要从大到小排序这个很关键的，因为你从大的先凑就能够保证后面选择的时候容错率更高一些。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>很显然我们可以剪掉当 lenlast&amp;lt;0 的情况，这个地方我们可以在拼接的时候就判断，也可以在拼接后判断。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在寻找下一个拼接片段的时候，我们可以通过二分搜索来查找下一个不超过lenlast的片段，我选择了直接用STL的库中的lower_bound函数。&lt;del>(其实因为是我的二分总是写炸)&lt;/del>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>再就是我们对于相等片段的处理，很显然当前片段不符合情况那么与他等长的也都不会符合，因此我们可以直接循环筛掉。当然更优的方法可以提前处理一个跳表，直接跳到下一个与他不同的位置。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后这个优化还是挺难想的，就是如果当前片段搜下去已经不符合情况，但是当前的lenlast是等于当前片段长度的，也就是说你正好用了尽可能满足条件的一个方案，也还是没达到目的，你们你继续往下搜，用比他还要劣的方案肯定也是不可能的，因此直接就break跳出循环不需要往下搜了。&lt;/p>
&lt;p>&lt;del>不过就算加了这么多优化我还是T了三个点，直接 O&lt;!-- raw HTML omitted -->2&lt;!-- raw HTML omitted -->一开跑路了嘿嘿&lt;/del>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h4 id="代码实现-1">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">70&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> n,a[maxn],temp,icnt&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> totlen,maxlen,cnt;
&lt;span style="color:#66d9ef">bool&lt;/span> vis[maxn],finish;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">cmp&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a,&lt;span style="color:#66d9ef">int&lt;/span> b)
{
&lt;span style="color:#66d9ef">return&lt;/span> a&lt;span style="color:#f92672">&amp;gt;&lt;/span>b;
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> nowcnt,&lt;span style="color:#66d9ef">int&lt;/span> nxt,&lt;span style="color:#66d9ef">int&lt;/span> lenlast,&lt;span style="color:#66d9ef">int&lt;/span> len)
&lt;span style="color:#75715e">//nowcnt:现在正在拼接第几根
&lt;/span>&lt;span style="color:#75715e">//nxt:我们应该从哪里开始检索
&lt;/span>&lt;span style="color:#75715e">//lenlast:现在拼接还需要多少才能拼接完成
&lt;/span>&lt;span style="color:#75715e">//len:每根木棍的理想长度
&lt;/span>&lt;span style="color:#75715e">&lt;/span>{
&lt;span style="color:#66d9ef">if&lt;/span>(lenlast&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span>(lenlast&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
{
&lt;span style="color:#75715e">// printf(&amp;#34;test\n&amp;#34;);
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(nowcnt&lt;span style="color:#f92672">==&lt;/span>cnt)
{
printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,len);
finish&lt;span style="color:#f92672">=&lt;/span>true;
&lt;span style="color:#66d9ef">return&lt;/span> ;
}
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(p&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;p&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;p&lt;span style="color:#f92672">++&lt;/span>) &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>vis[p]) &lt;span style="color:#66d9ef">break&lt;/span>;
vis[p]&lt;span style="color:#f92672">=&lt;/span>true;
dfs(nowcnt&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,p&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,len&lt;span style="color:#f92672">-&lt;/span>a[p],len);
&lt;span style="color:#66d9ef">if&lt;/span>(finish) &lt;span style="color:#66d9ef">return&lt;/span> ;
vis[p]&lt;span style="color:#f92672">=&lt;/span>false;
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
&lt;span style="color:#66d9ef">int&lt;/span> pos&lt;span style="color:#f92672">=&lt;/span>lower_bound(a&lt;span style="color:#f92672">+&lt;/span>nxt,a&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>n,lenlast,greater&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>())&lt;span style="color:#f92672">-&lt;/span>a;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>pos;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#75715e">// printf(&amp;#34;what\n&amp;#34;);
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>vis[i]&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>lenlast&lt;span style="color:#f92672">-&lt;/span>a[i]&lt;span style="color:#f92672">&amp;gt;=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
{
vis[i]&lt;span style="color:#f92672">=&lt;/span>true;
dfs(nowcnt,i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,lenlast&lt;span style="color:#f92672">-&lt;/span>a[i],len);
&lt;span style="color:#66d9ef">if&lt;/span>(finish) &lt;span style="color:#66d9ef">return&lt;/span>;
vis[i]&lt;span style="color:#f92672">=&lt;/span>false;
&lt;span style="color:#66d9ef">while&lt;/span>(a[i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">==&lt;/span>a[i]) i&lt;span style="color:#f92672">++&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span>(i&lt;span style="color:#f92672">==&lt;/span>n) &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span>(lenlast&lt;span style="color:#f92672">-&lt;/span>a[i]&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">break&lt;/span>;
}
}
}
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
&lt;span style="color:#75715e">// freopen(&amp;#34;test.in&amp;#34;,&amp;#34;r&amp;#34;,stdin);
&lt;/span>&lt;span style="color:#75715e">&lt;/span> scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>temp);
&lt;span style="color:#66d9ef">if&lt;/span>(temp&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#ae81ff">50&lt;/span>) a[i]&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">else&lt;/span> a[i]&lt;span style="color:#f92672">=&lt;/span>temp;
maxlen&lt;span style="color:#f92672">=&lt;/span>max(maxlen,a[i]);
totlen&lt;span style="color:#f92672">+=&lt;/span>a[i];
}
sort(a&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,a&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>n,cmp);
&lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>a[n]) n&lt;span style="color:#f92672">--&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> l&lt;span style="color:#f92672">=&lt;/span>maxlen;l&lt;span style="color:#f92672">&amp;lt;=&lt;/span>totlen;l&lt;span style="color:#f92672">++&lt;/span>)
{
finish&lt;span style="color:#f92672">=&lt;/span>false;
&lt;span style="color:#66d9ef">if&lt;/span>(totlen&lt;span style="color:#f92672">%&lt;/span>l&lt;span style="color:#f92672">!=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">continue&lt;/span>;
cnt&lt;span style="color:#f92672">=&lt;/span>totlen&lt;span style="color:#f92672">/&lt;/span>l;
vis[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">=&lt;/span>true;
dfs(&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>,l&lt;span style="color:#f92672">-&lt;/span>a[&lt;span style="color:#ae81ff">1&lt;/span>],l);
vis[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">=&lt;/span>false;
&lt;span style="color:#66d9ef">if&lt;/span>(finish) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="3-yokof---power-calculushttpswwwspojcomproblemsyokof">
3. &lt;a href="https://www.spoj.com/problems/YOKOF/">YOKOF - Power Calculus&lt;/a>
&lt;a class="heading-link" href="#3-yokof---power-calculushttpswwwspojcomproblemsyokof">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;hr>
&lt;h4 id="题意-2">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       给出一个正整数 &lt;strong>n&lt;/strong> ，只能使用乘法或者除法，可以乘除 $x$ 或者过程中产生的中间值 $x^i$ ，输出使得 $x$ 变为 $x^n$ 所需的最少步数。$(n\le100)$&lt;/p>
&lt;hr>
&lt;h4 id="思路-2">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       很显然我们一直是对指数进行操作，看似是乘除，直接转化为指数的加减。因此我们需要记录一个状态数组来记录乘除中间所产生的 $x^i$ ，以便后续过程中使用。但是这道题直接搜索的话，又会超时，因为他把大量的时间浪费在高深度上，但是这个却不一定是最优解。因此需要用到迭代加深搜索(IDDFS).&lt;/p>
&lt;blockquote>
&lt;p>迭代加深搜索(IDDFS)主要用于处理一些题目可能会搜到很深但是答案却不是最优的问题。有的时候dfs搜索的深度是无穷的，而且他的复杂度是呈指数级增长的，因此这其中某些情况就可以用IDDFS，在每次搜索的时候，我们给深度一个限制，当达到这个最大深度却没有得到答案的时候，就返回，然后逐步提升深度，这样我们就可以避免将时间浪费在那些无谓的高深度搜索上了。&lt;/p>
&lt;/blockquote>
&lt;p>$$
\sum_{i=0}^n2^i=2^{n+1}-1（指数级别增长实例）
$$&lt;/p>
&lt;hr>
&lt;h4 id="代码实现-2">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">int&lt;/span> n;
&lt;span style="color:#66d9ef">int&lt;/span> x[&lt;span style="color:#ae81ff">1005&lt;/span>]; &lt;span style="color:#75715e">//用来记录每次生成的中间状态
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> k,&lt;span style="color:#66d9ef">int&lt;/span> dep,&lt;span style="color:#66d9ef">int&lt;/span> maxdep)
{
&lt;span style="color:#66d9ef">if&lt;/span>(k&lt;span style="color:#f92672">&amp;lt;=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">||&lt;/span>dep&lt;span style="color:#f92672">&amp;gt;&lt;/span>maxdep&lt;span style="color:#f92672">||&lt;/span>k&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>(maxdep&lt;span style="color:#f92672">-&lt;/span>dep)&lt;span style="color:#f92672">&amp;lt;&lt;/span>n) &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;span style="color:#66d9ef">if&lt;/span>(k&lt;span style="color:#f92672">==&lt;/span>n&lt;span style="color:#f92672">||&lt;/span>k&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>(maxdep&lt;span style="color:#f92672">-&lt;/span>dep)&lt;span style="color:#f92672">==&lt;/span>n) &lt;span style="color:#66d9ef">return&lt;/span> true;
x[dep]&lt;span style="color:#f92672">=&lt;/span>k;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>dep;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(dfs(k&lt;span style="color:#f92672">+&lt;/span>x[i],dep&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,maxdep)) &lt;span style="color:#66d9ef">return&lt;/span> true; &lt;span style="color:#75715e">//对应乘法
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(dfs(k&lt;span style="color:#f92672">-&lt;/span>x[i],dep&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,maxdep)) &lt;span style="color:#66d9ef">return&lt;/span> true; &lt;span style="color:#75715e">//对应除法
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
x[dep]&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">return&lt;/span> false;
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
&lt;span style="color:#66d9ef">while&lt;/span>(scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n)&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>n)
{
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(dfs(&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">0&lt;/span>,i))
{
printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,i);
&lt;span style="color:#66d9ef">break&lt;/span>;
}
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr></description></item></channel></rss>