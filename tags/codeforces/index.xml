<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Codeforces on Zs's Blog</title><link>https://zzsqwq.github.io/tags/codeforces/</link><description>Recent content in Codeforces on Zs's Blog</description><generator>Hugo -- gohugo.io</generator><language>cn</language><lastBuildDate>Wed, 19 Feb 2020 01:02:00 +0000</lastBuildDate><atom:link href="https://zzsqwq.github.io/tags/codeforces/index.xml" rel="self" type="application/rss+xml"/><item><title>Codeforces#620 (Div.2)</title><link>https://zzsqwq.github.io/posts/30/</link><pubDate>Wed, 19 Feb 2020 01:02:00 +0000</pubDate><guid>https://zzsqwq.github.io/posts/30/</guid><description>&lt;h2 id="a-two-rabbitshttpscodeforcescomcontest1304problema">
A. &lt;a href="https://codeforces.com/contest/1304/problem/A">Two Rabbits&lt;/a>
&lt;a class="heading-link" href="#a-two-rabbitshttpscodeforcescomcontest1304problema">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    两个兔子分别位于 $(x,0)$ 和 $(y,0)$ ，两个人对头蹦，前者往前蹦 $a$ ，后者往前蹦 $b$ ，问两人是否能恰好相遇。&lt;/p>
&lt;h3 id="思路">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    算一下两个人直接得距离 $s$ ，每次两者距离减少 $a+b$ ，看 $s$ 是否能被 $a+b$ 整除，如果可以就能够相遇。&lt;/p>
&lt;h3 id="代码实现">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">int&lt;/span> t;
&lt;span style="color:#66d9ef">int&lt;/span> x,y,a,b;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>x,&lt;span style="color:#f92672">&amp;amp;&lt;/span>y,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a,&lt;span style="color:#f92672">&amp;amp;&lt;/span>b);
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>a&lt;span style="color:#f92672">+&lt;/span>b;
&lt;span style="color:#66d9ef">int&lt;/span> f&lt;span style="color:#f92672">=&lt;/span>y&lt;span style="color:#f92672">-&lt;/span>x;
&lt;span style="color:#66d9ef">if&lt;/span>(f&lt;span style="color:#f92672">%&lt;/span>p&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
{
printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,f&lt;span style="color:#f92672">/&lt;/span>p);
}
&lt;span style="color:#66d9ef">else&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;-1&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;h2 id="b-longest-palindromehttpscodeforcescomcontest1304problemb">
B. &lt;a href="https://codeforces.com/contest/1304/problem/B">Longest Palindrome&lt;/a>
&lt;a class="heading-link" href="#b-longest-palindromehttpscodeforcescomcontest1304problemb">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-1">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    给出 $n$ 段长度为 $m$ 的字符串，从中挑选出一些组成最长的回文字串，输出这个回文子串的长度和内容，如果有多种情况输出一种即可。如果没有符合的，就输出0 。$(1\le n\le 100,1\le m\le 50)$&lt;/p>
&lt;h3 id="思路-1">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    因为这个数据规模非常小，所以 $O(n^2m)$ 也是可以接受的（说实话我不是很会算，大概是个差不多的式子），那么我们可以选择暴力匹配，用每个字符串去匹配后面的，如果是两个互为回文串，那么就把其中任何一个计入到sub字符串中，然后用一个 vis 数组来标记他们两个已经被使用过了，最终一个字符串匹配完后面所有的发现没有合适的，那么就考虑他自己是不是一个回文串，如果是一个回文串，单独标记它是放在中间。最后我们的sub是存放了一半回文串。
​    统计答案的时候，先将sub加到答案ans中，检查一下是否中间有合适的回文串，如果有的话也加到ans里面，最后讲sub逆序一下，加到ans里面。最终输出答案的时候，看一下ans是不是空串，如果是空串，就输出0，否则输出长度和ans。（string是真的好用！！！）&lt;/p>
&lt;h3 id="代码实现-1">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">105&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> n,m;
string ans,sub,mid;
&lt;span style="color:#66d9ef">bool&lt;/span> ifmid;
string str[maxn];
&lt;span style="color:#66d9ef">bool&lt;/span> vis[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>m);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>) cin&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>str[i];
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;j&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(vis[j]) &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;span style="color:#66d9ef">bool&lt;/span> flag&lt;span style="color:#f92672">=&lt;/span>true;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> k&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;k&lt;span style="color:#f92672">&amp;lt;&lt;/span>m;k&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(str[i][k]&lt;span style="color:#f92672">==&lt;/span>str[j][m&lt;span style="color:#f92672">-&lt;/span>k&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>])
{
&lt;span style="color:#66d9ef">continue&lt;/span>;
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
flag&lt;span style="color:#f92672">=&lt;/span>false;
&lt;span style="color:#66d9ef">break&lt;/span>;
}
}
&lt;span style="color:#66d9ef">if&lt;/span>(flag)
{
vis[i]&lt;span style="color:#f92672">=&lt;/span>vis[j]&lt;span style="color:#f92672">=&lt;/span>true;
sub&lt;span style="color:#f92672">+=&lt;/span>str[i];
}
}
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>vis[i])
{
&lt;span style="color:#66d9ef">bool&lt;/span> flag&lt;span style="color:#f92672">=&lt;/span>true;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;&lt;/span>m;j&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(str[i][j]&lt;span style="color:#f92672">!=&lt;/span>str[i][m&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">-&lt;/span>j])
{
flag&lt;span style="color:#f92672">=&lt;/span>false;
&lt;span style="color:#66d9ef">break&lt;/span>;
}
}
&lt;span style="color:#66d9ef">if&lt;/span>(flag)
{
mid&lt;span style="color:#f92672">=&lt;/span>str[i];
ifmid&lt;span style="color:#f92672">=&lt;/span>true;
}
}
}
ans&lt;span style="color:#f92672">+=&lt;/span>sub;
reverse(sub.begin(),sub.end());
&lt;span style="color:#66d9ef">if&lt;/span>(ifmid) ans&lt;span style="color:#f92672">+=&lt;/span>mid;
ans&lt;span style="color:#f92672">+=&lt;/span>sub;
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>ans.empty())
{
cout&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>ans.length()&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>endl&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>ans;
}
&lt;span style="color:#66d9ef">else&lt;/span> cout&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;h2 id="c-air-conditionerhttpscodeforcescomcontest1304problemc">
C. &lt;a href="https://codeforces.com/contest/1304/problem/C">Air Conditioner&lt;/a>
&lt;a class="heading-link" href="#c-air-conditionerhttpscodeforcescomcontest1304problemc">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-2">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    餐厅老板有一个空调，餐厅初始温度为 $m$ ，会陆续来 $n$ 个顾客。餐厅老板每分钟可以控制空调的温度+1，-1，或者是不变。这 $n$ 个顾客会按来的时间顺序给出，每个人有一个感到舒适的温度范围，如果空调的温度在这个范围里面，那么顾客就会满意。问餐厅老板是否可以达到让每个人都满意。&lt;/p>
&lt;h3 id="思路-2">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    首先我们先思考从餐厅开始到第一个客人来临的时候，假设第一个人来临的时间是 $t$ ，舒适区间为 $[l,r]$，那么我们可以很容易发现只要 $[l,r]$ 与 $[m-t,m+t]$ 有交集，那么就是可以满足第一个客人条件。如果第二个和第一人的时间差为 $\Delta t$ ，那么这个时候要计算可达到的舒适区间就是在上次交集的区间上左右变化 $\Delta t$ ，为什么是交集呢。我一开始想错了。。一直写成并集，然后一直调不出来。但实际上不是这样的，我们可以理解为只有交集那部分才是符合上个顾客要求的，如果超出那个范围，就不能够满足上个顾客要求。所以挨个顾客扫一遍就行了。&lt;/p>
&lt;h3 id="代码实现-2">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">int&lt;/span> q,n,m;
&lt;span style="color:#66d9ef">int&lt;/span> last,l,h,t;
&lt;span style="color:#66d9ef">int&lt;/span> nowl,nowr,delt;
&lt;span style="color:#66d9ef">int&lt;/span> lef,righ;
&lt;span style="color:#66d9ef">bool&lt;/span> flag;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>q);
&lt;span style="color:#66d9ef">while&lt;/span>(q&lt;span style="color:#f92672">--&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>m);
lef&lt;span style="color:#f92672">=&lt;/span>righ&lt;span style="color:#f92672">=&lt;/span>m;
last&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
flag&lt;span style="color:#f92672">=&lt;/span>true;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t,&lt;span style="color:#f92672">&amp;amp;&lt;/span>l,&lt;span style="color:#f92672">&amp;amp;&lt;/span>h);
delt&lt;span style="color:#f92672">=&lt;/span>t&lt;span style="color:#f92672">-&lt;/span>last;
nowl&lt;span style="color:#f92672">=&lt;/span>lef&lt;span style="color:#f92672">-&lt;/span>delt;
nowr&lt;span style="color:#f92672">=&lt;/span>righ&lt;span style="color:#f92672">+&lt;/span>delt;
last&lt;span style="color:#f92672">=&lt;/span>t;
&lt;span style="color:#66d9ef">if&lt;/span>(nowl&lt;span style="color:#f92672">&amp;gt;&lt;/span>h&lt;span style="color:#f92672">||&lt;/span>nowr&lt;span style="color:#f92672">&amp;lt;&lt;/span>l) flag&lt;span style="color:#f92672">=&lt;/span>false;
&lt;span style="color:#66d9ef">else&lt;/span>
{
lef&lt;span style="color:#f92672">=&lt;/span>max(nowl,l);
righ&lt;span style="color:#f92672">=&lt;/span>min(nowr,h);
}
}
&lt;span style="color:#66d9ef">if&lt;/span>(flag)
{
printf(&lt;span style="color:#e6db74">&amp;#34;YES&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">else&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;NO&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
}
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>杂题训练</title><link>https://zzsqwq.github.io/posts/27/</link><pubDate>Sat, 15 Feb 2020 00:52:00 +0000</pubDate><guid>https://zzsqwq.github.io/posts/27/</guid><description>&lt;h2 id="a-配对httpsacnowcodercomacmcontest3007a">
A. &lt;a href="https://ac.nowcoder.com/acm/contest/3007/A">配对&lt;/a>
&lt;a class="heading-link" href="#a-%e9%85%8d%e5%af%b9httpsacnowcodercomacmcontest3007a">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    给定含有 $n$ 个正整数的集合 $A$ 和 $B$ ，你需要建立他们之间的一一映射。将配对的两个数相加可以得到 $n$ 个和，问第 $k$ 大的和最大为多少。&lt;/p>
&lt;h3 id="思路">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    首先我们可以确定，组成前 $k$ 个最大的和一定用的是两个序列里面前 $k$ 大的数字。那么我们只需要知道如何配对能使第 $k$ 大的和最大。我们把问题简化一下如果 $A_1 &amp;lt; A_2$ ，$B_1 &amp;lt; B_2$ ，那么如果想要第二个和最大，肯定是需要 $A_1$ 和 $B_2$ 匹配，$A_2$ 和 $B_1$ 匹配，然后两个选一个最小的。所以这个问题我们类推一下，就是将 $A$ 和 $B$ 序列进行排序，然后取两个里面前 $k$ 个数，$A$ 中大的依次匹配 $B$ 中小的。然后在这 $k$ 个和中取一个最小值即可。&lt;/p>
&lt;h3 id="代码实现">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1e5&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> a[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> b[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> n,k,ans&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1e9&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">7&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">cmp&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a,&lt;span style="color:#66d9ef">int&lt;/span> b)
{
&lt;span style="color:#66d9ef">return&lt;/span> a&lt;span style="color:#f92672">&amp;gt;&lt;/span>b;
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>k);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i]);
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>b[i]);
}
sort(a&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,a&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>n,cmp);
sort(b&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,b&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>n,cmp);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>k;i&lt;span style="color:#f92672">++&lt;/span>)
{
ans&lt;span style="color:#f92672">=&lt;/span>min(ans,a[i]&lt;span style="color:#f92672">+&lt;/span>b[k&lt;span style="color:#f92672">-&lt;/span>i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]);
}
printf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,ans);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;h2 id="b-十字阵列httpsacnowcodercomacmcontest3007f">
B. &lt;a href="https://ac.nowcoder.com/acm/contest/3007/F">十字阵列&lt;/a>
&lt;a class="heading-link" href="#b-%e5%8d%81%e5%ad%97%e9%98%b5%e5%88%97httpsacnowcodercomacmcontest3007f">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-1">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    给定一个 $n\times m$ 的网格，每一个交点都一个敌人。你可以使用共 $h$ 次魔法，第 $i$ 次魔法能对第 $x_i$ 行和第 $y_i$ 列的所有敌人造成 $w_i$ 点伤害，交界点的伤害只计算一次。。如果施放完所有所有魔法后，如果一个点 $(i,j)$ 共受到 $z_i$ 点伤害，问 $\sum{z_i(i+j)}$ 为多少。&lt;/p>
&lt;h3 id="思路-1">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    无脑的计数题QAQ..真的是水题啊，我们只需要给每次魔法施放的 $w_i$ 乘上一个 $(i,j)$ 即可，但是因为是一行一列都会变化，那么其实我们可以优化一下，先把一行一列的 $\sum(i+j)$ 给求出来，然后施法的时候直接乘上这个常数就可以了。（这个题还有个很神奇的地方就是，我明明算的不会爆int然后开的int，然后就错了，后来一直找问题没找出来，后来全改成long long就AC了，太奇怪了。。）&lt;/p>
&lt;h3 id="代码实现-1">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2005&lt;/span>;
&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> ll;
&lt;span style="color:#66d9ef">int&lt;/span> mod &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1e9&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">7&lt;/span>;
ll row[maxn];
ll col[maxn];
ll x,y,z;
ll n,m,h;
ll ans,now;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%lld%lld%lld&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>m,&lt;span style="color:#f92672">&amp;amp;&lt;/span>h);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
row[i]&lt;span style="color:#f92672">=&lt;/span>(m&lt;span style="color:#f92672">*&lt;/span>i)&lt;span style="color:#f92672">%&lt;/span>mod&lt;span style="color:#f92672">+&lt;/span>(m)&lt;span style="color:#f92672">*&lt;/span>(m&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
row[i]&lt;span style="color:#f92672">%=&lt;/span>mod;
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>m;j&lt;span style="color:#f92672">++&lt;/span>)
{
col[j]&lt;span style="color:#f92672">=&lt;/span>(n&lt;span style="color:#f92672">*&lt;/span>j)&lt;span style="color:#f92672">%&lt;/span>mod&lt;span style="color:#f92672">+&lt;/span>(n)&lt;span style="color:#f92672">*&lt;/span>(n&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
col[j]&lt;span style="color:#f92672">%=&lt;/span>mod;
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>h;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%lld%lld%lld&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>x,&lt;span style="color:#f92672">&amp;amp;&lt;/span>y,&lt;span style="color:#f92672">&amp;amp;&lt;/span>z);
now&lt;span style="color:#f92672">=&lt;/span>((row[x]&lt;span style="color:#f92672">+&lt;/span>col[y]&lt;span style="color:#f92672">-&lt;/span>(x&lt;span style="color:#f92672">+&lt;/span>y))&lt;span style="color:#f92672">%&lt;/span>mod)&lt;span style="color:#f92672">*&lt;/span>(z&lt;span style="color:#f92672">%&lt;/span>mod);
now&lt;span style="color:#f92672">%=&lt;/span>mod;
ans&lt;span style="color:#f92672">+=&lt;/span>now;
ans&lt;span style="color:#f92672">%=&lt;/span>mod;
}
printf(&lt;span style="color:#e6db74">&amp;#34;%lld&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,ans);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;h2 id="c-垃圾陷阱httpswwwluogucomcnproblemp1156">
C. &lt;a href="https://www.luogu.com.cn/problem/P1156">垃圾陷阱&lt;/a>
&lt;a class="heading-link" href="#c-%e5%9e%83%e5%9c%be%e9%99%b7%e9%98%b1httpswwwluogucomcnproblemp1156">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-2">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    奶牛卡门想要从垃圾井底上到地面，对于一个垃圾它可以吃掉，或者是堆起来。初始卡门有10个小时的能量，吃掉一个垃圾会给他提供 $f_i$ 个小时的能量，叠起来一个垃圾会获得 $h_i$ 点高度，当垃圾总高度超过井的深度 $D$ 的时候，卡门就能上到地面。一个垃圾当 $t_i$ 小时时会到达井底。给出所有垃圾的状态，问奶牛能否到达地面。&lt;/p>
&lt;h3 id="思路-2">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​ &lt;del>   这个题面被我翻译的屎一样，QAQ，如果看不懂还是去看原题叭。。&lt;/del>
​    这是一个类似于背包的题，对于一个垃圾，我们有两种选择，一个是吃掉它，一个是把他堆起来。。这个状态其实我没找好，看了题解发现可以设 $f[i][j]$ 来表示当用了前 $i$ 个垃圾时，当高度为 $j$ 的时候的最大的体力值（体力值就是还能继续活动多长时间）。我们用结构体数组 $a$ 来表示垃圾，写出如下转移方程。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果选择把这个垃圾吃掉，那么 $f[i][j]=max(f[i-1][j]+a[i].f,f[i][j])$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果选择把这个垃圾搭起来，那么$f[i][j+a[i].h]=max(f[i-1][j+a[i].h],f[i-1][j])$&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>​    我们发现边界就是 $f[0][0]=10$ ，也就是用了0个垃圾，高度为0的时候体力值为10。&lt;/p>
&lt;p>​    注意一个地方我们如果到达了地面，就直接输出时间，然后退出程序即可，如果没有的话，我们可以选择遍历每一个垃圾下的 $0$ 高度，也就是说所有垃圾都不叠是最长的寿命，所以输出一个其中的最大值即可。&lt;/p>
&lt;h3 id="代码实现-2">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">105&lt;/span>;
&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">node&lt;/span>
{
&lt;span style="color:#66d9ef">int&lt;/span> t,f,h;
}a[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">cmp&lt;/span>(node a,node b)
{
&lt;span style="color:#66d9ef">return&lt;/span> a.t&lt;span style="color:#f92672">&amp;lt;&lt;/span>b.t;
}
&lt;span style="color:#66d9ef">int&lt;/span> d,g;
&lt;span style="color:#66d9ef">int&lt;/span> dp[maxn][maxn]; &lt;span style="color:#75715e">//dp[i][j] 用i个垃圾，当高度为j时所具备的最高生命值
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
freopen(&lt;span style="color:#e6db74">&amp;#34;test.in&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;r&amp;#34;&lt;/span>,stdin);
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>d,&lt;span style="color:#f92672">&amp;amp;&lt;/span>g);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>g;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i].t,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i].f,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i].h);
}
sort(a&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,a&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>g,cmp);
memset(dp,&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#66d9ef">sizeof&lt;/span>(dp));
dp[&lt;span style="color:#ae81ff">0&lt;/span>][&lt;span style="color:#ae81ff">0&lt;/span>]&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>g;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>d;j&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(dp[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][j]&lt;span style="color:#f92672">&amp;gt;=&lt;/span>a[i].t)
{
&lt;span style="color:#66d9ef">if&lt;/span>(j&lt;span style="color:#f92672">+&lt;/span>a[i].h&lt;span style="color:#f92672">&amp;gt;=&lt;/span>d)
{
printf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,a[i].t);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
dp[i][j]&lt;span style="color:#f92672">=&lt;/span>max(dp[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][j]&lt;span style="color:#f92672">+&lt;/span>a[i].f,dp[i][j]);
dp[i][j&lt;span style="color:#f92672">+&lt;/span>a[i].h]&lt;span style="color:#f92672">=&lt;/span>max(dp[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][j&lt;span style="color:#f92672">+&lt;/span>a[i].h],dp[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][j]);
}
}
}
&lt;span style="color:#66d9ef">int&lt;/span> ans&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>g;i&lt;span style="color:#f92672">++&lt;/span>) ans&lt;span style="color:#f92672">=&lt;/span>max(ans,dp[i][&lt;span style="color:#ae81ff">0&lt;/span>]);
printf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,ans);
}
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Codeforces#619 (Div.2)</title><link>https://zzsqwq.github.io/posts/26/</link><pubDate>Fri, 14 Feb 2020 00:51:00 +0000</pubDate><guid>https://zzsqwq.github.io/posts/26/</guid><description>&lt;h2 id="a-three-stringshttpscodeforcescomcontest1301problema">
A. &lt;a href="https://codeforces.com/contest/1301/problem/A">Three Strings&lt;/a>
&lt;a class="heading-link" href="#a-three-stringshttpscodeforcescomcontest1301problema">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    给定三个长度为 $n$ 的字符串 $a$ , $b$ , $c$ ，遍历每个 $c$ 中每个字符 $c_i$，可以将其替换成 $a_i$ 或者 $b_i$ ，必须操作其中一个，问能否通过此操作使得字符串 $a$ , $b$ 相同。&lt;/p>
&lt;h3 id="思路">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    仔细思考一下，如果要使得最终两个字符串相同的话，必须字符串 $c$ 中出现的字符，在 $a$ 或者 $b$ 字符串出现过，如果每个位置都出现过，那么就是可以的，否则不行。&lt;/p>
&lt;h3 id="代码实现">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">105&lt;/span>;
&lt;span style="color:#66d9ef">char&lt;/span> a[maxn],b[maxn],c[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> t;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%s&amp;#34;&lt;/span>,a);
scanf(&lt;span style="color:#e6db74">&amp;#34;%s&amp;#34;&lt;/span>,b);
scanf(&lt;span style="color:#e6db74">&amp;#34;%s&amp;#34;&lt;/span>,c);
&lt;span style="color:#66d9ef">int&lt;/span> len&lt;span style="color:#f92672">=&lt;/span>strlen(c);
&lt;span style="color:#66d9ef">bool&lt;/span> flag&lt;span style="color:#f92672">=&lt;/span>true;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;&lt;/span>len;i&lt;span style="color:#f92672">++&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span>(c[i]&lt;span style="color:#f92672">!=&lt;/span>a[i]&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>c[i]&lt;span style="color:#f92672">!=&lt;/span>b[i])
{
flag&lt;span style="color:#f92672">=&lt;/span>false;
}
&lt;span style="color:#66d9ef">if&lt;/span>(flag)
{
printf(&lt;span style="color:#e6db74">&amp;#34;YES&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">else&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;NO&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;h2 id="b-motaracks-birthdayhttpscodeforcescomcontest1301problemb">
B. &lt;a href="https://codeforces.com/contest/1301/problem/B">Motarack&amp;rsquo;s Birthday&lt;/a>
&lt;a class="heading-link" href="#b-motaracks-birthdayhttpscodeforcescomcontest1301problemb">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-1">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    给定一个含有 $n$ 个整数的序列 $a$ ，其中有一些数丢失，问将丢失的数赋值为多少才能使得相邻两数之差的绝对值的最大值的最小。&lt;/p>
&lt;h3 id="思路-1">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    我们想一下首先不缺失的数相邻两数之差是一定，无论赋值前后都不影响。而如果两个相邻的数都缺失的话，那么他们之间差的绝对值一定是0，也不用去看。这样的话我们就看一下，不缺失和缺失两数之间差的绝对值如何能够最小。因为最终所有的缺失的数都是赋值为同一个数，所以我们考虑一下发现需要考虑一下 缺失和不缺失的数相邻的时候，不缺失的那个数的最大值和最小值，我们只需要取他们的和的平均，那么绝对值就可以最小了。所以最终我们就把缺失的值赋为两数均值，然后求一遍相邻数之差绝对值的最大值就好了。（好像这道题难点不是思路，而是实现起来有很多边界等乱七八糟的要自习考虑一下。）&lt;/p>
&lt;h3 id="代码实现-1">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">100005&lt;/span>;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> inf&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1000000000&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> n,t;
&lt;span style="color:#66d9ef">int&lt;/span> a[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> minn,maxx,ans,anss;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
minn&lt;span style="color:#f92672">=&lt;/span>inf,maxx&lt;span style="color:#f92672">=-&lt;/span>inf,anss&lt;span style="color:#f92672">=-&lt;/span>inf;
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i]);
&lt;span style="color:#66d9ef">if&lt;/span>(i&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>a[i]&lt;span style="color:#f92672">==-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>a[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">!=-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
{
minn&lt;span style="color:#f92672">=&lt;/span>min(minn,a[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]);
maxx&lt;span style="color:#f92672">=&lt;/span>max(maxx,a[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]);
}
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(i&lt;span style="color:#f92672">&amp;lt;&lt;/span>n&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>a[i]&lt;span style="color:#f92672">==-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>a[i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">!=-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
{
minn&lt;span style="color:#f92672">=&lt;/span>min(minn,a[i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]);
maxx&lt;span style="color:#f92672">=&lt;/span>max(maxx,a[i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]);
}
}
ans&lt;span style="color:#f92672">=&lt;/span>(minn&lt;span style="color:#f92672">+&lt;/span>maxx)&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(a[i]&lt;span style="color:#f92672">==-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) a[i]&lt;span style="color:#f92672">=&lt;/span>ans;
&lt;span style="color:#66d9ef">if&lt;/span>(i&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) anss&lt;span style="color:#f92672">=&lt;/span>max(anss,abs(a[i]&lt;span style="color:#f92672">-&lt;/span>a[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]));
}
printf(&lt;span style="color:#e6db74">&amp;#34;%d %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,anss,ans);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;h2 id="c-ayoubs-functionhttpscodeforcescomcontest1301problemc">
C. &lt;a href="https://codeforces.com/contest/1301/problem/C">Ayoub&amp;rsquo;s function&lt;/a>
&lt;a class="heading-link" href="#c-ayoubs-functionhttpscodeforcescomcontest1301problemc">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-2">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    给定一个01字符串 $s$ ，其中含有 $m$ 个1，用 $f(s)$ 来表示字符串 $s$ 的有多少个字串其中含有1，求出符合条件的字符串 $s$ 中， $f(s)$ 的最大值是多少。&lt;/p>
&lt;h3 id="思路-2">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    这题正着想不太好想，含有1的子串可以有很多种情况，但是正难则反，我们可以求出不含1的字串有多少情况，也就是全0的字串有多少种情况，然后用所有情况减去这个就行。
​    首先可以发现字符串 $s$ 一共有 $\binom{n}{2}+n$ 种连续子串，那么如果一些0是连续的，那么好比有连续 $l$ 个0的话，我们可以发现他是有 $\binom{l}{2}+l$ 种情况的。这个字符串一共是含有 $n-m$ 个0的，现在我们思考一下如何摆放这 $(n-m)$ 个0，才能使得 $f(s)$ 最大。那么如果 $f(s)$ 要尽量大，也就是说全0对应的情况就要尽可能的少，所以我们需要将这 $n-m$ 尽可能的均分成 $m+1$ 份，类似于排列组合的插空法，将他们插到其中，但是我们发现有很大的可能是不能均分的，也就是说可能会有余数，那么我们就把余数均匀的分给前面余数个空，这样其实每个多贡献了 $(n-m)/(m+1) +1 $ 个。所以答案也就不难写出来了。不过不要忘了开long long。&lt;/p>
&lt;h3 id="代码实现-2">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> ll;
ll n,m;
ll t;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%lld&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%lld%lld&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>m);
ll sum&lt;span style="color:#f92672">=&lt;/span>n&lt;span style="color:#f92672">*&lt;/span>(n&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
ll p&lt;span style="color:#f92672">=&lt;/span>n&lt;span style="color:#f92672">-&lt;/span>m;
ll mod&lt;span style="color:#f92672">=&lt;/span>p&lt;span style="color:#f92672">%&lt;/span>(m&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
ll k&lt;span style="color:#f92672">=&lt;/span>p&lt;span style="color:#f92672">/&lt;/span>(m&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
printf(&lt;span style="color:#e6db74">&amp;#34;%lld&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,sum&lt;span style="color:#f92672">-&lt;/span>(m&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">*&lt;/span>k&lt;span style="color:#f92672">*&lt;/span>(k&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">-&lt;/span>(k&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">*&lt;/span>mod);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Codeforces #618 (Div.2)</title><link>https://zzsqwq.github.io/posts/22/</link><pubDate>Mon, 10 Feb 2020 00:39:00 +0000</pubDate><guid>https://zzsqwq.github.io/posts/22/</guid><description>&lt;h2 id="a-non-zerohttpscodeforcescomcontest1300problema">
A. &lt;a href="https://codeforces.com/contest/1300/problem/A">Non-zero&lt;/a>
&lt;a class="heading-link" href="#a-non-zerohttpscodeforcescomcontest1300problema">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​       给出一段含有 $n$ 个数的序列 $a$ ，可以对其中任何数加一，问最少操作多少次让每一个数和序列和都不为0。&lt;/p>
&lt;hr>
&lt;h3 id="思路">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​       输入的时候如果输入的是 $0$ 就将答案加一，最后如果序列和为 $0$ 的话答案加一。&lt;/p>
&lt;hr>
&lt;h3 id="代码实现">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">int&lt;/span> t,n,sum,p,ans;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
sum&lt;span style="color:#f92672">=&lt;/span>ans&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>p);
&lt;span style="color:#66d9ef">if&lt;/span>(p&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
{
ans&lt;span style="color:#f92672">++&lt;/span>;
sum&lt;span style="color:#f92672">+=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;span style="color:#66d9ef">else&lt;/span> sum&lt;span style="color:#f92672">+=&lt;/span>p;
}
&lt;span style="color:#66d9ef">if&lt;/span>(sum&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>) printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,ans&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;span style="color:#66d9ef">else&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,ans);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="b-assigning-to-classeshttpscodeforcescomcontest1300problemb">
B. &lt;a href="https://codeforces.com/contest/1300/problem/B">Assigning to Classes&lt;/a>
&lt;a class="heading-link" href="#b-assigning-to-classeshttpscodeforcescomcontest1300problemb">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-1">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​       将 $2n$ 个数分成个奇数序列，问两个奇数序列的中位数之差最小为多少。&lt;/p>
&lt;hr>
&lt;h3 id="思路-1">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​       直接就将序列排序然后输出中间两个数之差即可。&lt;/p>
&lt;hr>
&lt;h3 id="代码实现-1">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100005&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> t,n,a[maxn&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>];
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>n&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>p;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i]);
}
sort(a&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,a&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>p);
printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,abs(a[n]&lt;span style="color:#f92672">-&lt;/span>a[n&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]));
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="c-anu-has-a-functionhttpscodeforcescomcontest1300problemc">
C. &lt;a href="https://codeforces.com/contest/1300/problem/C">Anu Has a Function&lt;/a>
&lt;a class="heading-link" href="#c-anu-has-a-functionhttpscodeforcescomcontest1300problemc">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-2">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​       给出函数 $f: f(x,y)=(x|y)-y $ ，给出序列 $a$，序列 $a$ 中含有 $n$ 个数，可以表示为$[a_1,a_2\cdots,a_n ]$ ，定义 $x=f(f(&amp;hellip;f(f(a_1,a_2),a_3),&amp;hellip;a_{n-1}),a_n)$ ，你可以对序列 $a$ 中元素进行重排，求使得 $x$ 最大的序列 $a$ 。如果有多种情况，输出一种即可。&lt;/p>
&lt;h3 id="思路-2">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>第一种思路是因为 $f(x,y)=(x|y)-y$ ，我们可以发现对于经过这样的运算之后，如果 $x$ 的某一位是1，如果 $y$ 的相应位是0，那么运算出来的 $f(x,y)$ 对应位就是1，如果 $y$ 对应位是1，那么运算出来就是0。那么对于 $x$ 的计算过程中的每一位这个规律都是适应的。因此我们只需要将位数从高到低依次扫一遍，如果这个位数为1的情况在序列所有元素中只出现了一次，那么就将唯一出现1的那个数放到第一位即可。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第二种思路
$$
\because f(x,y)=(x|y) - y {\Longleftrightarrow} f(x,y) = x&amp;amp;({\sim} y)
\therefore x=(a_1)&amp;amp;({\sim}a_2)&amp;amp;({\sim} a_3){\cdots}({\sim}a_n)
$$
我们发现后面其实都是可交换的，所以第一个只有第一个是起决定作用的，那么我们就可以处理一个前缀和后缀的 and 数组，这样我们就可以 $O(1)$ 的计算出后面那部分，然后遍历序列 $a$ 找到最合适的 $a_1$。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="代码实现-2">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;h4 id="第一种思路">
第一种思路
&lt;a class="heading-link" href="#%e7%ac%ac%e4%b8%80%e7%a7%8d%e6%80%9d%e8%b7%af">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">100005&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> n,a[maxn],maxk;
&lt;span style="color:#66d9ef">int&lt;/span> cnt;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i]);
maxk&lt;span style="color:#f92672">=&lt;/span>max(maxk,a[i]);
}
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,k&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">while&lt;/span>(p&lt;span style="color:#f92672">&amp;lt;=&lt;/span>maxk)
{
k&lt;span style="color:#f92672">++&lt;/span>;
p&lt;span style="color:#f92672">&amp;lt;&amp;lt;=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>k;i&lt;span style="color:#f92672">&amp;gt;=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;i&lt;span style="color:#f92672">--&lt;/span>)
{
cnt&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;j&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(a[j]&lt;span style="color:#f92672">&amp;amp;&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>i))
{
cnt&lt;span style="color:#f92672">++&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span>(cnt&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) swap(a[j],a[&lt;span style="color:#ae81ff">1&lt;/span>]);
}
}
&lt;span style="color:#75715e">// printf(&amp;#34;%d %d\n&amp;#34;,i,cnt);
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(cnt&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
{
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;j&lt;span style="color:#f92672">++&lt;/span>)
{
printf(&lt;span style="color:#e6db74">&amp;#34;%d &amp;#34;&lt;/span>,a[j]);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
printf(&lt;span style="color:#e6db74">&amp;#34;%d &amp;#34;&lt;/span>,a[i]);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="第二种思路">
第二种思路
&lt;a class="heading-link" href="#%e7%ac%ac%e4%ba%8c%e7%a7%8d%e6%80%9d%e8%b7%af">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">100005&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> n,a[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> ans;
&lt;span style="color:#66d9ef">int&lt;/span> pre[maxn],suf[maxn]; &lt;span style="color:#75715e">//pre is prefix,suf is suffix
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i]);
a[i]&lt;span style="color:#f92672">=~&lt;/span>a[i];
&lt;span style="color:#66d9ef">if&lt;/span>(i&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) pre[i]&lt;span style="color:#f92672">=&lt;/span>a[i];
&lt;span style="color:#66d9ef">else&lt;/span> pre[i]&lt;span style="color:#f92672">=&lt;/span>pre[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i];
}
suf[n]&lt;span style="color:#f92672">=&lt;/span>a[n];
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;gt;=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">--&lt;/span>)
{
suf[i]&lt;span style="color:#f92672">=&lt;/span>suf[i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">&amp;amp;&lt;/span>a[i];
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>a[i];
p&lt;span style="color:#f92672">=~&lt;/span>a[i];
&lt;span style="color:#66d9ef">if&lt;/span>(i&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
{
&lt;span style="color:#66d9ef">int&lt;/span> now&lt;span style="color:#f92672">=&lt;/span>suf[i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">&amp;amp;&lt;/span>p;
ans&lt;span style="color:#f92672">=&lt;/span>max(ans,now);
}
&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(i&lt;span style="color:#f92672">==&lt;/span>n)
{
&lt;span style="color:#66d9ef">int&lt;/span> now&lt;span style="color:#f92672">=&lt;/span>pre[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">&amp;amp;&lt;/span>p;
&lt;span style="color:#66d9ef">if&lt;/span>(now&lt;span style="color:#f92672">&amp;gt;&lt;/span>ans)
{
swap(a[i],a[&lt;span style="color:#ae81ff">1&lt;/span>]);
ans&lt;span style="color:#f92672">=&lt;/span>now;
}
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
&lt;span style="color:#66d9ef">int&lt;/span> now&lt;span style="color:#f92672">=&lt;/span>pre[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">&amp;amp;&lt;/span>suf[i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">&amp;amp;&lt;/span>p;
&lt;span style="color:#66d9ef">if&lt;/span>(now&lt;span style="color:#f92672">&amp;gt;&lt;/span>ans)
{
swap(a[i],a[&lt;span style="color:#ae81ff">1&lt;/span>]);
ans&lt;span style="color:#f92672">=&lt;/span>now;
}
}
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
printf(&lt;span style="color:#e6db74">&amp;#34;%d &amp;#34;&lt;/span>,&lt;span style="color:#f92672">~&lt;/span>a[i]);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="d-aerodynamichttpscodeforcescomcontest1299problemb">
D. &lt;a href="https://codeforces.com/contest/1299/problem/B">Aerodynamic&lt;/a>
&lt;a class="heading-link" href="#d-aerodynamichttpscodeforcescomcontest1299problemb">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="题意-3">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​       给定一个凸多边形 $P$ 的所有顶点，可以将凸多边形沿向量 $(x,y)$ 平移，我们定义多边形 $T$ 是所有 $P$ 平移到与原点有交点后所构成的点集所形成的图形（我知道这句话有点绕，我实在是解释不明白，实在不行康康原题吧）。那么问这个 $T$ 是否是和 $P$ 相似的，如果是输出YES，不是输出NO。&lt;/p>
&lt;hr>
&lt;h3 id="思路-3">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​       就是判断这个图形是不是中心对称图形就行了，证明还不会，暂且放一下，会了再写QAQ..&lt;/p>
&lt;hr>
&lt;h3 id="代码实现-3">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">100005&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> n;
&lt;span style="color:#66d9ef">int&lt;/span> x[maxn],y[maxn];
&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">check&lt;/span>()
{
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>n&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
&lt;span style="color:#75715e">// printf(&amp;#34;%d&amp;#34;,p);
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> x1&lt;span style="color:#f92672">=&lt;/span>x[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">+&lt;/span>x[&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>p];
&lt;span style="color:#66d9ef">int&lt;/span> y1&lt;span style="color:#f92672">=&lt;/span>y[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">+&lt;/span>y[&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>p];
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>p;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(x1&lt;span style="color:#f92672">!=&lt;/span>x[i]&lt;span style="color:#f92672">+&lt;/span>x[i&lt;span style="color:#f92672">+&lt;/span>p]&lt;span style="color:#f92672">||&lt;/span>y1&lt;span style="color:#f92672">!=&lt;/span>y[i]&lt;span style="color:#f92672">+&lt;/span>y[i&lt;span style="color:#f92672">+&lt;/span>p])
{
&lt;span style="color:#66d9ef">return&lt;/span> false;
}
}
&lt;span style="color:#66d9ef">return&lt;/span> true;
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>x[i],&lt;span style="color:#f92672">&amp;amp;&lt;/span>y[i]);
}
&lt;span style="color:#66d9ef">if&lt;/span>(n&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
{
printf(&lt;span style="color:#e6db74">&amp;#34;NO&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
&lt;span style="color:#66d9ef">if&lt;/span>(check())
{
printf(&lt;span style="color:#e6db74">&amp;#34;YES&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">else&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;NO&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr></description></item><item><title>Codeforces#617(Div.3)</title><link>https://zzsqwq.github.io/posts/17/</link><pubDate>Wed, 05 Feb 2020 23:18:00 +0000</pubDate><guid>https://zzsqwq.github.io/posts/17/</guid><description>&lt;h3 id="a-array-with-odd-sumhttpscodeforcescomcontest1296problema">
A. &lt;a href="https://codeforces.com/contest/1296/problem/A">Array with Odd Sum&lt;/a>
&lt;a class="heading-link" href="#a-array-with-odd-sumhttpscodeforcescomcontest1296problema">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;hr>
&lt;h4 id="题意">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       给出包含 &lt;strong>n&lt;/strong> 个正整数的序列 &lt;strong>a&lt;/strong> ，你可以把任何一个元素 $a_i$ ，赋值给另一个元素 $a_j$ ($i\neq j$) ，问通过任意此操作能否将序列 &lt;strong>a&lt;/strong> 的和变为奇数。可以输出 &lt;strong>YES&lt;/strong> ,不可以输入 &lt;strong>NO&lt;/strong>.&lt;/p>
&lt;hr>
&lt;h4 id="思路">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       首先当起始和为奇数的时候，就直接可输出 &lt;strong>YES&lt;/strong> 了，如果是偶数的话，我们可以发现，如果序列元素中同时包含奇数和偶数，那么就是可以的，否则不可以。&lt;/p>
&lt;hr>
&lt;h4 id="代码实现">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">int&lt;/span> t,n,flag,sum,p,flag1,flag2;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
flag&lt;span style="color:#f92672">=&lt;/span>false;
flag2&lt;span style="color:#f92672">=&lt;/span>flag1&lt;span style="color:#f92672">=&lt;/span>false;
sum&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>p);
sum&lt;span style="color:#f92672">+=&lt;/span>p;
&lt;span style="color:#66d9ef">if&lt;/span>(p&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) flag1&lt;span style="color:#f92672">=&lt;/span>true;
&lt;span style="color:#66d9ef">if&lt;/span>(p&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>) flag2&lt;span style="color:#f92672">=&lt;/span>true;
}
&lt;span style="color:#66d9ef">if&lt;/span>(flag1&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>flag2) flag&lt;span style="color:#f92672">=&lt;/span>true;
&lt;span style="color:#66d9ef">if&lt;/span>(sum&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) printf(&lt;span style="color:#e6db74">&amp;#34;YES&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">else&lt;/span>
{
&lt;span style="color:#66d9ef">if&lt;/span>(flag) printf(&lt;span style="color:#e6db74">&amp;#34;YES&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">else&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;NO&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="b-food-buyinghttpscodeforcescomcontest1296problemb">
B. &lt;a href="https://codeforces.com/contest/1296/problem/B">Food Buying&lt;/a>
&lt;a class="heading-link" href="#b-food-buyinghttpscodeforcescomcontest1296problemb">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;hr>
&lt;h4 id="题意-1">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       初始有 &lt;strong>s&lt;/strong> 个货币，每次花费 &lt;strong>x&lt;/strong> 个货币会返还 $\lfloor{\frac{x}{10}}\rfloor$ 个货币，问最多共能花费多少货币。&lt;/p>
&lt;hr>
&lt;h4 id="思路-1">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       贪心即可。剩余的货币一直除10累加，注意最终剩余不足10的处理。&lt;/p>
&lt;hr>
&lt;h4 id="代码实现-1">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">int&lt;/span> t,s;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>s);
{
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>s;
&lt;span style="color:#66d9ef">int&lt;/span> now&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">while&lt;/span>(p)
{
&lt;span style="color:#66d9ef">if&lt;/span>(p&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>) &lt;span style="color:#66d9ef">break&lt;/span>;
now&lt;span style="color:#f92672">=&lt;/span>p&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>;
s&lt;span style="color:#f92672">+=&lt;/span>now;
p&lt;span style="color:#f92672">%=&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>;
p&lt;span style="color:#f92672">+=&lt;/span>now;
}
}
printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,s);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="c-yet-another-walking-robothttpscodeforcescomcontest1296problemc">
C. &lt;a href="https://codeforces.com/contest/1296/problem/C">Yet Another Walking Robot&lt;/a>
&lt;a class="heading-link" href="#c-yet-another-walking-robothttpscodeforcescomcontest1296problemc">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;hr>
&lt;h4 id="题意-2">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       一个机器人初始在 $(0,0)$ 点，规定 &lt;strong>&amp;lsquo;L&amp;rsquo;&lt;/strong> ，&lt;strong>&amp;lsquo;R&amp;rsquo;&lt;/strong> ，&lt;strong>&amp;lsquo;U&amp;rsquo;&lt;/strong> ，&lt;strong>&amp;lsquo;D&amp;rsquo;&lt;/strong> 分别对应向左，向右，向上和向下。给定一段包含上述字母的序列 &lt;strong>s&lt;/strong> ，机器人遵循指引序列移动。如果删除一段连续序列可使得机器人最终到达终点不变，问删除的最短序列的起始和终点为多少。&lt;/p>
&lt;hr>
&lt;h4 id="思路-2">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       想了半天想了错误的解法。。一直在考虑 &lt;strong>L&lt;/strong> 和 &lt;strong>R&lt;/strong> 数相等，&lt;strong>U&lt;/strong> 和 &lt;strong>D&lt;/strong> 相等，通过这个方法来找序列。看了题解才发现是通过坐标来看。我们可以开一个map记录坐标和步数的关系，从左到右扫序列，如果没有到达过这个坐标，就记录当前是第几次移动到达这个坐标的，如果到达过的话，就看上一次到达这个坐标时的步数，计算他们的序列长度，如果小于计算的就更新答案。因为是需要找最小的，因此只需要记录上一次到达的步数即可。&lt;/p>
&lt;hr>
&lt;h4 id="代码实现-2">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;hr>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;map&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">200005&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> t,n;
&lt;span style="color:#66d9ef">char&lt;/span> s[maxn];
&lt;span style="color:#66d9ef">bool&lt;/span> flag;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">int&lt;/span> l&lt;span style="color:#f92672">=-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,r&lt;span style="color:#f92672">=&lt;/span>n;
scanf(&lt;span style="color:#e6db74">&amp;#34;%s&amp;#34;&lt;/span>,s&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> pos; &lt;span style="color:#75715e">//first为x second为y
&lt;/span>&lt;span style="color:#75715e">&lt;/span> map&lt;span style="color:#f92672">&amp;lt;&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> last;
pos.first&lt;span style="color:#f92672">=&lt;/span>pos.second&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
last[pos]&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(s[i]&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#e6db74">&amp;#39;L&amp;#39;&lt;/span>) pos.first&lt;span style="color:#f92672">--&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span>(s[i]&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#e6db74">&amp;#39;R&amp;#39;&lt;/span>) pos.first&lt;span style="color:#f92672">++&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span>(s[i]&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#e6db74">&amp;#39;U&amp;#39;&lt;/span>) pos.second&lt;span style="color:#f92672">++&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span>(s[i]&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#e6db74">&amp;#39;D&amp;#39;&lt;/span>) pos.second&lt;span style="color:#f92672">--&lt;/span>;
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> if(i==2)
&lt;/span>&lt;span style="color:#75715e"> {
&lt;/span>&lt;span style="color:#75715e"> printf(&amp;#34;%d %d\n&amp;#34;,pos.first,pos.second);
&lt;/span>&lt;span style="color:#75715e"> }
&lt;/span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span>(last.count(pos)&lt;span style="color:#f92672">!=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
{
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>i&lt;span style="color:#f92672">-&lt;/span>last[pos];
&lt;span style="color:#75715e">// if(i==2) printf(&amp;#34;%d %d\n&amp;#34;,i,last[pos]);
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(p&lt;span style="color:#f92672">&amp;lt;&lt;/span>r&lt;span style="color:#f92672">-&lt;/span>l)
{
l&lt;span style="color:#f92672">=&lt;/span>last[pos];
r&lt;span style="color:#f92672">=&lt;/span>i;
}
&lt;span style="color:#75715e">// if(i==2 )printf(&amp;#34;%d %d\n&amp;#34;,l,r);
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
last[pos]&lt;span style="color:#f92672">=&lt;/span>i;
}
&lt;span style="color:#66d9ef">if&lt;/span>(l&lt;span style="color:#f92672">==-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
{
printf(&lt;span style="color:#e6db74">&amp;#34;-1&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
printf(&lt;span style="color:#e6db74">&amp;#34;%d %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,l&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,r);
}
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="d-fight-with-monstershttpscodeforcescomcontest1296problemd">
D. &lt;a href="https://codeforces.com/contest/1296/problem/D">Fight with Monsters&lt;/a>
&lt;a class="heading-link" href="#d-fight-with-monstershttpscodeforcescomcontest1296problemd">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;hr>
&lt;h4 id="题意-3">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       由你先手和对手轮流击打 $n$ 个血量为 $h_i$ 的小怪兽，你可以对怪物造成 $a$ 点伤害，对手可以造成 $b$ 点伤害。你有 $k$ 次机会使对手跳过他的回合。当小怪兽血量 $h\le0$ 时视为被击杀，当你击杀怪兽，你获得一分，当对手击杀，你不得分。求你最多能获得多少分数。&lt;/p>
&lt;hr>
&lt;h4 id="思路-3">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       先看一下对于每个怪兽我们要击杀需要花费多少机会，你和对手一个回合会击杀怪兽 $a+b$ 点血量，因此你可以一直将回合进行到怪兽血量小于$a+b$，接下来我们可以分两种情况讨论。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>怪兽血量为0，那么我们就需要回溯对手最后一个回合，然后需要使用的机会就是 $\lceil\frac{h_i}{a}\rceil$ 次&lt;/p>
&lt;/li>
&lt;li>
&lt;p>怪兽血量不为0，我们需要使用的机会就是 $\lceil\frac{h_i}{a}\rceil-1$ 次，注意这里不能直接写 $\lfloor\frac{h_i}{a}\rfloor$ 次，因为如果 $h_i$ 刚好能被 $a$ 整除，后面这个写法就错了。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>​       计算出了每个怪兽需要花费的机会那么就好做了，就变成了一个贪心问题，我们去尽可能得击杀需要的机会少的，当机会消耗完毕，得到的就是答案了。&lt;/p>
&lt;hr>
&lt;h4 id="代码实现-3">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">200005&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> n,a,b,k;
&lt;span style="color:#66d9ef">int&lt;/span> f[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">cmp&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a,&lt;span style="color:#66d9ef">int&lt;/span> b)
{
&lt;span style="color:#66d9ef">return&lt;/span> a&lt;span style="color:#f92672">&amp;lt;&lt;/span>b;
}
&lt;span style="color:#66d9ef">int&lt;/span> h[maxn],ans;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>a,&lt;span style="color:#f92672">&amp;amp;&lt;/span>b,&lt;span style="color:#f92672">&amp;amp;&lt;/span>k);
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>a&lt;span style="color:#f92672">+&lt;/span>b;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>h[i]);
h[i]&lt;span style="color:#f92672">%=&lt;/span>p;
&lt;span style="color:#66d9ef">if&lt;/span>(h[i]&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
{
h[i]&lt;span style="color:#f92672">+=&lt;/span>b;
f[i]&lt;span style="color:#f92672">=&lt;/span>ceil((&lt;span style="color:#66d9ef">double&lt;/span>)h[i]&lt;span style="color:#f92672">/&lt;/span>a);
}
&lt;span style="color:#66d9ef">else&lt;/span> f[i]&lt;span style="color:#f92672">=&lt;/span>ceil((&lt;span style="color:#66d9ef">double&lt;/span>)h[i]&lt;span style="color:#f92672">/&lt;/span>a)&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
}
sort(f&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,f&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>n,cmp);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(k&lt;span style="color:#f92672">-&lt;/span>f[i]&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">break&lt;/span>;
ans&lt;span style="color:#f92672">++&lt;/span>;
k&lt;span style="color:#f92672">-=&lt;/span>f[i];
}
printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,ans);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr></description></item><item><title>CodeforcesER #81</title><link>https://zzsqwq.github.io/posts/8/</link><pubDate>Sun, 02 Feb 2020 21:53:00 +0000</pubDate><guid>https://zzsqwq.github.io/posts/8/</guid><description>&lt;h3 id="a--display-the-numberhttpscodeforcescomcontest1295problema">
A : &lt;a href="https://codeforces.com/contest/1295/problem/A">Display The Number&lt;/a>
&lt;a class="heading-link" href="#a--display-the-numberhttpscodeforcescomcontest1295problema">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;h4 id="题意">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       用一定数目的灯管，显示尽可能大的数&lt;/p>
&lt;p>&lt;img src="https://s2.ax1x.com/2020/02/02/1te6Re.md.png" alt="A">&lt;/p>
&lt;h4 id="思路">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       因为位数多的肯定更大，所以肯定用尽量少的灯管搭建单个数字更好，最少的两个分别是两个灯管显示的1，以及三个灯管显示的7，所以就是尽可能的用1，如果最后剩余正好三个就显示7。这就转化成了判断奇数还是偶数的题，奇数就显示7111····，偶数就是1111···。注意要把7放在前面（我就踩坑了）。&lt;/p>
&lt;h4 id="代码实现">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">int&lt;/span> t,n;
&lt;span style="color:#66d9ef">int&lt;/span> cnt&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;span style="color:#66d9ef">if&lt;/span>(n&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
{
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>n&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>p;i&lt;span style="color:#f92672">++&lt;/span>) printf(&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
printf(&lt;span style="color:#e6db74">&amp;#34;7&amp;#34;&lt;/span>);
n&lt;span style="color:#f92672">-=&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>n&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>p;i&lt;span style="color:#f92672">++&lt;/span>) printf(&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>);
}
printf(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="b--infinite-prefixeshttpscodeforcescomcontest1295problemb">
B : &lt;a href="https://codeforces.com/contest/1295/problem/B">Infinite Prefixes&lt;/a>
&lt;a class="heading-link" href="#b--infinite-prefixeshttpscodeforcescomcontest1295problemb">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;h4 id="题意-1">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       给定一段01字符串 &lt;strong>s&lt;/strong> 为循环节，得到无限循环的01字符串 &lt;strong>t&lt;/strong>，求 &lt;strong>t&lt;/strong> 中有多少前缀满足0个数-1个数等于期望值&lt;strong>x&lt;/strong> （空前缀也算是一个前缀）&lt;/p>
&lt;blockquote>
&lt;p>前缀：例如&amp;quot;abcd&amp;quot;的前缀包括 &amp;quot; &amp;ldquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;ab&amp;rdquo;,&amp;ldquo;abc&amp;rdquo;,&amp;ldquo;abcd&amp;rdquo;.&lt;/p>
&lt;/blockquote>
&lt;h4 id="思路-1">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>首先我们先记录循环节 &lt;strong>s&lt;/strong> 中每个位置对应的01个数差，记为$num_i，i\in[1,n]$ （ &lt;strong>s&lt;/strong> 长度记为n）&lt;/p>
&lt;ul>
&lt;li>
&lt;p>首先我们可以发现当 &lt;strong>x=0&lt;/strong> 的时候，空前缀也会有贡献，因此不能忽略空前缀。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果循环节 &lt;strong>s&lt;/strong> 的01数相等，那么我们可以发现最后循环节一位$num_n$总为0，那么可以分两种情况来讨论&lt;/p>
&lt;ul>
&lt;li>如果循环节中存在大于等于1个前缀满足期望值x，那么就有无限个满足，因此输出-1&lt;/li>
&lt;li>如果循环节 &lt;strong>s&lt;/strong> 中不存在满足期望值的前缀，那么 &lt;strong>t&lt;/strong> 中也一定不存在&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>再来看一般情况，如果一个前缀中包含多个循环节 &lt;strong>s&lt;/strong> ,那么前面每个循环节对于最终01个数差的贡献总为$num_n$，因此我们可以用所期望的值 &lt;strong>x&lt;/strong>，利用1~n 循环减去每一位的 $num_i$，如果所得是$num_n$的非负倍数，那么就是符合期望的，否则不是。(本来一直这里不太明白，后来发现对于循环节中的每一个位置，在后续循环的过程中，如果$num_n$不为0，那么这个位置每次对应的值总是唯一的)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="代码实现-1">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">int&lt;/span> num[&lt;span style="color:#ae81ff">100005&lt;/span>];
&lt;span style="color:#66d9ef">int&lt;/span> t,cnt,n,x;
&lt;span style="color:#66d9ef">bool&lt;/span> flag&lt;span style="color:#f92672">=&lt;/span>false;
&lt;span style="color:#66d9ef">char&lt;/span> s[&lt;span style="color:#ae81ff">100005&lt;/span>];
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t);
&lt;span style="color:#66d9ef">while&lt;/span>(t&lt;span style="color:#f92672">--&lt;/span>)
{
cnt&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
flag&lt;span style="color:#f92672">=&lt;/span>false;
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>x);
scanf(&lt;span style="color:#e6db74">&amp;#34;%s&amp;#34;&lt;/span>,s&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(s[i]&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>)
{
num[i]&lt;span style="color:#f92672">=&lt;/span>num[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;span style="color:#66d9ef">else&lt;/span> num[i]&lt;span style="color:#f92672">=&lt;/span>num[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span>(num[i]&lt;span style="color:#f92672">==&lt;/span>x) flag&lt;span style="color:#f92672">=&lt;/span>true;
}
&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>num[n];
&lt;span style="color:#66d9ef">if&lt;/span>(p&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(flag&lt;span style="color:#f92672">==&lt;/span>true)
{
printf(&lt;span style="color:#e6db74">&amp;#34;-1&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">continue&lt;/span>;
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
printf(&lt;span style="color:#e6db74">&amp;#34;0&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">continue&lt;/span>;
}
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">int&lt;/span> m&lt;span style="color:#f92672">=&lt;/span>x&lt;span style="color:#f92672">-&lt;/span>num[i];
&lt;span style="color:#66d9ef">if&lt;/span>(m&lt;span style="color:#f92672">%&lt;/span>p&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>m&lt;span style="color:#f92672">/&lt;/span>p&lt;span style="color:#f92672">&amp;gt;=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
{
cnt&lt;span style="color:#f92672">++&lt;/span>;
}
}
}
&lt;span style="color:#66d9ef">if&lt;/span>(x&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>) cnt&lt;span style="color:#f92672">++&lt;/span>;
printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,cnt);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="c--obtain-the-stringhttpscodeforcescomcontest1295problemc">
C : &lt;a href="https://codeforces.com/contest/1295/problem/C">Obtain The String&lt;/a>
&lt;a class="heading-link" href="#c--obtain-the-stringhttpscodeforcescomcontest1295problemc">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;h4 id="题意-2">
题意
&lt;a class="heading-link" href="#%e9%a2%98%e6%84%8f-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       给定字符串 &lt;strong>s&lt;/strong> 和 &lt;strong>t&lt;/strong> ，每次从 &lt;strong>s&lt;/strong> 中选取子序列放入起始为空串的 &lt;strong>z&lt;/strong> 后，问最少需要多少次操作使得 &lt;strong>z=t&lt;/strong>&lt;/p>
&lt;h4 id="思路-2">
思路
&lt;a class="heading-link" href="#%e6%80%9d%e8%b7%af-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​       看了小姜老师的博客解法说是贪心，想了好一会，好像确实是可以贪心的···? 设置两个指针从 &lt;strong>s&lt;/strong> 和 &lt;strong>t&lt;/strong> 串的头部开始扫，对于 &lt;strong>t&lt;/strong> 串中的每个字母，循环扫 &lt;strong>s&lt;/strong> 串在其中找与它相同的，最终的答案就是扫 &lt;strong>s&lt;/strong> 串的次数。(小姜老师说这个实质上就是每次尽可能找尽可能多的后缀，仔细想想确实是这样。)不过这么一直暴力扫下去肯定不是最优的方法，想办法去优化。还是借鉴大佬的想法用一个lens*26的跳表，然后O(lent)扫一遍 &lt;strong>t&lt;/strong> 即可.&lt;/p>
&lt;blockquote>
&lt;p>跳表nxt的作用，用于寻找下一个所寻找字符在s中的位置。&lt;/p>
&lt;p>nxt[x][y]用于指向从x位置开始下一个y的位置+1 （next在C++属于保留字，注意不要踩坑）&lt;/p>
&lt;/blockquote>
&lt;h4 id="代码实现-2">
代码实现
&lt;a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">100005&lt;/span>;
&lt;span style="color:#66d9ef">char&lt;/span> s[maxn],t[maxn];
&lt;span style="color:#66d9ef">int&lt;/span> nxt[maxn][&lt;span style="color:#ae81ff">30&lt;/span>];
&lt;span style="color:#66d9ef">int&lt;/span> p,lens,lent;
&lt;span style="color:#66d9ef">int&lt;/span> pos,ans;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>p);
&lt;span style="color:#66d9ef">while&lt;/span>(p&lt;span style="color:#f92672">--&lt;/span>)
{
ans&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
scanf(&lt;span style="color:#e6db74">&amp;#34;%s&amp;#34;&lt;/span>,s&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
scanf(&lt;span style="color:#e6db74">&amp;#34;%s&amp;#34;&lt;/span>,t);
lent&lt;span style="color:#f92672">=&lt;/span>strlen(t),lens&lt;span style="color:#f92672">=&lt;/span>strlen(s&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;span style="color:#75715e">// printf(&amp;#34;%d&amp;#34;,lens);
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> c&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;c&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">26&lt;/span>;c&lt;span style="color:#f92672">++&lt;/span>)
{
nxt[lens&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][c]&lt;span style="color:#f92672">=-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>lens;i&lt;span style="color:#f92672">&amp;gt;=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">--&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span>(s[i]&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>&lt;span style="color:#f92672">==&lt;/span>c)
{
nxt[i][c]&lt;span style="color:#f92672">=&lt;/span>i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;span style="color:#66d9ef">else&lt;/span> nxt[i][c]&lt;span style="color:#f92672">=&lt;/span>nxt[i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][c];
}
}
pos&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;&lt;/span>lent;i&lt;span style="color:#f92672">++&lt;/span>)
{
pos&lt;span style="color:#f92672">=&lt;/span>nxt[pos][(&lt;span style="color:#66d9ef">int&lt;/span>)t[i]&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>];
&lt;span style="color:#66d9ef">if&lt;/span>(pos&lt;span style="color:#f92672">==-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
{
ans&lt;span style="color:#f92672">++&lt;/span>;
pos&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
pos&lt;span style="color:#f92672">=&lt;/span>nxt[pos][(&lt;span style="color:#66d9ef">int&lt;/span>)t[i]&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>];
&lt;span style="color:#66d9ef">if&lt;/span>(pos&lt;span style="color:#f92672">==-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
{
ans&lt;span style="color:#f92672">=-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">break&lt;/span>;
}
}
}
printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,ans);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;hr></description></item></channel></rss>