<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>STL on Zs's Blog</title><link>https://zzsqwq.github.io/tags/stl/</link><description>Recent content in STL on Zs's Blog</description><generator>Hugo -- gohugo.io</generator><language>cn</language><lastBuildDate>Sun, 16 Feb 2020 00:55:00 +0000</lastBuildDate><atom:link href="https://zzsqwq.github.io/tags/stl/index.xml" rel="self" type="application/rss+xml"/><item><title>关于STL的一些总结</title><link>https://zzsqwq.github.io/posts/28/</link><pubDate>Sun, 16 Feb 2020 00:55:00 +0000</pubDate><guid>https://zzsqwq.github.io/posts/28/</guid><description>&lt;h2 id="前言">
前言
&lt;a class="heading-link" href="#%e5%89%8d%e8%a8%80">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;p>​    STL之前只会用 stack 和 queue ，set 和 map 啥的也不太会用。学习一下。&lt;/p>
&lt;hr>
&lt;h2 id="队列queue">
队列(queue)
&lt;a class="heading-link" href="#%e9%98%9f%e5%88%97queue">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="概述">
概述
&lt;a class="heading-link" href="#%e6%a6%82%e8%bf%b0">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    队列是一种特殊的线性表，是一种先进先出（FIFO）的数据结构。它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。&lt;/p>
&lt;h3 id="用法">
用法
&lt;a class="heading-link" href="#%e7%94%a8%e6%b3%95">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    首先使用之前需要声明头文件 &lt;code>#include&amp;lt;queue&amp;gt;&lt;/code> ，通过 &lt;code>queue&amp;lt;typename&amp;gt; q&lt;/code> 的形式来进行定义队列，上述为定义了一个队列元素类型为 typename 的队列，队列名称为 q，typename可以为C++原有数据类型，例如int，char，string这些，也可以是自定义的结构体类型等。&lt;/p>
&lt;h3 id="主要函数及用途">
主要函数及用途
&lt;a class="heading-link" href="#%e4%b8%bb%e8%a6%81%e5%87%bd%e6%95%b0%e5%8f%8a%e7%94%a8%e9%80%94">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    使用下述函数都是用类似于 队列名称.函数名() 的形式，好比pop函数就是 q.pop()&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>push(x) 将元素x从队尾入队&lt;/li>
&lt;li>front( ) &amp;amp; back( ) 分别为获取队首元素和队尾元素，使用的时候必须确保队列不为空&lt;/li>
&lt;li>pop( ) 弹出队首元素，使用的时候必须确保队列不为空&lt;/li>
&lt;li>empty( ) 判断队列是否为空，空返回true，不空返回false&lt;/li>
&lt;li>size( ) 查询队列中有多少个元素&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;h3 id="应用实例">
应用实例
&lt;a class="heading-link" href="#%e5%ba%94%e7%94%a8%e5%ae%9e%e4%be%8b">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;queue&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> q;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
q.push(&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>q.empty()) printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,q.front()); &lt;span style="color:#75715e">//
&lt;/span>&lt;span style="color:#75715e">&lt;/span> q.push(&lt;span style="color:#ae81ff">2&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>q.empty()) printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,q.back());
printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,q.size());
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>q.empty()) q.pop();
&lt;span style="color:#66d9ef">if&lt;/span>(q.empty()) printf(&lt;span style="color:#e6db74">&amp;#34;queue is empty&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">else&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;queue is not empty&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>q.empty()) q.pop();
&lt;span style="color:#66d9ef">if&lt;/span>(q.empty()) printf(&lt;span style="color:#e6db74">&amp;#34;queue is empty&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e">运行结果
&lt;/span>&lt;span style="color:#75715e">1
&lt;/span>&lt;span style="color:#75715e">2
&lt;/span>&lt;span style="color:#75715e">2
&lt;/span>&lt;span style="color:#75715e">queue is not empty
&lt;/span>&lt;span style="color:#75715e">queue is empty
&lt;/span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;!-- raw HTML omitted -->
&lt;h2 id="栈stack">
栈(stack)
&lt;a class="heading-link" href="#%e6%a0%88stack">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="概述-1">
概述
&lt;a class="heading-link" href="#%e6%a6%82%e8%bf%b0-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    与队列相对应，是一种先进后出（FILO）的数据结构，限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。&lt;/p>
&lt;h3 id="用法-1">
用法
&lt;a class="heading-link" href="#%e7%94%a8%e6%b3%95-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    首先使用之前需要声明头文件 &lt;code>#include&amp;lt;stack&amp;gt;&lt;/code> ，通过 &lt;code>stack&amp;lt;typename&amp;gt; s&lt;/code> 的形式来进行定义栈，上述为定义了一个队列元素类型为 typename 的栈，栈名称为 s，typename可以为C++原有数据类型，例如int，char，string这些，也可以是自定义的结构体类型等。&lt;/p>
&lt;h3 id="主要函数及用途-1">
主要函数及用途
&lt;a class="heading-link" href="#%e4%b8%bb%e8%a6%81%e5%87%bd%e6%95%b0%e5%8f%8a%e7%94%a8%e9%80%94-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​ 使用下述函数都是用类似于 栈名称.函数名() 的形式，好比pop函数就是 s.pop()&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>push(x) 将元素x压栈&lt;/li>
&lt;li>pop( ) 将栈顶元素出栈，使用时确保栈不为空&lt;/li>
&lt;li>top( ) 获取栈顶元素的值，使用时要确保栈不为空&lt;/li>
&lt;li>size( ) 返回栈中元素的个数&lt;/li>
&lt;li>empty( ) 查询栈是否为空，空返回true，不空返回false&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;h3 id="应用实例-1">
应用实例
&lt;a class="heading-link" href="#%e5%ba%94%e7%94%a8%e5%ae%9e%e4%be%8b-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;stack&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
stack&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> s;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
s.push(&lt;span style="color:#ae81ff">1&lt;/span>);
s.push(&lt;span style="color:#ae81ff">2&lt;/span>);
printf(&lt;span style="color:#e6db74">&amp;#34;Now the top element is %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,s.top()); &lt;span style="color:#75715e">//Now the top element is 2
&lt;/span>&lt;span style="color:#75715e">&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;Now the stack size is %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,s.size()); &lt;span style="color:#75715e">//Now the stack size is 2
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>s.empty()) s.pop(); &lt;span style="color:#75715e">//元素2 弹出栈
&lt;/span>&lt;span style="color:#75715e">&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;Now the top element is %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,s.top()); &lt;span style="color:#75715e">//Now the top element is 1
&lt;/span>&lt;span style="color:#75715e">&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;Now the stack size is %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,s.size()); &lt;span style="color:#75715e">//Now the stack size is 1
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(s.empty()) printf(&lt;span style="color:#e6db74">&amp;#34;stack is empty&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">else&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;stack is not empty&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>); &lt;span style="color:#75715e">//stack is not empty
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>s.empty()) s.pop(); &lt;span style="color:#75715e">//元素1 弹出栈
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(s.empty()) printf(&lt;span style="color:#e6db74">&amp;#34;stack is empty&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>); &lt;span style="color:#75715e">//stack is empty
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;stack is not empty&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e">运行结果
&lt;/span>&lt;span style="color:#75715e">Now the top element is 2
&lt;/span>&lt;span style="color:#75715e">Now the stack size is 2
&lt;/span>&lt;span style="color:#75715e">Now the top element is 1
&lt;/span>&lt;span style="color:#75715e">Now the stack size is 1
&lt;/span>&lt;span style="color:#75715e">stack is not empty
&lt;/span>&lt;span style="color:#75715e">stack is empty
&lt;/span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;!-- raw HTML omitted -->
&lt;h2 id="映射map">
映射(map)
&lt;a class="heading-link" href="#%e6%98%a0%e5%b0%84map">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="概述-2">
概述
&lt;a class="heading-link" href="#%e6%a6%82%e8%bf%b0-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    map是STL的一个关联容器，提供一对一的数据处理能力，可以建立两个数据之间一一映射关系，map的定义需要关键字和存储值两个参数，我们可以通过关键字来查找对应的存储值（感觉类似于下标可以为任何类型的数组）吧，因为map的底层实现为红黑树（虽然我没学过），所以具有自动排序功能，也就是说map内部有序。&lt;/p>
&lt;h3 id="用法-2">
用法
&lt;a class="heading-link" href="#%e7%94%a8%e6%b3%95-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    使用之前声明头文件 &lt;code>#include&amp;lt;map&amp;gt;&lt;/code> ，通过 &lt;code>map&amp;lt;typename,typename&amp;gt; m&lt;/code> 的形式来定义映射，如果我们要建立string和int这两个类型之间的一一映射，就可以写成 &lt;code>map&amp;lt;string,int&amp;gt; m&lt;/code> ，我们可以通过关键字string来查找对应的int值。下述的讲述我们用这个m这个映射来进行。&lt;/p>
&lt;h3 id="迭代器">
迭代器
&lt;a class="heading-link" href="#%e8%bf%ad%e4%bb%a3%e5%99%a8">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    迭代器就是类似于指针吧，我们可以通过&lt;code>map&amp;lt;string,int&amp;gt;::iterator it&lt;/code> ，来定义一个对应映射的迭代器，他能够用来指向map中的元素，通过它们我们可以对map执行定点删除，遍历等操作。&lt;/p>
&lt;h3 id="主要函数及用途-2">
主要函数及用途
&lt;a class="heading-link" href="#%e4%b8%bb%e8%a6%81%e5%87%bd%e6%95%b0%e5%8f%8a%e7%94%a8%e9%80%94-2">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;h4 id="1-插入数据">
1. 插入数据
&lt;a class="heading-link" href="#1-%e6%8f%92%e5%85%a5%e6%95%b0%e6%8d%ae">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>通过insert函数进行插入
&lt;ul>
&lt;li>&lt;code>m.insert(pair&amp;lt;string,int&amp;gt;(&amp;quot;zs&amp;quot;,1))&lt;/code>&lt;/li>
&lt;li>&lt;code>m.insert(make_pair(&amp;quot;zs&amp;quot;,2)) &lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>通过类似于数组的形式插入
&lt;ul>
&lt;li>&lt;code>m[&amp;quot;zs&amp;quot;] = 2&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>​    上述两种形式有一定的区别，因为集合中元素是唯一的，用insert函数插入的时候，如果已经有相应的关键字，那么就不会插入。而如果用类似于数组的方式进行插入，就会覆盖原关键字对应的值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">map&lt;span style="color:#f92672">&amp;lt;&lt;/span>string,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> m;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
m.insert(pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>string,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;zs&amp;#34;&lt;/span>,&lt;span style="color:#ae81ff">1&lt;/span>));
printf(&lt;span style="color:#e6db74">&amp;#34;%d &amp;#34;&lt;/span>,m[&lt;span style="color:#e6db74">&amp;#34;zs&amp;#34;&lt;/span>]);
m.insert(make_pair(&lt;span style="color:#e6db74">&amp;#34;zs&amp;#34;&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>));
printf(&lt;span style="color:#e6db74">&amp;#34;%d &amp;#34;&lt;/span>,m[&lt;span style="color:#e6db74">&amp;#34;zs&amp;#34;&lt;/span>]);
m[&lt;span style="color:#e6db74">&amp;#34;zs&amp;#34;&lt;/span>]&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
printf(&lt;span style="color:#e6db74">&amp;#34;%d &amp;#34;&lt;/span>,m[&lt;span style="color:#e6db74">&amp;#34;zs&amp;#34;&lt;/span>]);
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> 输出结果 1 1 2
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2-查找数据">
2. 查找数据
&lt;a class="heading-link" href="#2-%e6%9f%a5%e6%89%be%e6%95%b0%e6%8d%ae">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​    通过find函数来查找关键字在map中的位置，如果找到了的话就返回对应的迭代器，如果没有找到的话就返回尾部的迭代器（end函数返回的值）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">map&lt;span style="color:#f92672">&amp;lt;&lt;/span>string,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> m;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
map&lt;span style="color:#f92672">&amp;lt;&lt;/span>string,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;::&lt;/span>iterator it;
m[&lt;span style="color:#e6db74">&amp;#34;zs&amp;#34;&lt;/span>]&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
it&lt;span style="color:#f92672">=&lt;/span>m.find(&lt;span style="color:#e6db74">&amp;#34;zs&amp;#34;&lt;/span>);
cout&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>first&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>second;
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> 输出结果 zs 1
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3-删除数据">
3. 删除数据
&lt;a class="heading-link" href="#3-%e5%88%a0%e9%99%a4%e6%95%b0%e6%8d%ae">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>清空map，可以使用clear函数。&lt;/li>
&lt;li>删除特定元素
&lt;ul>
&lt;li>先用find函数找到特定元素的迭代器，通过erase函数清除。&lt;/li>
&lt;li>直接通过相应关键字清除。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>删除一串序列，通过erase(起始迭代器，终点迭代器) 来实现。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">map&lt;span style="color:#f92672">&amp;lt;&lt;/span>string,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> m;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
map&lt;span style="color:#f92672">&amp;lt;&lt;/span>string,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;::&lt;/span>iterator it;
m[&lt;span style="color:#e6db74">&amp;#34;zs&amp;#34;&lt;/span>]&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
it&lt;span style="color:#f92672">=&lt;/span>m.find(&lt;span style="color:#e6db74">&amp;#34;zs&amp;#34;&lt;/span>);
m.erase(it);
it&lt;span style="color:#f92672">=&lt;/span>m.find(&lt;span style="color:#e6db74">&amp;#34;zs&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span>(it&lt;span style="color:#f92672">==&lt;/span>m.end())
printf(&lt;span style="color:#e6db74">&amp;#34;Not find zs&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
m[&lt;span style="color:#e6db74">&amp;#34;zs&amp;#34;&lt;/span>]&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
m.erase(&lt;span style="color:#e6db74">&amp;#34;zs&amp;#34;&lt;/span>);
it&lt;span style="color:#f92672">=&lt;/span>m.find(&lt;span style="color:#e6db74">&amp;#34;zs&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span>(it&lt;span style="color:#f92672">==&lt;/span>m.end())
printf(&lt;span style="color:#e6db74">&amp;#34;Not find zs&amp;#34;&lt;/span>);
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> 输出结果 Not find zs
&lt;/span>&lt;span style="color:#75715e"> Not find zs
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="4-其他">
4. 其他
&lt;a class="heading-link" href="#4-%e5%85%b6%e4%bb%96">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;blockquote>
&lt;ol>
&lt;li>count(&amp;ldquo;关键字&amp;rdquo;) 查询相应关键字在map中是否出现过，出现过返回1，没出现返回0&lt;/li>
&lt;li>empty( ) 判断是否为空，空返回true，不空返回false&lt;/li>
&lt;li>begin( ) &amp;amp; end( ) 分别为返回头和尾迭代器，配合迭代器可实行遍历&lt;/li>
&lt;li>iterator-&amp;gt;first &amp;amp; iterator-&amp;gt;second 分别对应相应迭代器指向的元素的关键字和值&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;hr>
&lt;!-- raw HTML omitted -->
&lt;h2 id="集合set">
集合(set)
&lt;a class="heading-link" href="#%e9%9b%86%e5%90%88set">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="概述-3">
概述
&lt;a class="heading-link" href="#%e6%a6%82%e8%bf%b0-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    set为一个容器，用来存储同一数据类型的数据，并且能从一个数据集合中取出数据，在set中每个元素的值都唯一（集合的唯一性），并且内部能根据元素的值自动进行排序。&lt;/p>
&lt;h3 id="用法-3">
用法
&lt;a class="heading-link" href="#%e7%94%a8%e6%b3%95-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    使用之前需要声明头文件 &lt;code>#include&amp;lt;set&amp;gt;&lt;/code> ，通过 &lt;code>set&amp;lt;typename&amp;gt; s&lt;/code> 来定义一个存储数据类型为typename的集合，名字叫做s。下述实例用此做基础。&lt;/p>
&lt;h3 id="迭代器-1">
迭代器
&lt;a class="heading-link" href="#%e8%bf%ad%e4%bb%a3%e5%99%a8-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>​    通过&lt;code>set&amp;lt;typename&amp;gt;::iterator it&lt;/code>，可以来定义一个相应的set的迭代器，用来遍历和指向其中元素。&lt;/p>
&lt;h3 id="主要函数及用途-3">
主要函数及用途
&lt;a class="heading-link" href="#%e4%b8%bb%e8%a6%81%e5%87%bd%e6%95%b0%e5%8f%8a%e7%94%a8%e9%80%94-3">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;h4 id="1-插入数据-1">
1. 插入数据
&lt;a class="heading-link" href="#1-%e6%8f%92%e5%85%a5%e6%95%b0%e6%8d%ae-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>插入特定元素可以通过 &lt;code>s.insert(3)&lt;/code> 插入对应键值，返回值为pair&amp;lt;set&lt;!-- raw HTML omitted -->::iterator,bool&amp;gt; ，后续bool变量标志是否成功，如果元素3已经存在，那么bool值为false，迭代器对应的是该元素在其中的位置，如果元素不存在其中，返回true，并且返回的迭代器对应的在集合中位置&lt;/li>
&lt;li>插入一个区间的元素，例如有整数数组a ，可以用 &lt;code>s.insert(a,a+3)&lt;/code> ，可以将a中的 a[0] a[1] a[2] 插入到set中。&lt;/li>
&lt;/ul>
&lt;h4 id="2-删除数据">
2. 删除数据
&lt;a class="heading-link" href="#2-%e5%88%a0%e9%99%a4%e6%95%b0%e6%8d%ae">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​    删除和map非常像，也是三种。具体可参考map讲解。&lt;/p>
&lt;h4 id="3-查找元素">
3. 查找元素
&lt;a class="heading-link" href="#3-%e6%9f%a5%e6%89%be%e5%85%83%e7%b4%a0">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;p>​    也是可以通过find函数，也是和map非常的像~&lt;/p>
&lt;h4 id="4-其他-1">
4. 其他
&lt;a class="heading-link" href="#4-%e5%85%b6%e4%bb%96-1">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h4>
&lt;blockquote>
&lt;ol>
&lt;li>begin() &amp;amp; end( ) 返回头尾迭代器，注意尾迭代器是尾元素的后一位。&lt;/li>
&lt;li>clear( ) 清除set容器中所有元素&lt;/li>
&lt;li>empty( ) 判断set容器是否为空，为空则返回true，不空返回false&lt;/li>
&lt;li>size( ) 返回当前set容器中元素的个数&lt;/li>
&lt;li>rebegin( ) &amp;amp; rend( ) 返回尾和头迭代器，配合reverse_iterator可以反序遍历set&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;hr>
&lt;h2 id="关于vector和string等">
关于vector和string等
&lt;a class="heading-link" href="#%e5%85%b3%e4%ba%8evector%e5%92%8cstring%e7%ad%89">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>vector好的学习文章 ： &lt;a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html">C++ vector容器浅析&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>string好的学习文章 ： &lt;a href="https://www.cnblogs.com/fzxiaoyi/p/12083144.html">C++ STL(一)介绍及string&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></description></item></channel></rss>